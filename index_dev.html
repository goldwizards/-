<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Core Barrier Defense</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
<div class="wrap">
  <div class="leftCol">
    <div class="stage" id="stage">
    <canvas id="c" width="960" height="540"></canvas>
    <div id="hudOverlay" class="hudOverlay" aria-label="HUD">
      <div class="hudTop">
        <div class="hudLeft">
          <div class="hudChip hudCrystal"><span class="hudIcon">âœ¦</span><span id="uiCrystals">0</span></div>
          
  <!-- Mobile Bottom Tabs + Bottom Sheet (A: 45vh) -->
  <div id="mobileTabs" class="mobileTabs" aria-label="í•˜ë‹¨ íƒ­">
    <button class="tabBtn" type="button" data-tab="ctrl" aria-selected="false">ì¡°ì‘</button>
    <button class="tabBtn" type="button" data-tab="status" aria-selected="false">ìƒíƒœ</button>
    <button class="tabBtn" type="button" data-tab="shop" aria-selected="false">êµ¬ë§¤</button>
  </div>

  <div id="bottomSheet" class="bottomSheet" aria-label="í•˜ë‹¨ íŒ¨ë„" aria-hidden="true">
    <div class="sheetHandle" id="sheetHandle" aria-label="ë“œë˜ê·¸ í•¸ë“¤"></div>
    <div class="sheetPage" id="sheetCtrl" role="region" aria-label="ì¡°ì‘ íŒ¨ë„"></div>
    <div class="sheetPage" id="sheetStatus" role="region" aria-label="ìƒíƒœ íŒ¨ë„"></div>
    <div class="sheetPage" id="sheetShop" role="region" aria-label="êµ¬ë§¤ íŒ¨ë„"></div>
  </div>
<div class="hudChip" id="hudWave">Wave 1</div>
        </div>

        <div class="hudCenter">
          <div class="hudBarRow">
            <span class="hudBarLabel">HP</span>
            <div class="hudBar"><div id="hudHpFill" class="hudFill hp"></div></div>
            <span id="hudHpText" class="hudBarText">0/0</span>
          </div>
          <div class="hudBarRow">
            <span class="hudBarLabel">SH</span>
            <div class="hudBar"><div id="hudShFill" class="hudFill sh"></div></div>
            <span id="hudShText" class="hudBarText">0/0</span>
          </div>
        </div>

        <div class="hudRightLine">
          <div class="hudChip">ë°©ì–´ <b id="hudArmor">0</b></div>
          <div class="hudChip">ë³´í˜¸ë§‰ë°©ì–´ <b id="hudShArmor">0</b></div>
          <div class="hudChip" id="hudMeta">x1.0</div>
        </div>

        <div class="hudStatusRow" id="hudStatusRow" aria-label="ìƒíƒœì´ìƒ"></div>

        <div class="hudPassive" id="hudPassiveWrap">
          <div class="hudChip wide" id="hudPassiveText">íŒ¨ì‹œë¸Œ: ë¯¸ì„ íƒ</div>
          <div class="hudGauge"><div id="hudPassiveFill" class="hudFill gauge"></div></div>
        </div>
      </div>
      <div class="hudToast" id="uiMsg"></div>
    </div>
  </div>

    <div class="bottomRow">
    <div class="miniPanel" id="wirePanel">
      <div class="miniTitleRow">
        <div class="miniTitle">ì™€ì´ì–´ ìƒíƒœ(Star UI)</div>
      </div>
      <canvas id="wire" width="360" height="190"></canvas>
      <div class="miniText" id="wireText"></div>
    </div>
    <div class="miniPanel" id="upgPanelPC">
      <div class="miniTitleRow">
        <div class="miniTitle">ì—…ê·¸ë ˆì´ë“œ</div>
        <button class="miniTitleBtn" data-upg-panel-toggle="pc" aria-expanded="true">ì ‘ê¸°</button>
      </div>
      <div id="uiUpgradesPC" class="small">
        <div class="upgControls" data-upg-ctx="pc">
          <div class="upgTabs">
            <button class="upgTabBtn" data-upg-tab="all">ì „ì²´</button>
            <button class="upgTabBtn" data-upg-tab="core">ì½”ì–´</button>
            <button class="upgTabBtn" data-upg-tab="turret">í¬íƒ‘</button>
            <button class="upgTabBtn" data-upg-tab="util">ìœ í‹¸</button>
          </div>
          <input class="upgSearch" type="text" maxlength="32" placeholder="ì—…ê·¸ë ˆì´ë“œ ê²€ìƒ‰" data-upg-search>
          <button class="upgCtlBtn" data-upg-only>êµ¬ë§¤ê°€ëŠ¥ë§Œ: OFF</button>
          <button class="upgCtlBtn" data-upg-sort>ì •ë ¬: ê¸°ë³¸</button>
        </div>
        <div class="upgHint">ê²€ìƒ‰(/) Â· íƒ­ ì „í™˜ Â· ì •ë ¬/êµ¬ë§¤ê°€ëŠ¥ í† ê¸€</div>
        <div id="uiUpgListPC"></div>
      </div>
    </div>
  </div>
  </div>

  <div class="panel">
    <div class="panelMobileTop mobileOnly">
      <div class="title">ë©”ë‰´</div>
      <button id="btnPanelClose" class="closeBtn">ë‹«ê¸° âœ•</button>
    </div>
<h1>ìˆ˜ì •íƒ‘ ë³´í˜¸ë§‰ ë””íœìŠ¤</h1>
    <p class="small">
      ì¡°ì‘:
      <span class="kbd">ì¢Œí´ë¦­</span> í¬íƒ‘ ì„¤ì¹˜ /
      <span class="kbd">ìš°í´ë¦­</span> ë˜ëŠ” <span class="kbd">X</span> í¬íƒ‘ íŒë§¤(í™˜ë¶ˆ 80%) /
      <span class="kbd">1</span> ê¸°ë³¸ /
      <span class="kbd">2</span> ìŠ¬ë¡œìš° /
      <span class="kbd">3</span> ìŠ¤í”Œë˜ì‹œ /
      <span class="kbd">Space</span> ê¸´ê¸‰ ë³´í˜¸ë§‰ /
      <span class="kbd">E</span> ì—ë„ˆì§€í¬ /
      <span class="kbd">F</span> ìˆ˜ë¦¬ /
      <span class="kbd">R</span> ì¬ì‹œì‘
    </p>

    <div class="sep"></div>
<p class="stat" id="uiStats" style="display:none"></p>
<p class="small" id="uiEvent"></p>
    <div class="miniPanel" style="margin-top:10px;">
      <div class="miniTitleRow">
        <div class="miniTitle">ëŸ° ê¸°ë¡</div>
        <button id="btnResetRecords" class="miniTitleBtn">ì´ˆê¸°í™”</button>
      </div>
      <div class="miniText" id="uiRecords"></div>
    </div>

    <div class="miniPanel" style="margin-top:10px;">
      <div class="miniTitleRow">
        <div class="miniTitle">ë§µ ê¸°ë¯¹</div>
        <span class="badge" id="uiMapBonus">Ã—1.00</span>
      </div>
      <div class="miniText" id="uiMap"></div>
    </div>
    <div class="miniPanel" style="margin-top:10px;">
      <div class="miniTitle">ë‹¤ìŒ ì›¨ì´ë¸Œ ì •ë³´</div>
      <div class="miniText" id="uiPreview"></div>
    </div>
    <div class="miniPanel" style="margin-top:10px;">
      <div class="miniTitleRow">
        <div class="miniTitle">ìœ„í—˜ ê³„ì•½</div>
        <span class="badge" id="uiContractMul">Ã—1.00</span>
      </div>
      <div class="row" style="flex-wrap:wrap">
        <button class="miniBtn" id="btnContractNone">ì„ íƒ ì•ˆí•¨</button>
        <button class="miniBtn" id="btnContractHP">ì²´ë ¥â†‘</button>
        <button class="miniBtn" id="btnContractSPD">ì†ë„â†‘</button>
        <button class="miniBtn" id="btnContractSH">ë³´í˜¸ë§‰â†‘</button>
      </div>
      <div class="miniText small" id="uiContractHint"></div>
    </div>

    <div class="miniPanel" style="margin-top:10px;">
      <div class="miniTitleRow">
        <div class="miniTitle">ì›¨ì´ë¸Œ ëª©í‘œ</div>
        <span class="badge" id="uiMissionReward">+0</span>
      </div>
      <div class="miniText" id="uiMission"></div>
    </div>
<p class="small" id="uiCheat"></p>

    <div class="row">
      <button id="btnSound">ì‚¬ìš´ë“œ ON</button>
      <button id="btnVol">ë³¼ë¥¨ 85%</button>
    </div>
    <div class="row" style="align-items:center">
      <input id="volSlider" type="range" min="0" max="100" step="1" value="85" style="flex:1">
      <div class="small" id="volVal">85%</div>
    </div>
    <div class="row">
      <button id="btnToggleWire">ì™€ì´ì–´ í‘œì‹œ</button>
    </div>

    <div class="row">
      <button id="btnBg">ë°°ê²½ ì•½í•¨</button>
    </div>

    <div class="row">
      <button id="btnWave" class="btnPrimary">ì›¨ì´ë¸Œ ì‹œì‘</button>
      <button id="btnRestart">ì¬ì‹œì‘</button>
    </div>

    <div class="row">
      <button id="btnRepair" class="btnPrimary">ìˆ˜ë¦¬</button>
      <button id="btnEnergy" class="btnPrimary">ì—ë„ˆì§€í¬</button>
    </div>
    <div class="row">
      <button id="btnBarrier" class="btnPrimary">ì¥ë²½</button>
    </div>

    <div class="row">
      <button id="btnSpeed">ë°°ì† 1.0x</button>
      <button id="btnCheat">ì¹˜íŠ¸ OFF</button>
    </div>

    <div class="row">
      <button id="btnBugReport">ë²„ê·¸ ë¦¬í¬íŠ¸ ë³µì‚¬</button>
      <button id="btnSelfCheck">ìê°€ì§„ë‹¨</button>
    </div>
    <div class="miniPanel" style="margin-top:10px;">
  <div class="miniTitleRow corePassiveHeader">
    <div class="miniTitle">ì½”ì–´ íŒ¨ì‹œë¸Œ</div>
  </div>
  <div id="uiCorePassiveChosenWrap" class="corePassiveChosenWrap">
    <div id="uiCorePassiveChosenName" class="corePassiveChosenName">ë¯¸ì„ íƒ</div>
    <div id="uiCorePassiveChosenTag" class="corePassiveChosenTag small">ê²Œì„ í™”ë©´ì—ì„œ ì½”ì–´ íŒ¨ì‹œë¸Œë¥¼ ì„ íƒí•˜ì‹­ì‹œì˜¤.</div>
  </div>
  <div class="corePickGrid corePickGridTight corePickGridHidden">
        <button id="btnCoreRebuild" class="coreBtn blue">
          ğŸ”µ ì¬ê±´ ì½”ì–´
          <small>ì•ˆì • / ì¥ê¸°ì „</small>
        </button>
        <button id="btnCoreResonance" class="coreBtn orange">
          ğŸŸ  ê³µëª… ë°˜ê²© ì½”ì–´
          <small>ê³µê²© / í¬íƒ‘ ì¤‘ì‹¬</small>
        </button>
        <button id="btnCoreOverload" class="coreBtn red">
          ğŸ”´ ì„ê³„ ê³¼ë¶€í•˜
          <small>ì €ì²´ë ¥: í¬íƒ‘ í™”ë ¥â†‘ / í”¼í•´ê°ì†Œâ†‘</small>
        </button>
        <button id="btnCoreOverdrive" class="coreBtn purple">
          ğŸŸ£ ì½”ì–´ ì˜¤ë²„ë“œë¼ì´ë¸Œ
          <small>ìˆ˜ì •íƒ‘ ì§ì ‘ ê³µê²© (ì €ì²´ë ¥ ê°•í•´ì§)</small>
        </button>
      </div>
  <div class="corePassiveSplit">
    <div class="corePassiveSplitTitle small">íŒ¨ì‹œë¸Œ íš¨ê³¼</div>
    <div id="uiCorePassiveDesc" class="corePassiveDesc small">
      íŒ¨ì‹œë¸Œë¥¼ ì„ íƒí•˜ë©´ <span class="kbd">ì›¨ì´ë¸Œ ì‹œì‘</span>ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. (ì¬ì‹œì‘ ì‹œ ë‹¤ì‹œ ì„ íƒ)
    </div>
  </div>
</div>

<div id="finalSupportPanel" class="miniPanel hidden" style="margin-top:10px;">
  <div class="miniTitleRow">
    <div class="miniTitle">ìµœì¢… ì§€ì› ì„ íƒ (ì›¨ì´ë¸Œ 30 ì „)</div>
  </div>
  <div class="corePickGrid" style="grid-template-columns:1fr 1fr;">
    <button id="btnFinalOffense" class="coreBtn orange">
      ğŸŸ  í™”ë ¥ ì§€ì›
      <small>í¬íƒ‘ í”¼í•´ +15%</small>
    </button>
    <button id="btnFinalDefense" class="coreBtn blue">
      ğŸ”µ ë°©í˜¸ ê°•í™”
      <small>ë³´í˜¸ë§‰ ì¬ìƒ +25%</small>
    </button>
  </div>
  <div id="uiFinalSupportDesc" class="corePassiveDesc small">
    ì›¨ì´ë¸Œ 30 ì‹œì‘ ì „ì— 1ê°œë¥¼ ì„ íƒí•˜ì‹­ì‹œì˜¤. (ì„ íƒí•˜ì§€ ì•Šìœ¼ë©´ ìë™ìœ¼ë¡œ ë°©í˜¸ ê°•í™”)
  </div>
</div>

    <div class="miniPanel" id="upgPanelSide" style="margin-top:10px;">
      <div class="miniTitleRow">
        <div class="miniTitle">ì—…ê·¸ë ˆì´ë“œ</div>
        <button class="miniTitleBtn" data-upg-panel-toggle="side" aria-expanded="true">ì ‘ê¸°</button>
      </div>
      <div id="uiUpgrades" class="small">
        <div class="upgControls" data-upg-ctx="side">
          <div class="upgTabs">
            <button class="upgTabBtn" data-upg-tab="all">ì „ì²´</button>
            <button class="upgTabBtn" data-upg-tab="core">ì½”ì–´</button>
            <button class="upgTabBtn" data-upg-tab="turret">í¬íƒ‘</button>
            <button class="upgTabBtn" data-upg-tab="util">ìœ í‹¸</button>
          </div>
          <input class="upgSearch" type="text" maxlength="32" placeholder="ì—…ê·¸ë ˆì´ë“œ ê²€ìƒ‰" data-upg-search>
          <button class="upgCtlBtn" data-upg-only>êµ¬ë§¤ê°€ëŠ¥ë§Œ: OFF</button>
          <button class="upgCtlBtn" data-upg-sort>ì •ë ¬: ê¸°ë³¸</button>
        </div>
        <div class="upgHint">ê²€ìƒ‰(/) Â· íƒ­ ì „í™˜ Â· ì •ë ¬/êµ¬ë§¤ê°€ëŠ¥ í† ê¸€</div>
        <div id="uiUpgListSide"></div>
      </div>
    </div>

    <div class="row">
      <button id="btnEasy">ë‚œì´ë„â†“</button>
      <button id="btnHard">ë‚œì´ë„â†‘</button>
    </div>

  </div>
</div>


<!-- ===== Main Menu Overlay (v11-step29) ===== -->
<div id="mainMenuMask" class="overlayMask">
  <div class="overlayCard" role="dialog" aria-modal="true" aria-label="ë©”ì¸ ë©”ë‰´">
    <div class="overlayTitle">ë¬´ìŠ¨ê²Œì„ë§Œë“¤ê¹Œ</div>
    <div class="mmBadgeRow"><div id="mmDiffBadge" class="mmBadge">NORMAL</div></div>
    <div id="mmNote" class="mmNote">ë‚œì´ë„: ë³´í†µ Â· (1ì›¨ì´ë¸Œ ì‹œì‘ í›„ ë³€ê²½ ë¶ˆê°€)</div>

    <div class="mmBox">
      <div class="mmBoxTitle">ê¸°ë¡ (í˜„ì¬ ë‚œì´ë„)</div>
      <div id="mmRecords" class="smallDim">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</div>
    </div>

    <div class="mmBtns">
      <button id="btnMMStart" class="mmBtn primary">ê²Œì„ ì‹œì‘</button>
      <button id="btnMMOpenDiff" class="mmBtn">ë‚œì´ë„ ì„ íƒ</button>
      <button id="btnMMResetRec" class="mmBtn danger">ê¸°ë¡ ì´ˆê¸°í™”</button>
    </div>
  </div>
</div>

<!-- ===== Difficulty Pick Overlay ===== -->
<div id="diffPickMask" class="overlayMask hidden" aria-label="ë‚œì´ë„ ì„ íƒ">
  <div class="overlayCard" role="dialog" aria-modal="true">
    <div class="overlayTitle" style="font-size:22px;">ë‚œì´ë„ ì„ íƒ</div>
    <div class="diffPickGrid">
      <button id="btnDiffPickEasy" class="diffPickBtn easy">EASY Â· ì‰¬ì›€</button>
      <button id="btnDiffPickNormal" class="diffPickBtn normal">NORMAL Â· ë³´í†µ</button>
      <button id="btnDiffPickHard" class="diffPickBtn hard">HARD Â· ì–´ë ¤ì›€</button>
    </div>
    <div class="smallDim">
      ë‚œì´ë„ í”„ë¦¬ì…‹ì€ ì  <b>ì²´ë ¥/ê³µê²©/ìŠ¤í°/ë³´ìƒ</b>ì—ë§Œ ì ìš©ë©ë‹ˆë‹¤. (ì €ì¥ ì•ˆ í•¨)<br>
      ì‹œì‘(1ì›¨ì´ë¸Œ) ì´í›„ì—ëŠ” ë‚œì´ë„ ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.
    </div>
    <div class="diffFooter">
      <button id="btnDiffPickBack" class="mmBtn">ë’¤ë¡œ</button>
      <button id="btnDiffPickClose" class="mmBtn primary">ì ìš©</button>
    </div>
  </div>
</div>

<div id="mobileBar" class="mobileBar hidden" aria-label="ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤">
  <div class="mbRow">
    <button id="mbBasic" class="mbBtn primary"><span>ê¸°ë³¸</span><small>ì„¤ì¹˜(35)</small></button>
    <button id="mbSlow" class="mbBtn primary"><span>ìŠ¬ë¡œìš°</span><small>ì„¤ì¹˜(45)</small></button>
    <button id="mbSplash" class="mbBtn primary"><span>ìŠ¤í”Œë˜ì‹œ</span><small>ì„¤ì¹˜(60)</small></button>
  </div>
  <div class="mbRow">
    <button id="mbWave" class="mbBtn primary"><span>ì›¨ì´ë¸Œ</span><small>ì‹œì‘</small></button>
    <button id="mbRepair" class="mbBtn"><span>ìˆ˜ë¦¬</span><small>F</small></button>
    <button id="mbAegis" class="mbBtn"><span>ê¸´ê¸‰</span><small>Space</small></button>
    <button id="mbSell" class="mbBtn danger"><span>íŒë§¤ OFF</span><small>ê¸¸ê²Œ=íŒë§¤</small></button>
  </div>
  <div class="mbRow hidden" id="mbFinalRow">
  <button id="mbFinalOffense" class="mbBtn primary"><span>í™”ë ¥</span><small>+15%</small></button>
  <button id="mbFinalDefense" class="mbBtn primary"><span>ë°©í˜¸</span><small>+25%</small></button>
</div>
  <div class="mbRow" id="mbCheatRow">
    <button id="mbCheat" class="mbBtn"><span>ì¹˜íŠ¸ OFF</span><small>T</small></button>
    <button id="mbMenu" class="mbBtn"><span>ë©”ë‰´</span><small>ì—…ê¸€/íŒ¨ì‹œë¸Œ</small></button>
    <button id="mbCheatMenu" class="mbBtn danger" disabled><span>ì¹˜íŠ¸ ê¸°ëŠ¥</span><small>ì—´ê¸°</small></button>
  </div>
<div class="mbRow" id="mbWireRow">
    <button id="mbEnergy" class="mbBtn primary"><span>ì—ë„ˆì§€í¬</span><small>800</small></button>
    <button id="mbBarrier" class="mbBtn primary"><span>ì¥ë²½</span><small>-35</small></button>
  </div>
<div class="mbHint">íŒ: í¬íƒ‘ì„ <b>ê¸¸ê²Œ ëˆ„ë¥´ë©´ íŒë§¤</b>ë©ë‹ˆë‹¤. (ë¹Œë“œ/í´ë¦¬ì–´ì—ì„œë§Œ)</div>
</div>
<div id="cheatModal" class="cheatModal hidden" aria-label="ì¹˜íŠ¸ ë©”ë‰´">
  <div class="cheatCard" role="dialog" aria-modal="true">
    <div class="cheatTitle">ì¹˜íŠ¸</div>
    <div class="cheatGrid">
      <button id="chCrystals">+500 í¬ë¦¬ìŠ¤íƒˆ</button>
      <button id="chMaxUpg">ì—…ê¸€ MAX</button>
      <button id="chHeal">HP í’€íšŒë³µ</button>
      <button id="chShield">ë³´í˜¸ë§‰ í’€ì¶©ì „</button>
      <button id="chKill">ì  ì œê±°</button>
      <button id="chSkip">ì›¨ì´ë¸Œ ìŠ¤í‚µ</button>
      <button id="chGod">ë¬´ì  í† ê¸€</button>
      <button id="chPassiveFull">íŒ¨ì‹œë¸Œ 100%</button>
      <button id="chClose" class="danger">ë‹«ê¸°</button>
    </div>
    <div class="cheatNote">â€» ëª¨ë°”ì¼: ë²„íŠ¼ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥ / PC: T í† ê¸€ í›„ K,H,J,B,N,U,G</div>
  </div>
</div>

<div id="panelBackdrop" class="panelBackdrop hidden" aria-hidden="true"></div>

<script>
window.__CBD_BOOT_OK = true;


(() => {
  try {
  // ---------- Canvas ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // ---------- Battlefield Background (canvas-only) ----------
  const BG_GROUND = new Image();
  let BG_GROUND_READY = false;
  BG_GROUND.onload = () => { BG_GROUND_READY = true; };
  BG_GROUND.src = 'bg_ground_sanctuary_topdown.png';

  // ---------- Battlefield BG cache (perf) ----------
  // ë°°ê²½(ì´ë¯¸ì§€/ë² ì¼/ë¹„ë„¤íŠ¸) + ê·¸ë¦¬ë“œ + ì„¤ì¹˜ë°˜ê²½ì€ í”„ë ˆì„ë§ˆë‹¤ ìƒˆë¡œ ê·¸ë¦¬ë©´ ëª¨ë°”ì¼ì—ì„œ ë¶€ë‹´ì´ í½ë‹ˆë‹¤.
  // bgMode/ìº”ë²„ìŠ¤ í¬ê¸°/ì´ë¯¸ì§€ ë¡œë“œ ìƒíƒœê°€ ë°”ë€” ë•Œë§Œ í•œ ë²ˆ ë Œë”ë§í•˜ê³ , drawì—ì„œëŠ” drawImageë§Œ í•©ë‹ˆë‹¤.
  const BG_CACHE = { canvas: null, ctx: null, mode: -1, w: 0, h: 0, groundReady: false };

  function ensureBattleBgCache(bgMode){
    bgMode = (typeof bgMode === 'number') ? bgMode : 1;
    const need = (
      !BG_CACHE.canvas ||
      BG_CACHE.mode !== bgMode ||
      BG_CACHE.w !== W ||
      BG_CACHE.h !== H ||
      BG_CACHE.groundReady !== BG_GROUND_READY
    );
    if (!need) return;

    BG_CACHE.mode = bgMode;
    BG_CACHE.w = W;
    BG_CACHE.h = H;
    BG_CACHE.groundReady = BG_GROUND_READY;

    if (!BG_CACHE.canvas) {
      BG_CACHE.canvas = document.createElement('canvas');
      BG_CACHE.ctx = BG_CACHE.canvas.getContext('2d');
    }
    const bcv = BG_CACHE.canvas;
    const bctx = BG_CACHE.ctx;
    bcv.width = W;
    bcv.height = H;

    // ---- base ----
    bctx.setTransform(1,0,0,1,0,0);
    bctx.clearRect(0,0,W,H);
    bctx.fillStyle = '#0b0f14';
    bctx.fillRect(0,0,W,H);

    // ---- ground image + veil/vignette ----
    if (bgMode > 0) {
      if (BG_GROUND_READY) {
        const iw = BG_GROUND.width || 1, ih = BG_GROUND.height || 1;
        const s = Math.max(W/iw, H/ih);
        const dw = iw*s, dh = ih*s;
        const dx = (W - dw)/2;
        const dy = (H - dh)/2;
        bctx.save();
        bctx.globalAlpha = (bgMode === 2) ? 0.88 : 0.62;
        bctx.drawImage(BG_GROUND, dx, dy, dw, dh);
        bctx.restore();
      } else {
        // fallback: soft stone tiles (very cheap)
        bctx.save();
        bctx.fillStyle = '#101827';
        for (let y=0;y<H;y+=96){
          for (let x=0;x<W;x+=96){
            const o = ((x/96 + y/96) % 2) ? 0.06 : 0.03;
            bctx.globalAlpha = o;
            bctx.fillRect(x, y, 92, 92);
          }
        }
        bctx.restore();
      }

      // readability veil
      bctx.save();
      bctx.fillStyle = (bgMode === 2) ? 'rgba(10,14,20,0.16)' : 'rgba(10,14,20,0.26)';
      bctx.fillRect(0,0,W,H);

      // vignette
      const vg = bctx.createRadialGradient(W*0.5, H*0.5, Math.min(W,H)*0.18, W*0.5, H*0.5, Math.max(W,H)*0.72);
      vg.addColorStop(0, 'rgba(0,0,0,0)');
      vg.addColorStop(1, (bgMode === 2) ? 'rgba(0,0,0,0.32)' : 'rgba(0,0,0,0.38)');
      bctx.fillStyle = vg;
      bctx.fillRect(0,0,W,H);
      bctx.restore();
    }

    // ---- grid (static) ----
    bctx.globalAlpha = 0.15;
    bctx.strokeStyle = '#233047';
    bctx.lineWidth = 1;
    for (let x=0;x<=W;x+=32){ bctx.beginPath(); bctx.moveTo(x,0); bctx.lineTo(x,H); bctx.stroke(); }
    for (let y=0;y<=H;y+=32){ bctx.beginPath(); bctx.moveTo(0,y); bctx.lineTo(W,y); bctx.stroke(); }
    bctx.globalAlpha = 1;

    // ---- build radius (static) ----
    // CORE_POS/BUILD_RADIUSëŠ” ì•„ë˜ì—ì„œ ì •ì˜ë˜ì§€ë§Œ, drawì—ì„œ í˜¸ì¶œë˜ëŠ” ì‹œì ì—ëŠ” ì´ë¯¸ ê°’ì´ ì¤€ë¹„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
    try {
      bctx.globalAlpha = 0.16;
      bctx.beginPath();
      bctx.arc(CORE_POS.x, CORE_POS.y, BUILD_RADIUS, 0, Math.PI*2);
      bctx.fillStyle = '#1f2937';
      bctx.fill();
      bctx.globalAlpha = 1;
    } catch {}
  }

  const wireCanvas = document.getElementById("wire");
  const wctx = wireCanvas.getContext("2d");
  const wireText = document.getElementById("wireText");

  // ---------- Utils ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>a+Math.random()*(b-a);
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const dist  = (ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);
  const nowSec = ()=>performance.now()/1000;

  

  // ---------- Passive scaling (Hard mode) ----------
  const passiveHardMul = ()=> (typeof state !== 'undefined' && state && state.diffId === "hard") ? 0.8 : 1.0;
  const passiveScale = (v)=> v * passiveHardMul();
  const passiveScaleMul = (mul)=> 1 + (mul - 1) * passiveHardMul();
  const passiveScaleReduction = (red)=> 1 - red * passiveHardMul();
  const passiveScaleToward1 = (mul)=> 1 - (1 - mul) * passiveHardMul();
  const passiveScaleThresholdToward1 = (th)=> 1 - (1 - th) * passiveHardMul();
// ---------- Ending ----------
  const FINAL_WAVE = 30;

  // ---------- SFX (WebAudio, ì™¸ë¶€ íŒŒì¼ ì—†ì´ í•©ì„±) ----------
  const SFX = (() => {
    let ctx = null, master = null, noiseBuf = null;
    // BGM ì „ìš© ë¯¹ì„œ(íš¨ê³¼ìŒê³¼ ë¶„ë¦¬í•´ì„œ ë³´ìŠ¤ ì›¨ì´ë¸Œì—ì„œë§Œ ê°•í•˜ê²Œ ë§Œë“¤ê¸°)
    let bgmMix = null, bgmLP = null, bgmDrive = null;
    let enabled = true;
    // ê¸°ë³¸ ë³¼ë¥¨(ìš”ì²­: 0.75)
    let volume = 0.75;

    function makeDriveCurve(amount=0.35){
      // amount: 0(ê±°ì˜ ì—†ìŒ) ~ 0.8(ê°•í•¨)
      const n = 2048;
      const curve = new Float32Array(n);
      const k = Math.max(0.0001, Math.min(1.0, amount)) * 40;
      for (let i=0;i<n;i++){
        const x = (i*2)/(n-1) - 1;
        curve[i] = Math.tanh(k*x) / Math.tanh(k);
      }
      return curve;
    }

    function ensure(){
      if (ctx) return;
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      master = ctx.createGain();
      master.gain.value = volume;
      master.connect(ctx.destination);

      // --- BGM chain: (notes) -> LPF -> Drive -> bgmMix -> master
      bgmMix = ctx.createGain();
      bgmMix.gain.value = 0.82;
      bgmMix.connect(master);

      bgmLP = ctx.createBiquadFilter();
      bgmLP.type = "lowpass";
      bgmLP.frequency.value = 8000;
      bgmLP.Q.value = 0.8;

      bgmDrive = ctx.createWaveShaper();
      bgmDrive.curve = makeDriveCurve(0.30);
      bgmDrive.oversample = "2x";

      bgmLP.connect(bgmDrive).connect(bgmMix);

      noiseBuf = ctx.createBuffer(1, ctx.sampleRate, ctx.sampleRate);
      const d = noiseBuf.getChannelData(0);
      for (let i=0;i<d.length;i++) d[i] = Math.random()*2 - 1;
    }

    async function unlock(){
      ensure();
      if (ctx.state === "suspended") {
        try { await ctx.resume(); } catch {}
      }
      // iOS/Safari ëŒ€ì‘: ë§¤ìš° ì§§ì€ ë¬´ìŒ ì¬ìƒ
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      g.gain.value = 0.0001;
      o.connect(g).connect(master);
      o.start();
      o.stop(ctx.currentTime + 0.01);
      if (enabled && volume > 0.001) startBgm();
    }

    function setEnabled(v){
      enabled = !!v;
      if (!enabled) stopBgm();
      else if (ctx && ctx.state === "running" && volume > 0.001) startBgm();
    }
    function getEnabled(){ return enabled; }

    function setVolume(v){
      volume = clamp(v, 0, 1);
      ensure();
      master.gain.value = volume;
      if (volume <= 0.001) stopBgm();
      else if (enabled && ctx && ctx.state === "running") startBgm();
    }
    function getVolume(){ return volume; }

    

    // ---------- BGM (WebAudio, ì™¸ë¶€ íŒŒì¼ ì—†ì´ í•©ì„± ë£¨í”„) ----------
    // ëª©í‘œ: ê¸°ë³¸ì€ ë” ê¸´ì¥ê° ìˆê²Œ, ë³´ìŠ¤ ì›¨ì´ë¸Œì—ì„œëŠ” í™•ì‹¤íˆ "ê°•í•˜ê²Œ"(í…œí¬/ì‚¬ìš´ë“œ/ë ˆì´ì–´ ì¦ê°€)
    let bgmPlaying = false;
    let bgmTimer = null;
    let bgmStep = 0;
    let bgmNextTime = 0;

    const BGM_TICK_MS = 35;       // ìŠ¤ì¼€ì¤„ëŸ¬ ì£¼ê¸°(ì¡°ê¸ˆ ë” ì´˜ì´˜)
    const BGM_AHEAD = 0.22;       // ì•ì„œì„œ ìŠ¤ì¼€ì¤„í•  ì‹œê°„(ì´ˆ)
    let bgmStepsPerBar = 16; // ê¸°ë³¸ 4/4(16 x 16th)
    let bgmBars = 4;
    let bgmLoopSteps = bgmStepsPerBar * bgmBars;
    let bgmSwing = 0.0; // 0.0~0.20 ì •ë„(í™€ìˆ˜ 16ë¶„ì„ ë’¤ë¡œ ë¯¸ëŠ” ì…”í”Œ)

    // BGM ëª¨ë“œ: build(ê¸°ë³¸) / wave(ì „íˆ¬) / boss(ë³´ìŠ¤) / fail / win
    let bgmMode = "build";
    let bgmBpm = 112;

        const BGM_MODES = {
      // âœ… ì „ì²´ í…Œë§ˆ êµì²´: ë” ë¶€ë“œëŸ½ê³ (ëœ ì‚-), ê³µê°„ê° ìˆëŠ” 'ì‚¬ì›/ìš°ì£¼' ëŠë‚Œ
      build:{ bpm:104, mix:0.72, lp:7200,  drive:0.20, spb:16, bars:4, swing:0.00 },
      wave: { bpm:118, mix:0.88, lp:10500, drive:0.32, spb:16, bars:4, swing:0.04 },
      boss: { bpm:132, mix:1.02, lp:14000, drive:0.52, spb:16, bars:4, swing:0.08 },
      // âœ… ìµœì¢… ë³´ìŠ¤: í˜ì´ì¦ˆë³„ë¡œ í…Œë§ˆ/ë°€ë„/ë“œë¼ì´ë¸Œê°€ í™•ì‹¤íˆ ë‹¬ë¼ì§
      final1:{ bpm:144, mix:1.08, lp:16000, drive:0.62, spb:16, bars:4, swing:0.10 },
      final2:{ bpm:152, mix:1.12, lp:17500, drive:0.70, spb:16, bars:4, swing:0.12 },
      final3:{ bpm:160, mix:1.18, lp:19000, drive:0.78, spb:16, bars:4, swing:0.13 },
      // game over: 4/4 ëŠë¦¬ê²Œ(ë°•ì ì•ˆì •), ìŠ¬í”ˆ íŒ¨ë“œ ì¤‘ì‹¬
      fail: { bpm: 76, mix:0.42, lp:2600,  drive:0.08, spb:16, bars:4, swing:0.00 },
      // ending: 4/4 ë°ì€ ì§„í–‰(ë°•ì ì•ˆì •)
      win:  { bpm:112, mix:0.66, lp:12000, drive:0.16, spb:16, bars:4, swing:0.03 },
    };

    // ì½”ë“œ ì§„í–‰(4ë§ˆë”” ë£¨í”„) â€” ì „ì²´ í…Œë§ˆ êµì²´(ëœ ì‚- + ê³µê°„ê°)
    const CHORDS_BUILD = [
      [60, 64, 67, 74], // C(add9)
      [57, 60, 64, 67], // Am7
      [53, 57, 60, 64], // Fmaj7
      [55, 60, 62, 67], // Gsus4
    ];
    const ROOTS_BUILD = [36, 45, 41, 43]; // C2, A2, F2, G2 // A2, D2, F2, E2

    const CHORDS_WAVE = [
      [62, 65, 69, 72], // Dm7
      [58, 62, 65, 69], // Bbmaj7
      [53, 57, 60, 67], // F(add9)
      [60, 64, 67, 74], // C(add9)
    ];
    const ROOTS_WAVE = [38, 34, 41, 36]; // D2, Bb1, F2, C2 // E2, C2, G2, D2

    const CHORDS_BOSS = [
      [55, 58, 62, 65], // Gm7
      [51, 55, 58, 62], // Ebmaj7
      [53, 57, 60, 64], // Fmaj7
      [50, 54, 57, 60], // D7
    ];
    const ROOTS_BOSS = [43, 39, 41, 38]; // G2, Eb2, F2, D2 // F2, Db2, Eb2, C2

    // final1: Fm - Gb - Db - C7
    const CHORDS_FINAL1 = [
      [62, 65, 69, 72], // Dm7
      [63, 67, 70],     // Eb
      [58, 62, 65],     // Bb
      [57, 61, 64, 67], // A7
    ];
    const ROOTS_FINAL1 = [38, 39, 34, 45]; // D2, Eb2, Bb1, A2

    // final2: Fm - Ab - Eb - C7
    const CHORDS_FINAL2 = [
      [62, 65, 69, 72], // Dm7
      [55, 58, 62, 65], // Gm7
      [51, 55, 58, 62], // Ebmaj7
      [57, 61, 64, 67], // A7
    ];
    const ROOTS_FINAL2 = [38, 43, 39, 45];

    // final3: Fm - Gb - Ab - C7
    const CHORDS_FINAL3 = [
      [62, 65, 69, 72], // Dm7
      [63, 66, 70],     // Ebm(ì–´ë‘¡ê²Œ)
      [53, 57, 60, 64], // Fmaj7
      [57, 61, 64, 67], // A7
    ];
    const ROOTS_FINAL3 = [38, 39, 41, 45];

    // fail: ìŠ¬í”ˆ ì§„í–‰(Am - F - Dm - Em)
    const CHORDS_FAIL = [
      [57, 60, 64, 67], // Am7
      [55, 59, 62],     // G
      [53, 57, 60, 64], // Fmaj7
      [52, 55, 59],     // E
    ];
    const ROOTS_FAIL = [45, 43, 41, 40]; // A2, G2, F2, E2 // A2, F2, D2, E2

    // win: ì—”ë”© ì§„í–‰(C - G - Am - F)
    const CHORDS_WIN = [
      [60, 64, 67, 72], // C
      [55, 59, 62, 67], // G
      [57, 60, 64, 69], // Am
      [53, 57, 60],     // F
    ];
    const ROOTS_WIN = [36, 43, 45, 41]; // C2, G2, A2, F2 // C2, G2, A2, F2



// C2, G2, A2, F2


    function mtof(m){ return 440 * Math.pow(2, (m - 69) / 12); }

    function kick(t){
      // punch + click
      toneAt("sine", 170, 52, 0.095, 0.12, t);
      noiseAt({hp:5200, lp:16000, dur:0.012, vol:0.010, t});
    }
    function snare(t){
      // noise snap + short body
      noiseAt({hp:1200, lp:9000, dur:0.080, vol:0.065, t});
      toneAt("triangle", 260, 190, 0.060, 0.030, t);
    }
    function hat(t, strong=false){
      noiseAt({hp:9000, lp:18000, dur: strong ? 0.030 : 0.016, vol: strong ? 0.022 : 0.014, t});
    }
    function bass(t, f){
      // square bass + sub
      toneAt("square", f, f*0.98, 0.18, 0.042, t);
      toneAt("sine",   f*0.5, f*0.5, 0.22, 0.012, t);
    }
    function arp(t, f){
      // crisp arpeggio
      toneAt("square", f, f*1.01, 0.090, 0.030, t);
    }
    function melody(t, f){
      toneAt("triangle", f, f, 0.12, 0.020, t);
    }
    function lead(t, f){
      // detuned dual-osc for a "new" lead color
      toneAt("sawtooth", f, f*1.01, 0.14, 0.012, t);
      toneAt("square",   f*1.005, f, 0.14, 0.010, t + 0.002);
    }
    function riser(t, f0, f1){
      toneAt("sawtooth", f0, f1, 0.16, 0.010, t);
    }

    // failìš© íŒ¨ë“œ(ê¸¸ê²Œ/ë¶€ë“œëŸ½ê²Œ)
    function pad(t, f){
      toneAt("triangle", f, f, 0.95, 0.010, t);
      toneAt("sine", f*1.5, f*1.5, 0.85, 0.006, t + 0.01);
    }
    // winìš© ë²¨(ì§§ê³  ë°ê²Œ)
    function bell(t, f){
      toneAt("sine", f, f*1.002, 0.20, 0.016, t);
      toneAt("triangle", f*2, f*1.99, 0.12, 0.008, t);
    }


    function toneAt(type, f0, f1, dur, vol, t0){
      if (!enabled || volume <= 0.001) return;
      ensure();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(f0, t0);
      if (f1 && f1 !== f0) o.frequency.exponentialRampToValueAtTime(f1, t0 + dur*0.85);
      env(g.gain, t0, 0.0008, 0.02, 0.22, dur, vol);
      // BGMì€ ì „ìš© ì²´ì¸(bgmLP->drive->mix)ì„ í†µê³¼
      o.connect(g).connect(bgmLP || master);
      o.start(t0);
      o.stop(t0 + dur + 0.08);
    }

    function noiseAt({hp=2000, lp=12000, dur=0.03, vol=0.03, t=0} = {}){
      if (!enabled || volume <= 0.001) return;
      ensure();
      const src = ctx.createBufferSource();
      src.buffer = noiseBuf;
      const bp = ctx.createBiquadFilter(); bp.type = "highpass"; bp.frequency.value = hp;
      const lpF = ctx.createBiquadFilter(); lpF.type = "lowpass";  lpF.frequency.value = lp;
      const g = ctx.createGain();
      env(g.gain, t, 0.001, 0.01, 0.18, dur, vol);
      src.connect(bp).connect(lpF).connect(g).connect(bgmLP || master);
      src.start(t);
      src.stop(t + dur + 0.02);
    }

    function applyBgmMode(){
      if (!ctx) return;
      const m = BGM_MODES[bgmMode] || BGM_MODES.build;

      bgmBpm = m.bpm;

      // ë°•ì/ë£¨í”„ êµ¬ì¡°ë„ ëª¨ë“œë³„ë¡œ ë°”ê¿”ì„œ "ê³¡ë§Œ ë°”ë€ ëŠë‚Œ"ì´ ì•„ë‹ˆë¼ ë¦¬ë“¬ ìì²´ê°€ ë‹¬ë¼ì§€ê²Œ
      bgmStepsPerBar = m.spb || 16;
      bgmBars = m.bars || 4;
      bgmLoopSteps = bgmStepsPerBar * bgmBars;
      bgmSwing = m.swing || 0.0;

      if (bgmMix)  bgmMix.gain.setTargetAtTime(m.mix, ctx.currentTime, 0.06);
      if (bgmLP)   bgmLP.frequency.setTargetAtTime(m.lp,  ctx.currentTime, 0.08);
      if (bgmDrive) bgmDrive.curve = makeDriveCurve(m.drive);
    }

    function setBgmMode(mode){
      const next = (mode && BGM_MODES[mode]) ? mode : "build";
      if (next === bgmMode) return;

      const prev = bgmMode;
      const prevSpb = bgmStepsPerBar;
      const prevBars = bgmBars;

      bgmMode = next;
      if (ctx) applyBgmMode();

      // ë³´ìŠ¤/ìµœì¢…ì „ ì§„ì…, ë˜ëŠ” ë°•ì êµ¬ì¡°(steps-per-bar)ê°€ ë°”ë€Œë©´ ë£¨í”„ë¥¼ ì²˜ìŒë¶€í„° ì‹œì‘
      const sigChanged = (bgmStepsPerBar !== prevSpb) || (bgmBars !== prevBars);

      if (bgmPlaying && ctx && ctx.state === "running") {
        const prevIsFinal = (prev && String(prev).startsWith("final"));
        const nextIsFinal = (next && String(next).startsWith("final"));
        // ë³´ìŠ¤ ì§„ì… / ìµœì¢…ì „ ì§„ì…(ì²˜ìŒ) / ë°•ì êµ¬ì¡° ë³€ê²½ì´ë©´ ë£¨í”„ë¥¼ ì²˜ìŒë¶€í„° ì‹œì‘
        if ((next === "boss" && prev !== "boss") || (nextIsFinal && !prevIsFinal) || sigChanged) {
          bgmStep = 0;
          bgmNextTime = ctx.currentTime + 0.06;
        }
      }
    }
    function getBgmMode(){ return bgmMode; }

    function scheduleBgm(step, t, stepDur){
      const bar = Math.floor(step / bgmStepsPerBar) % bgmBars;
      const pos = step % bgmStepsPerBar;

      // ì…”í”Œ/ìŠ¤ìœ™: í™€ìˆ˜ 16ë¶„ì„ ì•½ê°„ ë’¤ë¡œ ë°€ê¸°
      const tt = t + (((pos & 1) === 1) ? (stepDur * bgmSwing) : 0);

      const isFinal = (bgmMode === "final1" || bgmMode === "final2" || bgmMode === "final3");
      const finalLv = (bgmMode === "final1") ? 1 : (bgmMode === "final2") ? 2 : (bgmMode === "final3") ? 3 : 0;

      const chord =
        (bgmMode === "final1") ? CHORDS_FINAL1[bar] :
        (bgmMode === "final2") ? CHORDS_FINAL2[bar] :
        (bgmMode === "final3") ? CHORDS_FINAL3[bar] :
        (bgmMode === "boss")   ? CHORDS_BOSS[bar]  :
        (bgmMode === "wave")   ? CHORDS_WAVE[bar]  :
        (bgmMode === "fail")   ? CHORDS_FAIL[bar]  :
        (bgmMode === "win")    ? CHORDS_WIN[bar]   :
                                  CHORDS_BUILD[bar];
      const root  =
        (bgmMode === "final1") ? ROOTS_FINAL1[bar] :
        (bgmMode === "final2") ? ROOTS_FINAL2[bar] :
        (bgmMode === "final3") ? ROOTS_FINAL3[bar] :
        (bgmMode === "boss")   ? ROOTS_BOSS[bar]  :
        (bgmMode === "wave")   ? ROOTS_WAVE[bar]  :
        (bgmMode === "fail")   ? ROOTS_FAIL[bar]  :
        (bgmMode === "win")    ? ROOTS_WIN[bar]   :
                                  ROOTS_BUILD[bar];

// ----------------- ë“œëŸ¼(ëª¨ë“œë³„ ë¦¬ë“¬ì„ í™•ì‹¤íˆ ë‹¤ë¥´ê²Œ) -----------------
      if (bgmMode === "build") {
        // ê±°ì˜ ì•°ë¹„ì–¸íŠ¸(ëœ ì‹œë„ëŸ½ê²Œ)
        if (pos === 0 || pos === 8) kick(tt);
        if (pos === 4 || pos === 12) hat(tt, pos === 12);
      } else if (bgmMode === "wave") {
        // ê¸°ë³¸ 4/4 ì „íˆ¬
        if (pos === 0 || pos === 8) kick(tt);
        if (pos === 4 || pos === 12) snare(tt);
        if (pos === 2 || pos === 6 || pos === 10 || pos === 14) hat(tt, pos === 2);
      } else if (bgmMode === "boss") {
        // ë¬µì§í•œ ë³´ìŠ¤ ê·¸ë£¨ë¸Œ
        if (pos === 0 || pos === 6 || pos === 8 || pos === 14) kick(tt);
        if (pos === 4 || pos === 12) snare(tt);
        if (pos % 2 === 0) hat(tt, pos === 0 || pos === 8);
        if (pos === 15) noiseAt({hp:1600, lp:9000, dur:0.09, vol:0.040, t:tt});
      } else if (isFinal) {
        // final(phase1~3): í˜ì´ì¦ˆê°€ ì˜¬ë¼ê°ˆìˆ˜ë¡ ë°€ë„ ìƒìŠ¹
        if (pos === 0 || pos === 3 || pos === 6 || pos === 8 || pos === 10 || pos === 12 || pos === 15) kick(tt);
        if (finalLv >= 2 && (pos === 5 || pos === 13)) kick(tt);
        if (pos === 4 || pos === 12) snare(tt);

        if (finalLv === 1) {
          if (pos % 2 === 0) hat(tt, pos === 0 || pos === 8);
          if (pos === 14 || pos === 15) hat(tt, true);
        } else if (finalLv === 2) {
          if (pos % 2 === 0) hat(tt, pos === 0 || pos === 8);
          if (pos === 10 || pos === 14 || pos === 15) hat(tt, true);
        } else {
          // phase3: ê°€ì¥ ì••ë°•ê°(ë³¼ë¥¨ì€ ë‚®ê²Œ)
          hat(tt, pos === 0 || pos === 8);
          if (pos % 2 === 1) hat(tt, false);
          if (pos === 7 || pos === 15) hat(tt, true);
        }

        if (pos === 0) noiseAt({hp:5200, lp:18000, dur:0.12, vol:0.045, t:tt});
        if (pos === 8) noiseAt({hp:1700, lp:9000, dur:0.08, vol:0.045, t:tt});
      } else if (bgmMode === "fail") {
        // fail(4/4): ëŠë¦° ì‹¬ì¥ë°•ë™ + ì–‡ì€ ë¨¼ì§€
        if (pos === 0 || pos === 9) toneAt("sine", 68, 54, 0.30, 0.012, tt);
        if (pos === 4) noiseAt({hp:950, lp:2600, dur:0.11, vol:0.030, t:tt});
      } else if (bgmMode === "win") {
        // win: 4/4 ê°€ë²¼ìš´ ìŠ¤ë„¤ì–´ + ì”¬í•œ í–‡
        if (pos === 0 || pos === 8) kick(tt);
        if (pos === 4 || pos === 12) snare(tt);
        if (pos === 2 || pos === 6 || pos === 10 || pos === 14) hat(tt, pos === 2);
      }

// ----------------- ë² ì´ìŠ¤(ëª¨ë“œë³„ ë°•ì) -----------------
      if (bgmMode === "fail") {
        if (pos === 0 || pos === 8) bass(tt, mtof(root));
      } else if (bgmMode === "win") {
        if (pos === 0 || pos === 4 || pos === 8 || pos === 12) bass(tt, mtof(root));
      } else if (isFinal) {
        if (finalLv === 1) {
          if (pos === 0 || pos === 6 || pos === 8 || pos === 14) bass(tt, mtof(root));
        } else if (finalLv === 2) {
          if (pos === 0 || pos === 4 || pos === 6 || pos === 8 || pos === 12 || pos === 14) bass(tt, mtof(root));
        } else {
          if (pos === 0 || pos === 3 || pos === 6 || pos === 8 || pos === 10 || pos === 12 || pos === 15) bass(tt, mtof(root));
        }
      } else if (bgmMode === "boss") {
        if (pos === 0 || pos === 6 || pos === 8 || pos === 14) bass(tt, mtof(root));
      } else if (bgmMode === "wave") {
        if (pos === 0 || pos === 7 || pos === 8 || pos === 15) bass(tt, mtof(root));
      } else {
        if (pos === 0 || pos === 8) bass(tt, mtof(root));
      }

      // ----------------- ë©œë¡œë””(ëª¨ë“œë³„ ë¦¬ë“¬ ìœ„ì¹˜ ë‹¤ë¥´ê²Œ) -----------------
      const scaleBuild = [60, 62, 64, 67, 69, 72, 74, 76]; // C major pentatonic-ish (calm) // A Dorian (build: ì°¨ë¶„)
      const scaleWave  = [62, 64, 65, 67, 69, 70, 72, 74]; // D minor (battle) // E Dorian (wave: ì „íˆ¬)
      const scaleBoss  = [55, 58, 60, 62, 63, 65, 67, 70]; // G minor-ish (tense) // F harmonic minor-ish (boss)
      const scaleFinal = [62, 63, 65, 67, 69, 70, 72, 74]; // D harmonic minor-ish (final) // F phrygian dominant-ish (final)
      const scaleFail  = [57, 60, 62, 64, 65, 67, 69];     // A minor (slow)     // ëŠë¦° ì• ê°€í† (ë¶€ë“œëŸ½ê²Œ)
      const scaleWin   = [60, 62, 64, 65, 67, 69, 71, 72]; // C major (victory) // C major-ish

      let scale = scaleBuild;
      if (bgmMode === "wave") scale = scaleWave;
      else if (bgmMode === "boss") scale = scaleBoss;
      else if (isFinal) scale = scaleFinal;
      else if (bgmMode === "fail") scale = scaleFail;
      else if (bgmMode === "win") scale = scaleWin;

      let melodyPos = [3, 11]; // build(ê¸°ë³¸): ë“œë¬¸ë“œë¬¸
      if (bgmMode === "wave") {
        melodyPos = [1, 6, 9, 14];
      } else if (bgmMode === "boss") {
        melodyPos = [1, 3, 7, 9, 11, 13, 15];
      } else if (isFinal) {
        melodyPos = (finalLv === 1) ? [1, 4, 7, 9, 11, 15]
                  : (finalLv === 2) ? [1, 3, 4, 7, 9, 11, 13, 15]
                                   : [1, 3, 4, 5, 7, 9, 11, 13, 15];
      } else if (bgmMode === "fail") {
        melodyPos = [4, 9, 12];
      } else if (bgmMode === "win") {
        melodyPos = [2, 6, 10, 14];
      }

      if (melodyPos.includes(pos)){
        const idx = (bar * 13 + pos * 3) % scale.length;
        if (bgmMode === "fail"){
          melody(tt, mtof(scale[idx] - 12));
        } else if (bgmMode === "win"){
          bell(tt, mtof(scale[idx]));
        } else {
          melody(tt, mtof(scale[idx]));
          if (bgmMode === "wave" && (pos === 9 || pos === 14)) arp(tt + 0.02, mtof(scale[(idx+4)%scale.length]));
          if (bgmMode === "boss" || isFinal) lead(tt + 0.02, mtof(scale[(idx+2)%scale.length]));
        }
      }

      // failì—ì„œëŠ” ë°”ë§ˆë‹¤ íŒ¨ë“œ(ì½”ë“œí†¤)ë¡œ ê³µê°„ê°
      if (bgmMode === "fail" && pos === 0) {
        for (let i=0;i<chord.length;i++){
          pad(tt, mtof(chord[i]) * (i===0 ? 0.5 : 1)); // ë£¨íŠ¸ëŠ” í•œ ì˜¥íƒ€ë¸Œ ì•„ë˜ë„ í•¨ê»˜
        }
      }

      // winì—ì„œëŠ” 2ë°•ë§ˆë‹¤ ì‚´ì§ ë°˜ì§ì„
      if (bgmMode === "win" && (pos === 0 || pos === 8)) {
        for (let i=0;i<chord.length;i++){
          bell(tt + i*0.03, mtof(chord[i] + 12));
        }
      }

      // ë§ˆë”” ë ìƒìŠ¹(ê¸´ì¥ ìœ ì§€) â€” ëª¨ë“œë³„ ìŠ¤í… ê¸¸ì´ì— ëŒ€ì‘
      if (pos === (bgmStepsPerBar - 1)) {
        if (isFinal) {
          const a = (finalLv === 1) ? 620 : (finalLv === 2) ? 660 : 700;
          const b = (finalLv === 1) ? 1280 : (finalLv === 2) ? 1450 : 1620;
          riser(tt, a, b);
        } else if (bgmMode === "boss") {
          riser(tt, 520, 980);
        }
      }
    }

    function bgmTick(){
      if (!enabled || !ctx || ctx.state !== "running" || volume <= 0.001) return;
      const stepDur = (60 / Math.max(30, bgmBpm)) / 4; // 16th
      while (bgmNextTime < ctx.currentTime + BGM_AHEAD){
        scheduleBgm(bgmStep, bgmNextTime, stepDur);
        bgmNextTime += stepDur;
        bgmStep = (bgmStep + 1) % bgmLoopSteps;
      }
    }

    function startBgm(){
      if (bgmPlaying) return;
      ensure();
      if (!enabled || volume <= 0.001) return;
      if (ctx.state !== "running") return; // ì ê²¨ìˆìœ¼ë©´ unlock ì´í›„ ì‹œì‘
      applyBgmMode();
      bgmPlaying = true;
      bgmStep = 0;
      bgmNextTime = ctx.currentTime + 0.05;
      bgmTimer = setInterval(bgmTick, BGM_TICK_MS);
    }

    function stopBgm(){
      if (!bgmPlaying) return;
      bgmPlaying = false;
      if (bgmTimer){ clearInterval(bgmTimer); bgmTimer = null; }
    }
function env(param, t, a, d, s, r, peak){
      param.cancelScheduledValues(t);
      param.setValueAtTime(0.0001, t);
      param.exponentialRampToValueAtTime(Math.max(0.0002, peak), t + a);
      param.exponentialRampToValueAtTime(Math.max(0.0001, peak*s), t + a + d);
      param.exponentialRampToValueAtTime(0.0001, t + a + d + r);
    }

    function noise({hp=900, lp=9000, dur=0.10, vol=0.25} = {}){
      ensure();
      const t = ctx.currentTime;

      const src = ctx.createBufferSource();
      src.buffer = noiseBuf;

      const hpF = ctx.createBiquadFilter();
      hpF.type = "highpass";
      hpF.frequency.value = hp;

      const lpF = ctx.createBiquadFilter();
      lpF.type = "lowpass";
      lpF.frequency.value = lp;

      const g = ctx.createGain();
      env(g.gain, t, 0.001, 0.02, 0.2, dur, vol);

      src.connect(hpF).connect(lpF).connect(g).connect(master);
      src.start(t);
      src.stop(t + dur + 0.05);
    }

    function tone(type, f0, f1, dur, vol){
      ensure();
      const t = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(f0, t);
      if (f1 && f1 !== f0) o.frequency.exponentialRampToValueAtTime(f1, t + dur*0.85);
      env(g.gain, t, 0.001, 0.03, 0.25, dur, vol);
      o.connect(g).connect(master);
      o.start(t);
      o.stop(t + dur + 0.08);
    }

    // band-pass tone (used for clean crystal SFX)
    function toneBP(type, f0, f1, dur, vol, bpFreq=1150, q=1.2, a=0.001, d=0.095, s=0.08, r=0.02){
      ensure();
      const t = ctx.currentTime;
      const o = ctx.createOscillator();
      const bp = ctx.createBiquadFilter();
      const g = ctx.createGain();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(bpFreq, t);
      bp.Q.setValueAtTime(q, t);
      o.type = type;
      o.frequency.setValueAtTime(f0, t);
      if (f1 && f1 !== f0) o.frequency.exponentialRampToValueAtTime(f1, t + dur*0.85);
      env(g.gain, t, a, d, s, r, vol);
      o.connect(bp).connect(g).connect(master);
      o.start(t);
      o.stop(t + dur + 0.08);
    }

    function toneBPDetune(type, f0, f1, dur, vol, bpFreq=1150, q=1.2, cents=6){
      const k = Math.pow(2, cents/1200);
      toneBP(type, f0*k, f1*k, dur, vol*0.55, bpFreq, q);
      toneBP(type, f0/k, f1/k, dur, vol*0.55, bpFreq, q);
    }

    // ì‚¬ìš´ë“œë“¤(íš¨ê³¼ìŒ ì „ì²´ êµì²´: ë” ë˜ë ·í•œ ë„¤ì˜¨/ì‚¬ì´ë²„ í†¤)
    // - ë°˜ë³µ ì¬ìƒì—ë„ ëœ í”¼ë¡œí•˜ê²Œ(ì§§ê³  ì •ëˆëœ ì–´íƒ)
    // - íƒ€ì…ë³„/ìƒí™©ë³„ êµ¬ë¶„ì´ í™•ì‹¤í•˜ë„ë¡(í”¼ì¹˜Â·ë…¸ì´ì¦ˆÂ·ì§ˆê° ë¶„ë¦¬)
    function j(f, cents=12){ return f * Math.pow(2, ((Math.random()*2-1)*cents)/1200); }

    function s_click(){
      tone("triangle", j(2100,14), j(1650,14), 0.040, 0.20);
      noise({hp:3200, lp:16000, dur:0.035, vol:0.06});
    }
    function s_place(){
      // ì„¤ì¹˜: ì§§ì€ ì €ì—­ 'íˆ­' + ê¸ˆì†ì„± í•˜ì´ë¼ì´íŠ¸
      tone("sine",     j(165,8),  j(95,8),   0.090, 0.22);
      tone("triangle", j(820,10), j(1220,10),0.060, 0.14);
      noise({hp:1400, lp:9000, dur:0.060, vol:0.07});
    }
    function s_shoot(){
      // í¬íƒ‘ ë°œì‚¬(ë ˆì´ì €): ë¹ ë¥¸ í•˜ì´â†’ë¡œìš° ìŠ¤ìœ• + ìŠ¤ëƒ… ë…¸ì´ì¦ˆ
      tone("sawtooth", j(1800,18), j(420,18), 0.065, 0.16);
      tone("triangle", j(2600,14), j(1200,14),0.045, 0.10);
      noise({hp:2600, lp:12000, dur:0.040, vol:0.06});
    }

    
    function s_coreShoot(){
      // ì½”ì–´(ì˜¤ë²„ë“œë¼ì´ë¸Œ) ì§ì ‘ ì‚¬ê²©: ë§‘ì€ ìˆ˜ì • 'íŒ…' (ë©”ì¸ ë ˆì´ì–´ë§Œ)
      // - Triangle ê¸°ë°˜, ì§§ì€ í•˜ê°• í”¼ì¹˜, Band-passë¡œ ìœ ë¦¬ ê³µëª… ëŠë‚Œ
      // - í¬íƒ‘ ë°œì‚¬ìŒ(ë ˆì´ì €)ê³¼ ì¬ì§ˆì´ ë‹¤ë¥´ê²Œ ë“¤ë¦¬ë„ë¡ ì„¤ê³„
      toneBPDetune("triangle", 1040, 860, 0.115, 0.30, 1150, 1.2, 6);
    }

// ì—ë„ˆì§€í¬(ì•¼ë§ˆí† í¬) ì „ìš© ì‚¬ìš´ë“œ: ì¶©ì „ì€ ë‹¨ê³„ë³„ë¡œ ë” ì„ ëª…, ë°œì‚¬ëŠ” 'ë¹”' ì²´ê° ê°•í™”
    function s_yamatoCharge1(){
      tone("sine",     j(95,6),  j(140,6),  0.16, 0.26);  // ì €ì—­ í—ˆë°
      tone("triangle", j(520,10),j(760,10), 0.06, 0.10);  // ìŠ¤íŒŒí¬
      noise({hp:800, lp:4200, dur:0.14, vol:0.10});
    }
    function s_yamatoCharge2(){
      tone("triangle", j(720,10),j(980,10), 0.07, 0.13);
      tone("sine",     j(140,6), j(190,6),  0.10, 0.18);
      noise({hp:1400, lp:6200, dur:0.12, vol:0.09});
    }
    function s_yamatoCharge3(){
      tone("square",   j(980,12), j(1220,12),0.06, 0.12);
      tone("triangle", j(1680,12),j(2380,12),0.05, 0.10);
      noise({hp:2200, lp:10000, dur:0.10, vol:0.09});
    }
    function s_yamatoChargeReady(){
      // ë°œì‚¬ ì§ì „: ë°ì€ 'ë½-ì˜¨' í•‘
      tone("triangle", j(1200,12), j(2800,12), 0.10, 0.18);
      noise({hp:3400, lp:18000, dur:0.09, vol:0.10});
    }
    function s_yamatoFire(){
      // ë°œì‚¬: ì €ì—­ ì¶©ê²© + ê³ ì—­ ìŠ¤ëƒ… + ì—ë„ˆì§€ í­ë°œ
      tone("sine",     j(95,6),   j(40,6),   0.70, 0.65);
      noise({hp:80,   lp:1600,  dur:0.50,  vol:0.26});
      tone("sawtooth", j(1100,16), j(180,16),0.42, 0.26);
      tone("triangle", j(3200,16), j(900,16),0.20, 0.30);
      noise({hp:3200, lp:19000, dur:0.16, vol:0.16});
    }

    function s_shieldHit(){
      // ë³´í˜¸ë§‰ í”¼ê²©: ê¸ˆì†ì„± 'í•‘' + ì „ê¸°ì„± íˆìŠ¤
      tone("triangle", j(1650,10), j(1050,10), 0.11, 0.22);
      tone("sine",     j(2550,12), j(1800,12), 0.06, 0.10);
      noise({hp:2400, lp:15000, dur:0.08, vol:0.10});
    }
    function s_shieldBreak(){
      // ë³´í˜¸ë§‰ íŒŒê´´: í¬ë™(í•˜ê°•) + íŒŒí¸ ë…¸ì´ì¦ˆ + ì €ì—­ ì”í–¥
      tone("sawtooth", j(1200,16), j(140,16), 0.28, 0.26);
      noise({hp:1800, lp:13000, dur:0.22, vol:0.22});
      tone("triangle", j(2200,14), j(1600,14), 0.09, 0.14);
      tone("triangle", j(2800,14), j(1900,14), 0.07, 0.12);
      tone("sine",     j(140,8),   j(70,8),    0.30, 0.18);
    }
    function s_coreBreak(){
      // ìˆ˜ì •íƒ‘ íŒŒê´´(ì•½ 1ì´ˆ): í¬ë¦¬ìŠ¤íƒˆ í¬ë™ + ìŠ¤íŒŒí´ + ì €ì—­ ì”í–¥
      tone("triangle", j(2400,12), j(1100,12), 0.16, 0.22);
      tone("sawtooth", j(980,14),  j(70,14),   1.05, 0.36);
      noise({hp:1600, lp:14000, dur:0.95, vol:0.22});
      tone("sine",     j(3200,18), j(2100,18), 0.22, 0.08);
      tone("sine",     j(2600,18), j(1700,18), 0.26, 0.08);
      tone("sine",     j(150,8),   j(60,8),    1.05, 0.16);
    }

    function s_enemyShoot(){
      // ì  ë°œì‚¬: ë” 'ê±°ì¹ ê³  ë‚®ê²Œ' (í”Œë ˆì´ì–´ ë°œì‚¬ì™€ êµ¬ë¶„)
      tone("square", j(780,14), j(260,14), 0.080, 0.13);
      noise({hp:1800, lp:9000, dur:0.045, vol:0.05});
    }
    function s_blast(){
      // í­íŒŒë³‘: ì§§ì€ í­ë°œ(ì €ì—­+ë…¸ì´ì¦ˆ)
      tone("sine", j(140,8), j(55,8), 0.38, 0.34);
      noise({hp:90, lp:1800, dur:0.32, vol:0.16});
      noise({hp:2200, lp:12000, dur:0.08, vol:0.06});
    }
    function s_hpHit(){
      // HP í”¼ê²©: ë³´í˜¸ë§‰ë³´ë‹¤ í›¨ì”¬ ë‘”íƒí•˜ê²Œ
      tone("sine", j(110,6), j(70,6), 0.20, 0.28);
      noise({hp:120, lp:1600, dur:0.14, vol:0.10});
    }
    function s_boom(){
      // í° í­ë°œ
      tone("sine", j(90,6), j(28,6), 0.95, 0.48);
      noise({hp:60, lp:1400, dur:0.85, vol:0.18});
      noise({hp:2000, lp:11000, dur:0.12, vol:0.08});
    }
    function s_aegis(){
      // ê¸´ê¸‰ ë³´í˜¸ë§‰: ìƒìŠ¹ ìŠ¤ìœ• + shimmer
      tone("triangle", j(420,10), j(1520,10), 0.22, 0.22);
      tone("sine",     j(980,12), j(2060,12), 0.18, 0.12);
      noise({hp:2800, lp:17000, dur:0.18, vol:0.10});
    }
    function s_repair(){
      // ìˆ˜ë¦¬: ë°ì€ ì¹˜ì„ + ìŠ¤íŒŒí´
      tone("sine",     j(520,10), j(880,10),  0.20, 0.18);
      tone("triangle", j(1200,10),j(1720,10), 0.16, 0.12);
      noise({hp:2400, lp:16000, dur:0.12, vol:0.08});
    }

    function s_clear(){
      // ì›¨ì´ë¸Œ í´ë¦¬ì–´: ì§§ì€ 'ìƒìŠ¹' ìŠ¤íŒ…
      tone("triangle", j(720,8),  j(1440,8), 0.22, 0.20);
      tone("triangle", j(1040,8), j(2080,8), 0.18, 0.10);
    }
    function s_wave(){
      // ì›¨ì´ë¸Œ ì‹œì‘: 'ì‚-ì—…' + ê°€ë²¼ìš´ íˆìŠ¤
      tone("square", j(360,10), j(720,10), 0.14, 0.18);
      noise({hp:1900, lp:9000, dur:0.10, vol:0.07});
    }

    function s_warning(){
      // ìµœì¢…ì „/ë³´ìŠ¤ ê²½ê³ : ì§§ì€ ì‚¬ì´ë Œ + íŠ¸ë ˆëª°ë¡œ
      ensure();
      const t0 = ctx.currentTime;

      const o = ctx.createOscillator();
      const g = ctx.createGain();
      const f = ctx.createBiquadFilter();

      // tremolo
      const lfo = ctx.createOscillator();
      const lfoG = ctx.createGain();

      o.type = "sawtooth";
      o.frequency.setValueAtTime(520, t0);
      o.frequency.exponentialRampToValueAtTime(980, t0+0.18);
      o.frequency.exponentialRampToValueAtTime(520, t0+0.36);
      o.frequency.exponentialRampToValueAtTime(980, t0+0.54);
      o.frequency.exponentialRampToValueAtTime(620, t0+0.78);

      f.type = "bandpass";
      f.frequency.setValueAtTime(1300, t0);
      f.Q.value = 0.9;

      lfo.type = "sine";
      lfo.frequency.setValueAtTime(10, t0);
      lfoG.gain.setValueAtTime(0.18, t0);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.20, t0+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+0.80);

      lfo.connect(lfoG).connect(g.gain);
      o.connect(f).connect(g).connect(master);
      o.start(t0); lfo.start(t0);
      o.stop(t0+0.82); lfo.stop(t0+0.82);

      // ì•„ì£¼ ì•½í•œ íˆìŠ¤(ìƒí™© ê²½ê³ ê°)
      noise({hp:2400, lp:14000, dur:0.10, vol:0.06});
    }

    function s_victory(){
      // ìŠ¹ë¦¬: 2ë‹¨ ì•„ë¥´í˜ì§€ì˜¤ + ì§§ì€ ì½”ë“œ ìŠ¤ì›°
      ensure();
      const t0 = ctx.currentTime;

      function toneAt(type, f, dt, dur, vol){
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(f, t0 + dt);
        env(g.gain, t0 + dt, 0.001, 0.02, 0.25, dur, vol);
        o.connect(g).connect(master);
        o.start(t0 + dt);
        o.stop(t0 + dt + dur + 0.08);
      }

      const seq = [
        [0.00, 523.25], // C5
        [0.10, 659.25], // E5
        [0.20, 783.99], // G5
        [0.30, 1046.50],// C6
        [0.52, 783.99], // G5
        [0.62, 880.00], // A5
        [0.72, 1046.50],// C6
        [0.82, 1318.51],// E6
      ];
      for (const [dt, f] of seq){
        toneAt("triangle", f, dt, 0.16, 0.16);
      }

      const chordT = 0.98;
      toneAt("sine",     523.25, chordT, 0.45, 0.10);
      toneAt("sine",     659.25, chordT, 0.45, 0.08);
      toneAt("sine",     783.99, chordT, 0.45, 0.08);
      toneAt("triangle", 1046.50, chordT, 0.36, 0.08);

      setTimeout(()=>{ try { noise({hp:2600, lp:16000, dur:0.09, vol:0.08}); } catch {} }, 280);
    }


    function play(name){
      if (!enabled) return;
      // ì ê¸ˆ í•´ì œëŠ” ê° ì…ë ¥ì—ì„œ unlock()ë¡œ ì²˜ë¦¬ (ì—¬ê¸°ì„œ ê°•ì œ resumeí•˜ì§€ ì•ŠìŒ)
      switch(name){
        case "click": return s_click();
        case "place": return s_place();
        case "shoot": return s_shoot();
        case "core_shoot": return s_coreShoot();
        case "y_charge1": return s_yamatoCharge1();
        case "y_charge2": return s_yamatoCharge2();
        case "y_charge3": return s_yamatoCharge3();
        case "y_charge_ready": return s_yamatoChargeReady();
        case "y_fire": return s_yamatoFire();
        case "enemy_shoot": return s_enemyShoot();
        case "blast": return s_blast();
        case "shield_hit": return s_shieldHit();
        case "shield_break": return s_shieldBreak();
        case "hp_hit": return s_hpHit();
        case "boom": return s_boom();
        case "core_break": return s_coreBreak();
        case "aegis": return s_aegis();
        case "repair": return s_repair();
        case "clear": return s_clear();
        case "wave": return s_wave();
        case "warning": return s_warning();
        case "victory": return s_victory();
      }
    }
    return { unlock, play, setEnabled, getEnabled, setVolume, getVolume, startBgm, stopBgm, setBgmMode, getBgmMode };
  })();

  // SFX ê³¼ë‹¤ ì¬ìƒ ë°©ì§€(ë¦¬ë¯¸í„°)
  let _lastShootSfx = 0;
  let _lastCritTingSfx = 0;
  let _lastShieldHitSfx = 0;
  let _lastHpHitSfx = 0;
  function sfxShoot(){
    const t = nowSec();
    if (t - _lastShootSfx > 0.05){ SFX.play("shoot"); _lastShootSfx = t; }
  }
  function sfxCritTing(){
    const t = nowSec();
    if (t - _lastCritTingSfx > 0.06){ SFX.play("core_shoot"); _lastCritTingSfx = t; }
  }
  function sfxShieldHit(){
    const t = nowSec();
    if (t - _lastShieldHitSfx > 0.10){ SFX.play("shield_hit"); _lastShieldHitSfx = t; }
  }
  function sfxHpHit(){
    const t = nowSec();
    if (t - _lastHpHitSfx > 0.12){ SFX.play("hp_hit"); _lastHpHitSfx = t; }
  }
  function ensureAudio(){ SFX.unlock(); }

  function setMsg(msg, secs=1.6){
    state.uiMsg = String(msg||"");
    state.uiMsgUntil = nowSec() + (secs||0);
    if (uiMsg) uiMsg.textContent = state.uiMsg;
  }



  // ---------- Diagnostics / Bug report ----------
  const BUILD_TAG = "v11-step14-diag";

  function debugLog(msg){
    try{
      if (!state.debugLogs) state.debugLogs = [];
      const t = new Date().toISOString();
      state.debugLogs.push(`${t} ${String(msg)}`);
      if (state.debugLogs.length > 80) state.debugLogs.splice(0, state.debugLogs.length - 80);
    }catch{}
  }

  function fallbackCopy(t){
    return new Promise((resolve, reject)=>{
      try{
        const ta = document.createElement("textarea");
        ta.value = String(t||"");
        ta.setAttribute("readonly", "");
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        ta.style.top  = "-9999px";
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, ta.value.length);
        const ok = document.execCommand("copy");
        document.body.removeChild(ta);
        ok ? resolve(true) : reject(new Error("copy_failed"));
      }catch(e){ reject(e); }
    });
  }

  function copyText(text){
    const t = String(text||"");
    if (navigator.clipboard && navigator.clipboard.writeText){
      return navigator.clipboard.writeText(t).catch(()=>fallbackCopy(t));
    }
    return fallbackCopy(t);
  }

  function collectBugReport(){
    const s = state;
    const turretCounts = {};
    try{ (s.turrets||[]).forEach(t=>{ turretCounts[t.type] = (turretCounts[t.type]||0) + 1; }); }catch{}

    const snap = {
      build: BUILD_TAG,
      ts: new Date().toISOString(),
      ua: navigator.userAgent,
      screen: { w: window.innerWidth, h: window.innerHeight, dpr: window.devicePixelRatio||1 },
      wave: s.wave,
      phase: s.phase,
      diff: s.diffId,
      speed: s.speed,
      crystals: s.crystals,
      map: s.mapId,
      contractPick: s.contractPick,
      contractActive: s.contractActive,
      mission: s.mission ? { id: s.mission.id, goalWave: s.mission.goalWave, reward: s.mission.reward } : null,
      core: s.core ? {
        hp: s.core.hp, hpMax: s.core.hpMax,
        shield: s.core.shield, shieldMax: s.core.shieldMax,
        barrierActive: !!s.core.barrierActive,
      } : null,
      upg: s.upg || null,
      turrets: turretCounts,
      enemiesAlive: (s.enemies||[]).length,
      hardError: s.hardError || "",
      recentLogs: (s.debugLogs||[]).slice(-50),
    };

    return "CBD BUG REPORT\n" + JSON.stringify(snap, null, 2);
  }

  function runSelfCheck(){
    const miss = [];
    const needIds = [
      "btnWave","btnRepair","btnEnergy","btnBarrier",
      "btnSpeed","btnCheat",
      "btnBugReport","btnSelfCheck",
    ];
    for (const id of needIds){
      if (!document.getElementById(id)) miss.push(`DOM:${id}`);
    }

    try{ if (typeof startWave !== "function") miss.push("FN:startWave"); } catch { miss.push("FN:startWave"); }
    try{ if (typeof restart !== "function") miss.push("FN:restart"); } catch { miss.push("FN:restart"); }
    try{ if (typeof tryRepair !== "function") miss.push("FN:tryRepair"); } catch { miss.push("FN:tryRepair"); }
    try{ if (typeof fireEnergyCannon !== "function") miss.push("FN:fireEnergyCannon"); } catch { miss.push("FN:fireEnergyCannon"); }
    try{ if (typeof tryBarrier !== "function") miss.push("FN:tryBarrier"); } catch { miss.push("FN:tryBarrier"); }

    const ok = miss.length === 0;
    debugLog(ok ? "self_check_ok" : ("self_check_fail " + miss.join(",")));
    setMsg(ok ? "ìê°€ì§„ë‹¨: OK" : `ìê°€ì§„ë‹¨: ${miss.length}ê°œ ë¬¸ì œ (ë²„ê·¸ë¦¬í¬íŠ¸ ë³µì‚¬ë¡œ ê³µìœ )`, ok ? 1.6 : 3.0);
    return { ok, miss };
  }

  function setupErrorCapture(){
    if (window.__CBD_ERRCAP) return;
    window.__CBD_ERRCAP = true;

    window.addEventListener("error", (ev)=>{
      try{
        const m = (ev && ev.message) ? ev.message : "Unknown error";
        debugLog("error: " + m);
        if (!state.hardError) state.hardError = String(m).slice(0, 140);
      }catch{}
    });

    window.addEventListener("unhandledrejection", (ev)=>{
      try{
        const r = ev && ev.reason ? (ev.reason.stack || ev.reason.message || String(ev.reason)) : "Unhandled rejection";
        debugLog("unhandledrejection: " + String(r).slice(0, 500));
        if (!state.hardError) state.hardError = String(r).slice(0, 140);
      }catch{}
    });
  }
  function mulberry32(seed){
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  // ---------- Layout ----------
  const CORE_POS = { x: W*0.5, y: H*0.5 };
  const CORE_RADIUS = 34;
  const BUILD_RADIUS = 240;

  // ---------- Assets (ì½”ì–´ ì•„ì´ì½˜ ë‚´ì¥: ë¡œì»¬/ëª¨ë°”ì¼ì—ì„œ íŒŒì¼ ë¡œë”©ì´ ë§‰í˜€ë„ í•­ìƒ í‘œì‹œ) ----------
  const CORE_ICON_DATA_URL = "data:image/png;base64,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";
  const coreIcon = new Image();
  let coreIconReady = false;
  coreIcon.onload = () => coreIconReady = true;
  coreIcon.onerror = () => {
    // ë¡œì»¬ íŒŒì¼/ì••ì¶•ë·°ì–´ ë“±ì—ì„œ core_icon.png ë¡œë”©ì´ ì‹¤íŒ¨í•˜ëŠ” ê²½ìš° ë‚´ì¥ ë°ì´í„°ë¡œ í´ë°±
    if (coreIcon.src !== CORE_ICON_DATA_URL) coreIcon.src = CORE_ICON_DATA_URL;
  };
  // 1) ë¨¼ì € ì™¸ë¶€ íŒŒì¼ì„ ì‹œë„í•˜ê³ , 2) ì‹¤íŒ¨/ì§€ì—° ì‹œ ë‚´ì¥ ë°ì´í„°ë¡œ ìë™ í´ë°±
  coreIcon.src = "core_icon.png";
  setTimeout(() => {
    if (!coreIconReady) coreIcon.src = CORE_ICON_DATA_URL;
  }, 800);

  // ---------- Turrets ----------
  const TURRET_TYPES = {
    basic:  { key:"1", name:"ê¸°ë³¸ í¬íƒ‘",   cost:35, range:175, fireRate:3.0, dmg:9,  projSpd:350, splash:0,  slow:0,    desc:"ë‹¨ì¼ íƒ€ê²Ÿ, ì•ˆì •í˜•" },
    slow:   { key:"2", name:"ìŠ¬ë¡œìš° í¬íƒ‘", cost:45, range:165, fireRate:2.2, dmg:6,  projSpd:330, splash:0,  slow:0.35, desc:"í”¼ê²© ì‹œ ë‘”í™”" },
    splash: { key:"3", name:"ìŠ¤í”Œë˜ì‹œ",    cost:60, range:155, fireRate:1.5, dmg:12, projSpd:310, splash:48, slow:0,    desc:"ë²”ìœ„ í­ë°œ í”¼í•´" },

    // 4) ì‹¤ë“œ ë¶„ì‡„: ì  ì‹¤ë“œ(íŒŒë€ ë³´í˜¸ë§‰)ë¥¼ ë¹ ë¥´ê²Œ ê¹ìŒ
    shred: {
      name: "ì‹¤ë“œ ë¶„ì‡„",
      key: "4",
      cost: 70,
      dmg: 7,
      fireRate: 2.6,
      range: 170,
      projSpd: 340,
      shieldMul: 2.25,
      desc: "ì  ë³´í˜¸ë§‰ì— ì¶”ê°€ í”¼í•´",
    },
    // 5) ë°©í˜¸ íŒŒê´´: ì ì„ ì·¨ì•½ ìƒíƒœë¡œ ë§Œë“¤ì–´ ì¶”ê°€ í”¼í•´
    breaker: {
      name: "ë°©í˜¸ íŒŒê´´",
      key: "5",
      cost: 85,
      dmg: 10,
      fireRate: 2.0,
      range: 175,
      projSpd: 330,
      vulnBonus: 0.22,
      vulnDur: 2.6,
      desc: "ì·¨ì•½ í‘œì‹(ë°›í”¼ì¦) ë¶€ì—¬",
    },

  };

  // ---------- Build helpers ----------
  // í¬íƒ‘ íŒë§¤ í™˜ë¶ˆ ë¹„ìœ¨(ê¸°ë³¸ 80%)
  const SELL_REFUND = 0.80;
  function sellRefundRate(){
    return SELL_REFUND;
  }

  // ---------- (11) ë°©ì–´ì„ : ì½”ì–´ ì• 1íšŒìš© ì¥ë²½ ----------
  const BARRIER_COST = 35;
  const BARRIER_CD   = 22.0;

  // ---------- (12) ìƒì  ì†Œë¹„ ì•„ì´í…œ ----------
  const SHOP_ITEM_REPAIR_COST = 60;
  const SHOP_ITEM_REPAIR_CD   = 26.0;
  const SHOP_ITEM_REPAIR_MISS = 0.35;  // missing HP portion
  const SHOP_ITEM_REPAIR_MIN  = 20;

  const SHOP_ITEM_FIRE_COST = 55;
  const SHOP_ITEM_FIRE_CD   = 30.0;
  const SHOP_ITEM_FIRE_DUR  = 10.0;
  const SHOP_ITEM_FIRE_MUL  = 1.35;

  const SHOP_ITEM_SLOW_COST = 65;
  const SHOP_ITEM_SLOW_CD   = 32.0;
  const SHOP_ITEM_SLOW_MUL  = 0.72;

  function findTurretIndexAt(x,y, rad=18){
    let best = -1, bestD = 1e9;
    for (let i=0;i<state.turrets.length;i++){
      const t = state.turrets[i];
      const d = dist(x,y, t.x,t.y);
      if (d <= rad && d < bestD){ best = i; bestD = d; }
    }
    return best;
  }

  function sellTurretAt(x,y){
    const idx = findTurretIndexAt(x,y, 18);
    if (idx < 0) return false;
    const tr = state.turrets[idx];
    const cost = (TURRET_TYPES[tr.type] ? TURRET_TYPES[tr.type].cost : 0);
    const refund = Math.max(0, Math.floor(cost * sellRefundRate()));
    state.crystals += refund;
    state.turrets.splice(idx, 1);
    fxRing(x,y, 18, 72, "#fcd34d");
    fxText(`íŒë§¤ +${refund}`, x, y - 18, "#fcd34d");
    SFX.play("click");
    return true;
  }


  const EVENTS = [
    { id:"barrier_null",  name:"ë³´í˜¸ë§‰ êµë€", desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ ë³´í˜¸ë§‰ í¡ìˆ˜ íš¨ìœ¨ì´ í¬ê²Œ ê°ì†Œí•©ë‹ˆë‹¤(ì¼ë¶€ HP ì§ê²©).",
      apply(s){ s.mods.shieldAbsorbMul = 0.25; s.mods.shieldRegenMul = 0.60; s.mods.rewardMul = 1.25; } },
    { id:"proj_slow",    name:"íƒ„ì† ê°ì†Œ",  desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ í¬íƒ‘ íƒ„ì†/ì—°ì‚¬ë ¥ì´ ê°ì†Œí•©ë‹ˆë‹¤.",
      apply(s){ s.mods.turretProjMul = 0.72; s.mods.turretFireMul = 0.78; } },
    { id:"double_crystal", name:"ìì› 2ë°°", desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ ì²˜ì¹˜ ë³´ìƒì´ 2ë°°ì…ë‹ˆë‹¤.",
      apply(s){ s.mods.rewardMul = 2.0; } },
{ id:"turret_boost", name:"í¬íƒ‘ ê°•í™”", desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ í¬íƒ‘ í”¼í•´ +20%.",
  apply(s){ s.mods.turretDmgMul = 1.20; } },

{ id:"shield_surge", name:"ì‹¤ë“œ ê³¼ì¶©ì „", desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ ë³´í˜¸ë§‰ ì¬ìƒ +60%.",
  apply(s){ s.mods.shieldRegenMul = 1.60; } },
{ id:"overclock_rounds", name:"ê°€ì† íƒ„í™˜", desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ í¬íƒ‘ íƒ„ì† +30%, ì—°ì‚¬ë ¥ +10%.",
  apply(s){ s.mods.turretProjMul = 1.30; s.mods.turretFireMul = 1.10; } },

{ id:"precision_mode", name:"ì •ë°€ ì¡°ì¤€", desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ í¬íƒ‘ í”¼í•´ +30%, ì—°ì‚¬ë ¥ -12%.",
  apply(s){ s.mods.turretDmgMul = 1.30; s.mods.turretFireMul = 0.88; } },


{ id:"emp_storm", name:"EMP í­í’", desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ í¬íƒ‘ ì—°ì‚¬ë ¥ -35%.",
  apply(s){ s.mods.turretFireMul = 0.65; } },

{ id:"resource_tax", name:"ë³´ê¸‰ ì°¨ê°", desc:"ì´ë²ˆ ì›¨ì´ë¸Œ ë™ì•ˆ í¬ë¦¬ìŠ¤íƒˆ ë³´ìƒ -40%.",
  apply(s){ s.mods.rewardMul = 0.60; } },


  ];
  // ---------- Difficulty Presets (ì €ì¥ ì•ˆ í•¨) ----------
  // í”„ë¦¬ì…‹ì€ ì  ìŠ¤íƒ¯/ìŠ¤í°/ë³´ìƒì—ë§Œ ê³±í•´ì§€ê³ , ì›¨ì´ë¸Œ ê¸°ë³¸ ê³¡ì„ (waveSpec)ì€ ê·¸ëŒ€ë¡œ ë‘¡ë‹ˆë‹¤.
  const DIFF_PRESETS = {
    easy:   { key:"easy",   name:"ì‰¬ì›€",   hpMul:0.92, dmgMul:0.90, spdMul:0.98, spawnMul:0.94, rewardMul:1.10,
              eliteAdd:0.00,
              bossHpMul:1.00, bossSpdMul:1.00, bossPatternMul:1.00, bossRewardMul:1.00,
              finalHpMul:1.00, finalSpdMul:1.00, finalPatternMul:1.00, finalPhase2Add:0.00, finalRewardMul:1.00 },
    normal: { key:"normal", name:"ë³´í†µ",   hpMul:1.00, dmgMul:1.00, spdMul:1.00, spawnMul:1.00, rewardMul:1.00,
              eliteAdd:0.00,
              bossHpMul:1.00, bossSpdMul:1.00, bossPatternMul:1.00, bossRewardMul:1.00,
              finalHpMul:1.00, finalSpdMul:1.00, finalPatternMul:1.00, finalPhase2Add:0.00, finalRewardMul:1.00 },
    hard:   { key:"hard",   name:"ì–´ë ¤ì›€", hpMul:1.20, dmgMul:1.00, spdMul:1.06, spawnMul:1.00, rewardMul:1.05,
              eliteAdd:0.02,
              bossHpMul:1.22, bossSpdMul:1.04, bossPatternMul:0.98, bossRewardMul:1.08,
              finalHpMul:1.28, finalSpdMul:1.04, finalPatternMul:0.96, finalPhase2Add:0.05, finalRewardMul:1.12 },
  };


  function getDiff(){
    const k = (state && state.diffId) ? String(state.diffId) : "normal";
    return DIFF_PRESETS[k] || DIFF_PRESETS.normal;
  }
  function setDiffPreset(key){
    // ëŸ° ì‹œì‘ í›„ ë‚œì´ë„ ê³ ì •
    if (state && state.diffLocked) {
      try { if (typeof setMsg === 'function') setMsg("ì§„í–‰ ì¤‘ì—ëŠ” ë‚œì´ë„ ë³€ê²½ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. (ì¬ì‹œì‘ í›„ ë³€ê²½ ê°€ëŠ¥)", 2.2); } catch {}
      try { SFX.play("click"); } catch {}
      return;
    }

    const k = (key && DIFF_PRESETS[key]) ? key : "normal";
    state.diffId = k;
    state.diff = DIFF_PRESETS[k];
    // (legacy) ì¼ë¶€ UI/ë””ë²„ê·¸ì—ì„œ difficultyë¥¼ ì“°ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë™ê¸°í™”
    state.difficulty = state.diff.hpMul;

    // ë‚œì´ë„ ë³€ê²½ ì‹œ ê¸°ë¡ë„ í•´ë‹¹ ë‚œì´ë„ë¡œ ìŠ¤ìœ„ì¹­
    try { __records = null; } catch {}
    try { renderRecords(true); } catch {}

    try { refreshDiffUI(); } catch {}
    try { if (typeof setMsg === 'function') setMsg(`ë‚œì´ë„: ${state.diff.name}`, 1.4); } catch {}
    try { if (typeof refreshUI === 'function') refreshUI(); } catch {}
      try { if (typeof updateMainMenuUI === 'function') updateMainMenuUI(true); } catch {}
}


  // UIì—ì„œ í”„ë¦¬ì…‹ ë²„íŠ¼ í•˜ì´ë¼ì´íŠ¸ (DOMì´ ì—†ìœ¼ë©´ ì¡°ìš©íˆ ë¬´ì‹œ)
  function refreshDiffUI(){
    try {
      const k = (state && state.diffId) ? String(state.diffId) : "normal";
      const bE = document.getElementById("btnDiffEasy");
      const bN = document.getElementById("btnDiffNormal");
      const bH = document.getElementById("btnDiffHard");
      if (bE) bE.classList.toggle("active", k==="easy");
      if (bN) bN.classList.toggle("active", k==="normal");
      if (bH) bH.classList.toggle("active", k==="hard");
    } catch {}
  }

  // ---------- State ----------
  const state = {
    diffId: "normal",
    diffLocked: false,
    diff: DIFF_PRESETS.normal,
    difficulty: DIFF_PRESETS.normal.hpMul,
    speed: 1.0,
    cheat: false,
    god: false,
    gtime: 0,
    wave: 1,
    phase: "build", // build | wave | clear | finalprep | fail | win
    contractPick: "none",
    mapId: "sanctuary",
    map: null,
    contractActive: "none",


    // ì›¨ì´ë¸Œ ëª©í‘œ(ë¯¸ì…˜)
    mission: null,
    nextMission: null,
    
    basicEvo: null, // basic turret evolution: null|pierce|focus
crystals: 80,
    selected: "basic",
    lastTime: nowSec(),
    time: 0,
    _finalBossJustDied: false,
win: null,
    stats: { runStart: nowSec(), runEnd: 0, finalWave: 0, kills: 0, damageTaken: 0, repairs: 0, turretBuilt: { basic:0, slow:0, splash:0, shred:0, breaker:0 } },

    hardError: "",

    debugLogs: [],
    uiMsg: "",
    uiMsgUntil: 0,

    // ì—°ì¶œ/UX(ì €ì¥ ì•ˆ í•¨): ì›¨ì´ë¸Œ/ë³´ìŠ¤/íŒ¨ì‹œë¸Œ ë“± ì¤‘ìš”í•œ ìˆœê°„ì— ì¤‘ì•™ ì¹´ë“œ í‘œì‹œ
    cine: {
      cards: []
    },

ui: {
  bgMode: 1,
  autoStartEnabled: false,  // ë‹¤ìŒ ì›¨ì´ë¸Œ ìë™ ì‹œì‘(ì €ì¥ ì•ˆ í•¨)

  upgTab: "all",        // all | core | turret | util
  upgSearch: "",
  upgOnlyCanBuy: false,
  upgSortMode: 0,       // 0 ê¸°ë³¸ | 1 ë¹„ìš©â†‘ | 2 ë¹„ìš©â†“
  upgCollapse: { core:false, turret:false, util:false },
},

    autoStartDelay: 10.0,
    autoStartAt: 0,

// ìµœì¢…ì „ ì¤€ë¹„(ì›¨ì´ë¸Œ 30 ì§ì „)
finalPrepEndsAt: 0,
finalChoice: null, // "offense" | "defense"
final: null,       // ìµœì¢… ë³´ìŠ¤ íŒ¨í„´ ìƒíƒœ


    upg: {
      coreHp: 0,
      coreShield: 0,
      hpArmor: 0,
      shieldArmor: 0,
      shieldRegen: 0,
      energyCannon: 0,
      repair: 0,
      turretDmg: 0,
      turretFire: 0,
      turretRange: 0,
      slowPower: 0,
      splashRadius: 0,
      projSpeed: 0,
      turretCrit: 0,
      slowDuration: 0,
      // sellRefund(íšŒìˆ˜ íš¨ìœ¨ ì—…ê·¸ë ˆì´ë“œ) ì œê±°ë¨
      aegisTune: 0,
      waveShield: 0,
    },

    enemies: [],
    turrets: [],
    projectiles: [],
    fx: [],

    flames: [],
    flameSpawnAcc: 0,

    debris: [],
    collapse: null, // {t, boomT, shake, fade}

    event: null,
    eventTextTimer: 0,

    mods: {
      shieldAbsorbMul: 1,
      shieldRegenMul: 1,
      turretDmgMul: 1,
      turretProjMul: 1,
      turretFireMul: 1,
      rewardMul: 1,
      enemyHpMul: 1,
      enemySpdMul: 1,
      enemyShieldMul: 1,
      enemyGrantShieldMul: 0,
    },

    // ìƒì  ì†Œë¹„ ì•„ì´í…œ(ì €ì¥ ì•ˆ í•¨)
    shop: {
      repairReadyAt: 0,
      fireReadyAt: 0,
      slowReadyAt: 0,
      fireUntil: 0,
      slowWave: 0,
    },


    core: {
      hpMax: 420, hp: 420,
      shieldMax: 300, shield: 300,
      shieldRegen: 7,
      hpArmor: 2,
      shieldArmor: 2,

      // ì½”ì–´ íŒ¨ì‹œë¸Œ(4íƒ1)
      passiveId: null,        // "
      passiveLocked: false, // ì¬ì‹œì‘ ì „ê¹Œì§€ íŒ¨ì‹œë¸Œ ë³€ê²½ ê¸ˆì§€ ("rebuild" | "resonance" | "overload" | "overdrive")
      passiveStacks: 0,       // ê³µëª… ë°˜ê²© ìŠ¤íƒ
      passiveLastHitAt: -999, // ë§ˆì§€ë§‰ í”¼ê²©(ìŠ¤íƒ ìœ ì§€/ê°ì†Œìš©)
      passiveStackDecayAcc: 0,
      overdriveShotAcc: 0,      // ì½”ì–´ ì˜¤ë²„ë“œë¼ì´ë¸Œ ë°œì‚¬ ëˆ„ì 
      passiveSalvageThisWave: 0, // íšŒìˆ˜ í”„ë¡œí† ì½œ: ì´ë²ˆ ì›¨ì´ë¸Œ ì¶”ê°€ íšë“ëŸ‰
      hpDirectDamaged: false, // HPì— "ì§ì ‘" í”¼í•´ë¥¼ ì…ì€ ì ì´ ìˆìœ¼ë©´ true (ì¬ê±´ ì½”ì–´ ìë™ìˆ˜ë¦¬ ì¡°ê±´)
      // ìë™ íšŒë³µ ì˜µì…˜
      // - ì‚¬ìš©ìê°€ ì›í•˜ì‹œë©´ trueë¡œ ë°”ê¾¸ë©´, ì›¨ì´ë¸Œê°€ ì•„ë‹Œ êµ¬ê°„ì—ì„œ HPê°€ ì²œì²œíˆ íšŒë³µë©ë‹ˆë‹¤.
      passiveHpRegenEnabled: false,
      // - ë³´í˜¸ë§‰ ìë™ ì¬ìƒì„ ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ í•˜ë ¤ë©´ false (í˜„ì¬ ê¸°ë³¸ false)
      shieldRegenOutOfWave: false,
// ìµœì¢… ë³´ìŠ¤ íŒ¨í„´ ë“±ìœ¼ë¡œ ì¼ì‹œì ìœ¼ë¡œ ë³´í˜¸ë§‰ ì¬ìƒì´ ì°¨ë‹¨ë  ìˆ˜ ìˆìŒ
shieldRegenBlockedUntil: 0,
// ì‹¤ë“œ/ìˆ˜ë¦¬/í¬íƒ‘ EMP ë””ë²„í”„(ì /ë³´ìŠ¤ íŒ¨í„´)
repairBlockedUntil: 0,
empUntil: 0,
empMul: 0.75,
      // ì›¨ì´ë¸Œ 30(ìµœì¢…ì „): ìˆ˜ì •íƒ‘ ì—ë„ˆì§€ ì§‘ì† ì—°ì¶œ(ì‹œê°íš¨ê³¼ìš©)
      finalCharge: 0,
      finalChargeAcc: 0,
      finalChargeOrbs: [],



      // ----- Repair (HP íšŒë³µ) -----
      // ìë™ ìˆ˜ë¦¬: build/clear ë‹¨ê³„ì—ì„œ, ìµœê·¼ HP í”¼í•´ í›„ ì¼ì • ì‹œê°„ ì§€ë‚˜ë©´ ì´ˆë‹¹ íšŒë³µ
      hpRegenPerSec: 6,
      hpRegenDelay: 4.0,
      lastHpDamageAt: -999,

      // ìˆ˜ë¦¬ ë²„íŠ¼/í‚¤(F): ìì› ì†Œëª¨ + ì¦‰ì‹œ íšŒë³µ + ì¿¨ë‹¤ìš´
      repairCost: 20,
      repairAmount: 90,
      repairCd: 12.0,
      repairReadyAt: 0,
      energyCd: 40.0,
      energyReadyAt: 0,

      // ----- Barrier (ë°©ì–´ì„ ) -----
      barrierActive: false,
      barrierReadyAt: 0,
      barrierUntil: 0,
      energyDmg: 800,
      energyChargeDur: 3.0,
      energyCharging: false,
      energyChargeStartAt: 0,
      energyChargeUntil: 0,
      energyChargeFxAt: 0,
      energyLock: null,
      aegisCd: 18.0,
      aegisReadyAt: 0,
      aegisActiveUntil: 0,

      // ----- Overload (ì„ê³„ ê³¼ë¶€í•˜) burst/mark -----
      overloadBurstUntil: 0,
      overloadBurstReadyAt: 0,
      overloadWasAbove30: true,
      overloadExtendReadyAt: 0,
      overloadKickReadyAt: 0,
    },

    spawn: null
  };

  // ---------- Performance caps (ëª¨ë°”ì¼ ë ‰ ë°©ì§€) ----------
  function isNarrowScreen(){ return (detectMobile && detectMobile()) || window.innerWidth <= 640; }

  function enemyCap(){
    if (state.wave === 30) return isNarrowScreen() ? 55 : 70; // ìµœì¢…ì „ì€ íŠ¹íˆ ì œí•œ
    return isNarrowScreen() ? 85 : 110;
  }
  function projCap(){
    if (state.wave === 30) return isNarrowScreen() ? 140 : 220;
    return isNarrowScreen() ? 220 : 320;
  }


  // ---------- Time (real vs game) ----------
  function gameSec(){ return state.gtime; }

  function setSpeed(v){
    state.speed = clamp(v, 0.25, 8);
    if (btnSpeed) btnSpeed.textContent = `ë°°ì† ${state.speed.toFixed(2).replace(/\.00$/,".0")}x`;
  }

  function cycleSpeed(){
    const steps = [0.5, 1, 1.5, 2, 3, 4];
    const cur = state.speed;
    let i = steps.findIndex(s => Math.abs(s-cur) < 0.01);
    if (i < 0) i = 1;
    i = (i + 1) % steps.length;
    setSpeed(steps[i]);
    setMsg(`ë°°ì†: ${state.speed.toFixed(2).replace(/\.00$/,".0")}x`, 1.8);
  }

  function toggleCheat(){
    state.cheat = !state.cheat;
    setMsg(state.cheat ? "ì¹˜íŠ¸ ON (Të¡œ ë„ê¸°)" : "ì¹˜íŠ¸ OFF", 2.0);
    syncCheatButtons();
  }

  function cheatGuard(){
    if (!state.cheat) { setMsg("ì¹˜íŠ¸ê°€ OFF ì…ë‹ˆë‹¤. (T)", 1.6); return false; }
    return true;
  }

  function cheatAddCrystals(n=500){
    if (!cheatGuard()) return;
    state.crystals += (n|0);
    setMsg(`í¬ë¦¬ìŠ¤íƒˆ +${n}`, 1.8);
  }

  function cheatHealHP(){
    if (!cheatGuard()) return;
    state.core.hp = state.core.hpMax;
    setMsg("HP í’€íšŒë³µ", 1.8);
  }

  function cheatRefillShield(){
    if (!cheatGuard()) return;
    state.core.shield = state.core.shieldMax;
    setMsg("ë³´í˜¸ë§‰ í’€ì¶©ì „", 1.8);
  }

  function cheatKillAll(){
    if (!cheatGuard()) return;
    const n = state.enemies.length;
    state.enemies.length = 0;
    state.projectiles = state.projectiles.filter(p=>p.kind !== "enemy");
    setMsg(`ì  ì œê±°: ${n}ë§ˆë¦¬`, 1.8);
  }

  function cheatSkipWave(){
    if (!cheatGuard()) return;
    if (state.phase === "wave") {
      cheatKillAll();
      clearWave();
    } else if (state.phase === "build" || state.phase === "clear" || state.phase === "finalprep") {
      startWave();
    }
    setMsg("ì›¨ì´ë¸Œ ìŠ¤í‚µ", 1.8);
  }

  function cheatMaxUpgrades(){
    if (!cheatGuard()) return;
    for (const def of UPGRADE_DEFS) state.upg[def.id] = def.max;
    applyUpgrades();
    setMsg("ì—…ê·¸ë ˆì´ë“œ MAX", 2.0);
  }

  function toggleGod(){
    if (!cheatGuard()) return;
    state.god = !state.god;
    setMsg(state.god ? "ë¬´ì  ON" : "ë¬´ì  OFF", 2.0);
  }

  // ì¹˜íŠ¸: í˜„ì¬ ì„ íƒëœ ì½”ì–´ íŒ¨ì‹œë¸Œë¥¼ "100%" ìƒíƒœë¡œ ê°•ì œ
  // - ê³µëª…: ê²Œì´ì§€ 100%(ì¦‰ì‹œ ë°©ì¶œ ê°€ëŠ¥)
  // - ê³¼ë¶€í•˜: ë²„ìŠ¤íŠ¸ ì¦‰ì‹œ ë°œë™
  // - ì¬ê±´: ê¸´ê¸‰ ë³´ê°• ì¦‰ì‹œ ë°œë™
  // - ì˜¤ë²„ë“œë¼ì´ë¸Œ: 8ì´ˆê°„ ìµœëŒ€ ì¶œë ¥(HPì™€ ë¬´ê´€)
  function cheatPassiveFull(){
    if (!cheatGuard()) return;
    const id = state.core.passiveId;
    const t = gameSec();
    if (!id) {
      setMsg("íŒ¨ì‹œë¸Œê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", 1.8);
      return;
    }

    if (id === "resonance") {
      resonanceEnsure();
      state.core.resGauge = 100;
      state.core.resDischargeReadyAt = 0;
      setMsg("ê³µëª… ê²Œì´ì§€ 100%", 1.8);
      return;
    }

    if (id === "overload") {
      overloadEnsure();
      state.core.overloadBurstReadyAt = 0;
      overloadShockBurst();
      setMsg("ê³¼ë¶€í•˜ ë²„ìŠ¤íŠ¸ ë°œë™", 1.8);
      return;
    }

    if (id === "rebuild") {
      const dur0 = (state.wave === FINAL_WAVE) ? 1.9 : 1.5;

      const dur = dur0 * passiveHardMul();
state.core.rebuildEmergencyUntil = t + dur;
      state.core.rebuildEmergencyReadyAt = t + 7.0;
      fxText("ê¸´ê¸‰ ë³´ê°•!(ì¹˜íŠ¸)", CORE_POS.x, CORE_POS.y - 128, "#93c5fd");
      fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+150, "#93c5fd");
      try { cineToast("ì¬ê±´ ì½”ì–´", `ê¸´ê¸‰ ë³´ê°• ${dur.toFixed(1)}s`, "#60a5fa", 1.05); } catch {}
      setMsg("ê¸´ê¸‰ ë³´ê°• ë°œë™", 1.8);
      return;
    }

    if (id === "overdrive") {
      state.core.overdriveCheatUntil = t + 8.0;
      fxText("ì˜¤ë²„ë“œë¼ì´ë¸Œ!(ì¹˜íŠ¸)", CORE_POS.x, CORE_POS.y - 128, "#c4b5fd");
      fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+150, "#c4b5fd");
      try { cineToast("ì½”ì–´ ì˜¤ë²„ë“œë¼ì´ë¸Œ", "ìµœëŒ€ ì¶œë ¥ 8s", "#a78bfa", 1.05); } catch {}
      setMsg("ì˜¤ë²„ë“œë¼ì´ë¸Œ ìµœëŒ€ ì¶œë ¥ 8s", 1.8);
      return;
    }

    setMsg("íŒ¨ì‹œë¸Œ 100% (ì¹˜íŠ¸)", 1.8);
  }

  // ---------- Upgrades ----------
  const CORE_BASE = {
    hpMax: state.core.hpMax,
    shieldMax: state.core.shieldMax,
    shieldRegen: state.core.shieldRegen,
    hpArmor: state.core.hpArmor,
    shieldArmor: state.core.shieldArmor,
    repairCost: state.core.repairCost,
    repairAmount: state.core.repairAmount,
    repairCd: state.core.repairCd,
    // ì—ë„ˆì§€í¬(ìŠ¤í‚¬) ê¸°ë³¸ê°’
    energyDmg: state.core.energyDmg,
    energyChargeDur: state.core.energyChargeDur,
    energyCd: state.core.energyCd,
    aegisCd: state.core.aegisCd,
  };

  const UPGRADE_DEFS = [
    { id:"coreHp", cat:"core", name:"ë³¸ì²´ ë‚´êµ¬(HP)", max:5, base:55, grow:1.55, desc:(lv)=>`ìµœëŒ€ HP +${40*lv}`, apply(){ state.core.hpMax = CORE_BASE.hpMax + 40*state.upg.coreHp; } },
    { id:"coreShield", cat:"core", name:"ë³´í˜¸ë§‰ ìš©ëŸ‰", max:5, base:55, grow:1.55, desc:(lv)=>`ìµœëŒ€ ë³´í˜¸ë§‰ +${30*lv}`, apply(){ state.core.shieldMax = CORE_BASE.shieldMax + 30*state.upg.coreShield; } },
    { id:"hpArmor", cat:"core", name:"ë°©ì–´ë ¥", max:5, base:60, grow:1.60, desc:(lv)=>`ë°©ì–´ë ¥ +${2*lv}`, apply(){ state.core.hpArmor = CORE_BASE.hpArmor + 2*state.upg.hpArmor; } },
    { id:"shieldArmor", cat:"core", name:"ë³´í˜¸ë§‰ ë°©ì–´ë ¥", max:5, base:60, grow:1.60, desc:(lv)=>`ë³´í˜¸ë§‰ ë°©ì–´ë ¥ +${2*lv}`, apply(){ state.core.shieldArmor = CORE_BASE.shieldArmor + 2*state.upg.shieldArmor; } },
    { id:"shieldRegen", cat:"core", name:"ë³´í˜¸ë§‰ ì¬ìƒ", max:5, base:70, grow:1.60, desc:(lv)=>`ì¬ìƒ +${(0.8*lv).toFixed(1)}/s`, apply(){ state.core.shieldRegen = CORE_BASE.shieldRegen + 0.8*state.upg.shieldRegen; } },

    { id:"repair", cat:"core", name:"ìˆ˜ë¦¬ ê³µí•™", max:6, base:75, grow:1.62,
      desc:(lv)=>`íšŒë³µ +${15*lv} / ë¹„ìš© -${2*lv} / ì¿¨ -${1*lv}s`,
      apply(){
        const lv = state.upg.repair;
        state.core.repairAmount = CORE_BASE.repairAmount + 15*lv;
        state.core.repairCost   = Math.max(8, CORE_BASE.repairCost - 2*lv);
        state.core.repairCd     = Math.max(6, CORE_BASE.repairCd - 1*lv);
      } },

    { id:"turretDmg", cat:"turret", name:"í¬íƒ‘ í™”ë ¥", max:6, base:80, grow:1.62, desc:(lv)=>`í”¼í•´ +${Math.round(15*lv)}%`, apply(){} },
    { id:"turretFire", cat:"turret", name:"í¬íƒ‘ ì—°ì‚¬", max:6, base:80, grow:1.62, desc:(lv)=>`ì—°ì‚¬ +${Math.round(10*lv)}%`, apply(){} },
    { id:"turretRange", cat:"turret", name:"í¬íƒ‘ ì‚¬ê±°ë¦¬", max:6, base:70, grow:1.58, desc:(lv)=>`ì‚¬ê±°ë¦¬ +${12*lv}`, apply(){} },

    { id:"projSpeed", cat:"turret", name:"íƒ„ì† ê°€ì†", max:5, base:65, grow:1.58, desc:(lv)=>`íƒ„ì† +${Math.round(15*lv)}%`, apply(){} },
    { id:"turretCrit", cat:"turret", name:"ì¹˜ëª…íƒ€", max:5, base:75, grow:1.60,
      desc:(lv)=>{
        const isHard = (state && state.diffId === "hard");
        const base = isHard ? 15 : 0;
        const per  = isHard ? 4 : 2;
        const mult = isHard ? 2.0 : 1.5;
        const total = base + per*lv;
        return isHard
          ? `ì¹˜ëª…íƒ€ í™•ë¥  ${total}% (x${mult.toFixed(1)})`
          : `ì¹˜ëª…íƒ€ í™•ë¥  +${per*lv}% (x${mult.toFixed(1)})`;
      },
      apply(){} },

    { id:"waveShield", cat:"core", name:"ê°œì „ ê³¼ì¶©ì „", max:5, base:70, grow:1.60, desc:(lv)=>`ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ ë³´í˜¸ë§‰ +${20*lv}`, apply(){} },
    { id:"slowDuration", cat:"turret", name:"ë‘”í™” ì§€ì†", max:5, base:60, grow:1.55, desc:(lv)=>`ë‘”í™” ì§€ì† +${(0.25*lv).toFixed(2)}s`, apply(){} },
    { id:"aegisTune", cat:"core", name:"ì•„ì´ê¸°ìŠ¤ íŠœë‹", max:6, base:85, grow:1.62,
      desc:(lv)=>`ê¸´ê¸‰ ë³´í˜¸ë§‰ ì¿¨ -${(1.5*lv).toFixed(1)}s`,
      apply(){
        const lv = state.upg.aegisTune;
        state.core.aegisCd = Math.max(6, CORE_BASE.aegisCd - 1.5*lv);
      } },

    // ì—ë„ˆì§€í¬ ì—…ê·¸ë ˆì´ë“œ: ë ˆë²¨ì— ë”°ë¼ í”¼í•´/ì¶©ì „/ì¿¨ì„ ê°œëŸ‰ (ì´ 6ë ˆë²¨)
    { id:"energyCannon", cat:"core", name:"ì—ë„ˆì§€í¬ ê°œëŸ‰", max:6, base:95, grow:1.62,
      // ì—…ê·¸ë ˆì´ë“œ UIì—ì„œ "í˜„ì¬/ë‹¤ìŒ"ì„ ë³´ì—¬ì£¼ê¸° ìœ„í•´, lv(í˜„ì¬ ë ˆë²¨)ì— í•´ë‹¹í•˜ëŠ” 'í˜„ì¬ ìŠ¤íƒ¯'ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
      desc:(lv)=>{
        const L = clamp(lv|0, 0, 6);
        // ê¸°ë³¸ê°’
        let dmg = CORE_BASE.energyDmg;
        let charge = CORE_BASE.energyChargeDur;
        let cd = CORE_BASE.energyCd;

        if (L >= 1) dmg = CORE_BASE.energyDmg + 100;
        if (L >= 4) dmg = CORE_BASE.energyDmg + 200;

        if (L >= 2) charge = CORE_BASE.energyChargeDur - 0.4;
        if (L >= 5) charge = CORE_BASE.energyChargeDur - 0.8;

        if (L >= 3) cd = CORE_BASE.energyCd - 5;
        if (L >= 6) cd = CORE_BASE.energyCd - 10;

        return `í”¼í•´ ${dmg} / ì¶©ì „ ${Math.max(1.2, charge).toFixed(1)}s / ì¿¨ ${Math.max(8, cd)}s`;
      },
      apply(){
        const lv = (state.upg.energyCannon|0);

        // ê¸°ë³¸ê°’
        let dmg = CORE_BASE.energyDmg;
        let charge = CORE_BASE.energyChargeDur;
        let cd = CORE_BASE.energyCd;

        if (lv >= 1) dmg = CORE_BASE.energyDmg + 100;
        if (lv >= 4) dmg = CORE_BASE.energyDmg + 200;

        if (lv >= 2) charge = CORE_BASE.energyChargeDur - 0.4;
        if (lv >= 5) charge = CORE_BASE.energyChargeDur - 0.8;

        if (lv >= 3) cd = CORE_BASE.energyCd - 5;
        if (lv >= 6) cd = CORE_BASE.energyCd - 10;

        state.core.energyDmg = dmg;
        state.core.energyChargeDur = Math.max(1.2, charge);
        state.core.energyCd = Math.max(8, cd);
      } },

    { id:"slowPower", cat:"turret", name:"ìŠ¬ë¡œìš° ê°•í™”", max:5, base:65, grow:1.58, desc:(lv)=>`ë‘”í™” +${Math.round(6*lv)}%`, apply(){} },
    { id:"splashRadius", cat:"turret", name:"ìŠ¤í”Œë˜ì‹œ ë°˜ê²½", max:5, base:65, grow:1.58, desc:(lv)=>`ë°˜ê²½ +${8*lv}`, apply(){} },

    // ì‹ ê·œ í¬íƒ‘ ì „ìš© ì—…ê·¸ë ˆì´ë“œ
    { id:"shredFocus", cat:"turret", name:"ì‹¤ë“œ ë¶„ì‡„ ê°•í™”", max:5, base:75, grow:1.60,
      desc:(lv)=>`ë³´í˜¸ë§‰ ì¶”ê°€í”¼í•´ ë°°ìœ¨ +${(0.15*lv).toFixed(2)}`, apply(){} },
    { id:"breakerMark", cat:"turret", name:"ì·¨ì•½ í‘œì‹ ê°•í™”", max:5, base:80, grow:1.60,
      desc:(lv)=>`ë°›í”¼ì¦ +${Math.round(3*lv)}% / ì§€ì† +${(0.2*lv).toFixed(1)}s`, apply(){} },
  ];

  function upgCost(def){
    const lv = state.upg[def.id];
    const cost = def.base * Math.pow(def.grow, lv);
    return Math.round(cost/5)*5;
  }

  function applyUpgrades(){
    // base -> upgraded
    for (const def of UPGRADE_DEFS) def.apply();
    // clamp current values to new max
    state.core.hp = clamp(state.core.hp, 0, state.core.hpMax);
    state.core.shield = clamp(state.core.shield, 0, state.core.shieldMax);
  }

  function buyUpgrade(id){
    const def = UPGRADE_DEFS.find(d=>d.id===id);
    if (!def) return;
    const lv = state.upg[id];
    if (lv >= def.max) return;

    const cost = upgCost(def);
    if (state.crystals < cost) return;

    state.crystals -= cost;
    state.upg[id]++;

    applyUpgrades();
    SFX.play("click");
    setMsg(`ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ: ${def.name} (-${cost})`, 1.8);
    fxText(`ê°•í™”: ${def.name}`, CORE_POS.x, CORE_POS.y - 92, "#93c5fd");
  }

function ensureUpgUI(){
  if (!state.ui) {
    state.ui = { upgTab:"all", upgSearch:"", upgOnlyCanBuy:false, upgSortMode:0, upgCollapse:{core:false,turret:false,util:false}, upgPanelCollapsed:{pc:false, side:false} };
  }
  if (!state.ui.upgCollapse) state.ui.upgCollapse = { core:false, turret:false, util:false };
  if (!state.ui.upgPanelCollapsed) state.ui.upgPanelCollapsed = { pc:false, side:false };
  if (!("upgOnlyCanBuy" in state.ui)) state.ui.upgOnlyCanBuy = false;
  if (!("upgSortMode" in state.ui)) state.ui.upgSortMode = 0;
  if (!state.ui.upgTab) state.ui.upgTab = "all";
  if (state.ui.upgSearch == null) state.ui.upgSearch = "";
  if (!("pc" in state.ui.upgPanelCollapsed)) state.ui.upgPanelCollapsed.pc = false;
  if (!("side" in state.ui.upgPanelCollapsed)) state.ui.upgPanelCollapsed.side = false;
}

function sortLabel(mode){
  return mode === 1 ? "ë¹„ìš©â†‘" : mode === 2 ? "ë¹„ìš©â†“" : "ê¸°ë³¸";
}

function syncUpgControls(){
  const ui = state.ui;
  const wraps = [document.getElementById("uiUpgrades"), document.getElementById("uiUpgradesPC")].filter(Boolean);
  for (const w of wraps){
    // tabs
    const tabs = w.querySelectorAll("[data-upg-tab]");
    tabs.forEach(btn=>{
      btn.classList.toggle("active", btn.dataset.upgTab === ui.upgTab);
    });
    // search
    const inp = w.querySelector("[data-upg-search]");
    if (inp && inp.value !== ui.upgSearch) inp.value = ui.upgSearch;
    // only
    const onlyBtn = w.querySelector("[data-upg-only]");
    if (onlyBtn) onlyBtn.textContent = `êµ¬ë§¤ê°€ëŠ¥ë§Œ: ${ui.upgOnlyCanBuy ? "ON" : "OFF"}`;
    // sort
    const sortBtn = w.querySelector("[data-upg-sort]");
    if (sortBtn) sortBtn.textContent = `ì •ë ¬: ${sortLabel(ui.upgSortMode)}`;
  }

  const panels = [
    { key: "pc", el: document.getElementById("upgPanelPC") },
    { key: "side", el: document.getElementById("upgPanelSide") },
  ];
  for (const { key, el } of panels) {
    if (!el) continue;
    const collapsed = !!(ui.upgPanelCollapsed && ui.upgPanelCollapsed[key]);
    el.classList.toggle("collapsed", collapsed);
    const btn = el.querySelector(`[data-upg-panel-toggle="${key}"]`);
    if (btn) {
      btn.textContent = collapsed ? "í¼ì¹˜ê¸°" : "ì ‘ê¸°";
      btn.setAttribute("aria-expanded", collapsed ? "false" : "true");
    }
  }
}

function renderUpgrades(){
  if (!upgContainers || upgContainers.length === 0) return;
  ensureUpgUI();

  const ui = state.ui;
  const q = (ui.upgSearch || "").trim().toLowerCase();

  const canBuyOf = (def) => {
    const lv = state.upg[def.id];
    const cost = upgCost(def);
    const enough = (state.crystals >= cost);
    return (lv < def.max) && enough && (state.phase !== "fail") && (state.phase !== "win");
  };

  const match = (def) => {
    if (ui.upgTab !== "all" && def.cat !== ui.upgTab) return false;
    if (ui.upgOnlyCanBuy && !canBuyOf(def)) return false;
    if (!q) return true;
    const hay = `${def.name} ${def.cat || ""}`.toLowerCase();
    return hay.includes(q);
  };

  // í•„í„° + ì •ë ¬ ì¤€ë¹„
  const filtered = UPGRADE_DEFS.filter(match);

  const sortMode = ui.upgSortMode|0;
  const sorter = (a,b) => {
    if (sortMode === 1) return upgCost(a) - upgCost(b);
    if (sortMode === 2) return upgCost(b) - upgCost(a);
    return 0; // ê¸°ë³¸(ì •ì˜ ìˆœì„œ ìœ ì§€)
  };

  const CAT_META = [
    ["core",   "ì½”ì–´ ê°•í™”"],
    ["turret", "í¬íƒ‘/ì „íˆ¬"],
    ["util",   "ìœ í‹¸/ê²½ì œ"],
  ];

  const totalByCat = {};
  for (const def of UPGRADE_DEFS) totalByCat[def.cat] = (totalByCat[def.cat]||0) + 1;

  let out = "";
  for (const [cat, title] of CAT_META) {
    const defs = filtered.filter(d=>d.cat===cat);
    // Utility íƒ­ì— ìƒì  ì†Œë¹„ ì•„ì´í…œì„ í‘œì‹œ
    const wantShopItems = (cat === "util" && ui.upgTab === "util");
    if (!defs.length && !wantShopItems) continue;

    // ì •ë ¬(ê¸°ë³¸ì´ë©´ ì•ˆì • ì •ë ¬ ìœ ì§€)
    const list = (sortMode === 0) ? defs : defs.slice().sort(sorter);

    const collapsed = !!(ui.upgCollapse && ui.upgCollapse[cat]);

    out += `<div class="upgSection ${collapsed ? "collapsed" : ""}" data-upg-sec="${cat}">
      <div class="upgSectionHeader" data-upg-toggle="${cat}">
        <div>${title}</div>
        <div style="display:flex; gap:10px; align-items:center;">
          <div class="count">${defs.length}/${totalByCat[cat]||defs.length}</div>
          <div class="chev">${collapsed ? "â–¶" : "â–¼"}</div>
        </div>
      </div>
      <div class="upgGrid">
    `;

	    // --- Shop consumables (Utility íƒ­) ---
	    if (wantShopItems) {
	      const tNow = gameSec();
	      const inWave = (state.phase === "wave");
	      const hpFull = (state.core.hp >= state.core.hpMax - 0.01);
	      const blockLeft = Math.max(0, (state.core.repairBlockedUntil||0) - tNow);

	      const cdR = Math.max(0, (state.shop.repairReadyAt||0) - tNow);
	      const cdF = Math.max(0, (state.shop.fireReadyAt||0) - tNow);
	      const cdS = Math.max(0, (state.shop.slowReadyAt||0) - tNow);

	      const slowAlready = (state.shop.slowWave === state.wave) && inWave;
	      const fireLeft = inWave ? Math.max(0, (state.shop.fireUntil||0) - tNow) : 0;

	      const canRepair = (state.phase !== "fail") && (state.phase !== "win") && (blockLeft <= 0.05) && (cdR <= 0.05) && (!hpFull) && (state.crystals >= SHOP_ITEM_REPAIR_COST);
	      const canFire   = (state.phase !== "fail") && (state.phase !== "win") && inWave && (cdF <= 0.05) && (state.crystals >= SHOP_ITEM_FIRE_COST);
	      const canSlow   = (state.phase !== "fail") && (state.phase !== "win") && inWave && (!slowAlready) && (cdS <= 0.05) && (state.crystals >= SHOP_ITEM_SLOW_COST);

	      const rowClass = (canRepair || canFire || canSlow) ? "upgRow canBuy" : "upgRow disabled";

	      let lblRepair = `ì¦‰ì‹œ ìˆ˜ë¦¬ (-${SHOP_ITEM_REPAIR_COST})`;
	      if (hpFull) lblRepair = "ì¦‰ì‹œ ìˆ˜ë¦¬ (HP ë§Œë•…)";
	      else if (blockLeft > 0.05) lblRepair = `ì¦‰ì‹œ ìˆ˜ë¦¬ (ì°¨ë‹¨ ${blockLeft.toFixed(1)}s)`;
	      else if (cdR > 0.05) lblRepair = `ì¦‰ì‹œ ìˆ˜ë¦¬ (${cdR.toFixed(1)}s)`;

	      let lblFire = `ê³µì† 10s (-${SHOP_ITEM_FIRE_COST})`;
	      if (!inWave) lblFire = `ê³µì† 10s (-${SHOP_ITEM_FIRE_COST}) Â· ì›¨ì´ë¸Œ ì¤‘`;
	      else if (cdF > 0.05) lblFire = `ê³µì† 10s (${cdF.toFixed(1)}s)`;
	      if (fireLeft > 0.05) lblFire += ` Â· í™œì„± ${fireLeft.toFixed(1)}s`;

	      let lblSlow = `ì›¨ì´ë¸Œ ìŠ¬ë¡œìš° (-${SHOP_ITEM_SLOW_COST})`;
	      if (!inWave) lblSlow = `ì›¨ì´ë¸Œ ìŠ¬ë¡œìš° (-${SHOP_ITEM_SLOW_COST}) Â· ì›¨ì´ë¸Œ ì¤‘`;
	      else if (slowAlready) lblSlow = "ì›¨ì´ë¸Œ ìŠ¬ë¡œìš° (ì ìš©ì¤‘)";
	      else if (cdS > 0.05) lblSlow = `ì›¨ì´ë¸Œ ìŠ¬ë¡œìš° (${cdS.toFixed(1)}s)`;

	      const hint = "ì†Œë¹„ ì•„ì´í…œ: ì¦‰ì‹œ ìˆ˜ë¦¬ / ê³µì† 10s / ìŠ¬ë¡œìš°(1 ì›¨ì´ë¸Œ)";
	      out += `
	        <div class="${rowClass}" style="cursor:default;" title="${hint}">
	          <div class="upgTop">
	            <div class="upgNameLine">
	              <b>ì†Œë¹„ ì•„ì´í…œ</b>
	              <span class="muted">ìœ í‹¸ íƒ­ ì „ìš©</span>
	            </div>
	            <div style="display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end;">
	              <button class="miniBtn" data-shop-item="repair" ${canRepair ? "" : "disabled"}>${lblRepair}</button>
	              <button class="miniBtn" data-shop-item="fire"   ${canFire   ? "" : "disabled"}>${lblFire}</button>
	              <button class="miniBtn" data-shop-item="slow"   ${canSlow   ? "" : "disabled"}>${lblSlow}</button>
	            </div>
	          </div>
	          <div class="upgDesc">
	            <div><span class="muted">ì¦‰ì‹œ ìˆ˜ë¦¬</span> ë¶€ì¡±ë¶„ì˜ 35% (ìµœì†Œ 20) íšŒë³µ</div>
	            <div><span class="muted">ê³µì†/ìŠ¬ë¡œìš°</span> ì›¨ì´ë¸Œ ì¤‘ ì‚¬ìš© Â· ê³µì† Ã—${SHOP_ITEM_FIRE_MUL.toFixed(2)} Â· ì  ì´ë™ Ã—${SHOP_ITEM_SLOW_MUL.toFixed(2)}</div>
	          </div>
	        </div>
	      `;
	    }

    // --- Basic Turret Evolution (branch) ---
    if (cat === "turret") {
      const needLv = 3;
      const unlocked = ((state.upg.turretDmg|0) >= needLv);
      const canPick = unlocked && (state.phase !== "wave") && (state.phase !== "fail") && (state.phase !== "win");
      const cur = state.basicEvo || "none";
      const label = (cur === "pierce") ? "A ê´€í†µ" : (cur === "focus" ? "B ì§‘ì¤‘" : "ë¯¸ì„ íƒ");
      const hint = unlocked ? (canPick ? "A/B ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤." : "ì›¨ì´ë¸Œ/ê²°ê³¼ í™”ë©´ì—ì„œëŠ” ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.") : `ì ê¹€: í¬íƒ‘ í™”ë ¥ Lv ${needLv} í•„ìš”`;
      const selStyle = (on)=> on ? 'style="border-color: rgba(96,165,250,0.65); background: rgba(96,165,250,0.16);"' : '';
      out += `
        <div class="upgRow ${unlocked ? "canBuy" : "disabled"}" style="cursor:default;" title="${hint}">
          <div class="upgTop">
            <div class="upgNameLine">
              <b>ê¸°ë³¸ í¬íƒ‘ ì§„í™”</b>
              <span class="muted">${unlocked ? `í˜„ì¬: ${label}` : `Lv ${needLv} í•„ìš”`}</span>
            </div>
            <div style="display:flex; gap:6px;">
              <button class="miniBtn" data-basic-evo="pierce" ${canPick ? "" : "disabled"} ${selStyle(cur==="pierce")}>A ê´€í†µ</button>
              <button class="miniBtn" data-basic-evo="focus"  ${canPick ? "" : "disabled"} ${selStyle(cur==="focus")}>B ì§‘ì¤‘</button>
            </div>
          </div>
          <div class="upgDesc">
            <div><span class="muted">A</span> ê´€í†µ 2íšŒ Â· í”¼í•´ -12% Â· íƒ„ì† +10% Â· ì‚¬ê±°ë¦¬ +5%</div>
            <div><span class="muted">B</span> í”¼í•´ +55% Â· ê³µì† -30% Â· ë³´ìŠ¤ í”¼í•´ +35% Â· ì‚¬ê±°ë¦¬ +8%</div>
          </div>
        </div>
      `;
    }
for (const def of list) {
      const lv = state.upg[def.id];
      const max = def.max;
      const cost = upgCost(def);
      const enough = (state.crystals >= cost);
      const canBuy = canBuyOf(def);

      const descCur = def.desc(lv);
      const descNext = (lv >= max) ? "MAX" : def.desc(lv + 1);

      const rowClass = canBuy ? "upgRow canBuy" : "upgRow disabled";
      const btnLabel = (lv >= max) ? "MAX" : `${cost}`;
      const btnDisabled = (lv >= max) || (!enough) || (state.phase === "fail") || (state.phase === "win");
      const btnClass = btnDisabled ? "miniBtn isDisabled" : "miniBtn";

      const hint = (lv >= max)
        ? "ìµœëŒ€ ë ˆë²¨ì…ë‹ˆë‹¤."
        : (!enough ? `ìì› ë¶€ì¡± (í•„ìš” ${cost}, ë³´ìœ  ${state.crystals})` : (state.phase === "win" ? "í´ë¦¬ì–´ í›„ì—ëŠ” ê°•í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤." : "êµ¬ë§¤ ê°€ëŠ¥"));

      out += `
        <div class="${rowClass}" data-upg="${def.id}" data-can="${canBuy ? 1 : 0}" title="${hint}">
          <div class="upgTop">
            <div class="upgNameLine">
              <b>${def.name}</b>
              <span class="muted">Lv ${lv}/${max}</span>
            </div>
            <button class="${btnClass}">${btnLabel}</button>
          </div>
          <div class="upgDesc">
            <div><span class="muted">í˜„ì¬</span> ${descCur}</div>
            <div><span class="muted">ë‹¤ìŒ</span> ${descNext}</div>
          </div>
        </div>
      `;
    }

    out += `</div></div>`;
  }

  // ì•„ë¬´ê²ƒë„ ì—†ì„ ë•Œ
  if (!out) {
    out = `<div class="muted" style="padding:10px; opacity:0.8;">ì¡°ê±´ì— ë§ëŠ” ì—…ê·¸ë ˆì´ë“œê°€ ì—†ìŠµë‹ˆë‹¤.</div>`;
  }

  for (const el of upgContainers) el.innerHTML = out;
  syncUpgControls();
}

  // ---------- UI ----------
  const uiStats = document.getElementById("uiStats");
    const uiCrystals = document.getElementById("uiCrystals");
  // HUD (ìƒë‹¨ ì˜¤ë²„ë ˆì´)
  const hudWave = document.getElementById("hudWave");
  const hudHpFill = document.getElementById("hudHpFill");
  const hudHpText = document.getElementById("hudHpText");
    const hudHpRow = (hudHpFill && hudHpFill.closest) ? hudHpFill.closest(".hudBarRow") : null;
const hudShFill = document.getElementById("hudShFill");
  const hudShText = document.getElementById("hudShText");
  const hudArmor = document.getElementById("hudArmor");
  const hudShArmor = document.getElementById("hudShArmor");
  const hudMeta = document.getElementById("hudMeta");
  const hudPassiveText = document.getElementById("hudPassiveText");
  const hudPassiveFill = document.getElementById("hudPassiveFill");
  const hudStatusRow = document.getElementById("hudStatusRow");

const uiMsg   = document.getElementById("uiMsg");
const uiCheat = document.getElementById("uiCheat");
const uiUpgradesWrap = document.getElementById("uiUpgrades");
const uiUpgradesPCWrap = document.getElementById("uiUpgradesPC");
const upgPanelPC = document.getElementById("upgPanelPC");
const upgPanelSide = document.getElementById("upgPanelSide");
const uiUpgListSide = document.getElementById("uiUpgListSide") || uiUpgradesWrap;
const uiUpgListPC   = document.getElementById("uiUpgListPC")   || uiUpgradesPCWrap;
const upgContainers = [uiUpgListSide, uiUpgListPC].filter(Boolean);
const upgWraps = [uiUpgradesWrap, uiUpgradesPCWrap].filter(Boolean);

// ì—…ê·¸ë ˆì´ë“œ UI ì»¨íŠ¸ë¡¤(íƒ­/ê²€ìƒ‰/í† ê¸€/ì„¹ì…˜ ì ‘ê¸°)
function bindUpgradeControls(){
  ensureUpgUI();

  for (const w of upgWraps){
    if (!w || w.__upgCtlBound) continue;
    w.__upgCtlBound = true;

    // í´ë¦­: íƒ­/í† ê¸€ ë²„íŠ¼
    w.addEventListener("click", (ev)=>{
      const tabBtn = ev.target.closest("[data-upg-tab]");
      if (tabBtn) {
        ev.preventDefault(); ev.stopPropagation();
        ensureUpgUI();
        state.ui.upgTab = tabBtn.dataset.upgTab || "all";
        window.__upgLastRenderAt = 0;
        window.__upgForceRender = true;
        refreshUI();
        return;
      }

      const onlyBtn = ev.target.closest("[data-upg-only]");
      if (onlyBtn) {
        ev.preventDefault(); ev.stopPropagation();
        ensureUpgUI();
        state.ui.upgOnlyCanBuy = !state.ui.upgOnlyCanBuy;
        window.__upgLastRenderAt = 0;
        window.__upgForceRender = true;
        refreshUI();
        return;
      }

      const sortBtn = ev.target.closest("[data-upg-sort]");
      if (sortBtn) {
        ev.preventDefault(); ev.stopPropagation();
        ensureUpgUI();
        state.ui.upgSortMode = ((state.ui.upgSortMode|0) + 1) % 3;
        window.__upgLastRenderAt = 0;
        window.__upgForceRender = true;
        refreshUI();
        return;
      }

      const panelBtn = ev.target.closest("[data-upg-panel-toggle]");
      if (panelBtn) {
        ev.preventDefault(); ev.stopPropagation();
        ensureUpgUI();
        const key = panelBtn.dataset.upgPanelToggle;
        if (key) {
          state.ui.upgPanelCollapsed[key] = !state.ui.upgPanelCollapsed[key];
          window.__upgLastRenderAt = 0;
          window.__upgForceRender = true;
          refreshUI();
        }
        return;
      }
    }, { capture:true });

    // ê²€ìƒ‰
    const inp = w.querySelector("[data-upg-search]");
    if (inp && !inp.__bound) {
      inp.__bound = true;
      inp.addEventListener("input", ()=>{
        ensureUpgUI();
        state.ui.upgSearch = inp.value || "";
        window.__upgLastRenderAt = 0;
        window.__upgForceRender = true;
        refreshUI();
      });
      // íŒ¨ë„/ìº”ë²„ìŠ¤ë¡œ ì…ë ¥ì´ ìƒˆì§€ ì•Šê²Œ
      inp.addEventListener("pointerdown", (ev)=>{ ev.stopPropagation(); }, { capture:true });
      inp.addEventListener("keydown", (ev)=>{
        if (ev.key === "Escape") {
          inp.value = "";
          ensureUpgUI();
          state.ui.upgSearch = "";
          window.__upgLastRenderAt = 0;
          window.__upgForceRender = true;
          refreshUI();
        }
      });
    }
  }

  // ì„¹ì…˜ ì ‘ê¸°/í¼ì¹˜ê¸°(ë¦¬ìŠ¤íŠ¸ ë‚´ë¶€ ìš”ì†Œì´ë¯€ë¡œ ìœ„ì„)
  for (const list of upgContainers){
    if (!list || list.__upgListBound) continue;
    list.__upgListBound = true;
    list.addEventListener("click", (ev)=>{
      const t = ev.target.closest("[data-upg-toggle]");
      if (!t) return;
      ev.preventDefault(); ev.stopPropagation();
      ensureUpgUI();
      const cat = t.dataset.upgToggle;
      if (!cat) return;
      state.ui.upgCollapse[cat] = !state.ui.upgCollapse[cat];
      window.__upgLastRenderAt = 0;
      window.__upgForceRender = true;
      refreshUI();
    }, { capture:true });
  }

	  // ì—…ê·¸ë ˆì´ë“œ ë²„ê·¸(í˜¸ë²„/íˆ´íŒì´ ë¦¬ë Œë”ë¡œ ëŠê¸°ëŠ” ë¬¸ì œ) ë°©ì§€:
	  // ë¦¬ìŠ¤íŠ¸ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦° ë™ì•ˆì—ëŠ” ì£¼ê¸°ì  ë¦¬ë Œë”ë¥¼ ì ì‹œ ë©ˆì¶˜ë‹¤.
	  if (typeof window.__upgHoverCount === "undefined") window.__upgHoverCount = 0;
	  for (const list of upgContainers){
	    if (!list || list.__upgHoverBound) continue;
	    list.__upgHoverBound = true;
	    const onEnter = ()=>{
	      window.__upgHoverCount = (window.__upgHoverCount|0) + 1;
	      window.__freezeUpgRender = true;
	    };
	    const onLeave = ()=>{
	      window.__upgHoverCount = Math.max(0, (window.__upgHoverCount|0) - 1);
	      if (window.__upgHoverCount === 0) {
	        window.__freezeUpgRender = false;
	        window.__upgForceRender = true;
	      }
	    };
	    list.addEventListener("pointerenter", onEnter);
	    list.addEventListener("pointerleave", onLeave);
	    // ì¼ë¶€ í™˜ê²½ì—ì„œ pointerenter/leaveê°€ ë¶ˆì•ˆì •í•  ë•Œë¥¼ ëŒ€ë¹„
	    list.addEventListener("mouseenter", onEnter);
	    list.addEventListener("mouseleave", onLeave);
	  }
}
bindUpgradeControls();

document.addEventListener("keydown", (ev)=>{
  if (ev.key !== "/") return;
  if (ev.target && (ev.target.tagName === "INPUT" || ev.target.tagName === "TEXTAREA")) return;
  ensureUpgUI();
  const pickSearch = () => {
    if (upgPanelPC && !state.ui.upgPanelCollapsed.pc && upgPanelPC.offsetParent) {
      const input = upgPanelPC.querySelector("[data-upg-search]");
      if (input) return input;
    }
    if (upgPanelSide && !state.ui.upgPanelCollapsed.side && upgPanelSide.offsetParent) {
      const input = upgPanelSide.querySelector("[data-upg-search]");
      if (input) return input;
    }
    return document.querySelector("[data-upg-search]");
  };
  const input = pickSearch();
  if (input) {
    ev.preventDefault();
    input.focus();
  }
});

  const uiEvent = document.getElementById("uiEvent");
  const uiRecords = document.getElementById("uiRecords");
  const btnResetRecords = document.getElementById("btnResetRecords");

  const uiPreview = document.getElementById("uiPreview");

  const uiMapEl = document.getElementById("uiMap");
  const uiMapBonus = document.getElementById("uiMapBonus");

  const btnCoreRebuild   = document.getElementById("btnCoreRebuild");
  const btnCoreResonance = document.getElementById("btnCoreResonance");
  const btnCoreOverload  = document.getElementById("btnCoreOverload");
  const btnCoreOverdrive = document.getElementById("btnCoreOverdrive");
  const uiCorePassiveDesc = document.getElementById("uiCorePassiveDesc");
  // (PC) ì½”ì–´ íŒ¨ì‹œë¸Œ ìƒíƒœ í‘œì‹œ: ìƒë‹¨ ë¯¸ì„ íƒ ë°°ì§€ ì‚­ì œë¨
  const uiCorePassiveChosenWrap = document.getElementById("uiCorePassiveChosenWrap");
  const uiCorePassiveChosenName = document.getElementById("uiCorePassiveChosenName");
  const uiCorePassiveChosenTag  = document.getElementById("uiCorePassiveChosenTag");
const finalSupportPanel = document.getElementById("finalSupportPanel");
const btnFinalOffense   = document.getElementById("btnFinalOffense");
const btnFinalDefense   = document.getElementById("btnFinalDefense");
const uiFinalSupportDesc = document.getElementById("uiFinalSupportDesc");

// ===== Run Records (localStorage) =====
// ë‚œì´ë„ë³„ ë¶„ë¦¬ ì €ì¥ (v2)
const RECORD_KEY_LEGACY = "shield_defense_records_v1";
const RECORD_KEY_BASE   = "shield_defense_records_v2";
let __records = null;
let __recordsLastRenderAt = 0;

function recordKeyForDiff(diffId){
  const k = (diffId && typeof diffId === 'string') ? diffId : ((state && state.diffId) ? String(state.diffId) : 'normal');
  const kk = (k === 'easy' || k === 'hard' || k === 'normal') ? k : 'normal';
  return `${RECORD_KEY_BASE}_${kk}`;
}

function loadRecords(){
  try {
    const key = recordKeyForDiff();
    const raw = localStorage.getItem(key);
    if (!raw) {
      // (ê¶Œì¥) legacy(v1) -> v2_normal 1íšŒ ë§ˆì´ê·¸ë ˆì´ì…˜
      try {
        if (key === `${RECORD_KEY_BASE}_normal`) {
          const legacyRaw = localStorage.getItem(RECORD_KEY_LEGACY);
          if (legacyRaw) {
            const legacy = JSON.parse(legacyRaw);
            if (legacy && typeof legacy === 'object') {
              const mig = { bestRun: legacy.bestRun || null, lastRun: legacy.lastRun || null };
              localStorage.setItem(key, JSON.stringify(mig));
              return mig;
            }
          }
        }
      } catch(e2) {}
      return { bestRun:null, lastRun:null };
    }
    const obj = JSON.parse(raw);
    if (!obj || typeof obj !== "object") return { bestRun:null, lastRun:null };
    if (!("bestRun" in obj)) obj.bestRun = null;
    if (!("lastRun" in obj)) obj.lastRun = null;
    return obj;
  } catch(e) {
    return { bestRun:null, lastRun:null };
  }
}

function saveRecords(){
  try {
    const key = recordKeyForDiff();
    localStorage.setItem(key, JSON.stringify(__records||{bestRun:null,lastRun:null}));
  } catch(e) {}
}

function passiveName(pid){
  try {
    if (!pid) return "ë¯¸ì„ íƒ";
    const d = CORE_PASSIVES && CORE_PASSIVES[pid];
    return d ? d.name : String(pid);
  } catch(e) { return pid || "ë¯¸ì„ íƒ"; }
}

function basicEvoName(e){
  if (e === "pierce") return "A ê´€í†µ";
  if (e === "focus") return "B ì§‘ì¤‘";
  return "ë¯¸ì„ íƒ";
}

function mapName(mid){
  if (mid === "sanctuary") return "ì„±ì—­";
  if (mid === "void") return "ê³µí—ˆ";
  if (mid === "wasteland") return "í™©ë¬´ì§€";
  return mid || "â€”";
}

function turretRatioText(tb){
  const keys = ["basic","slow","splash","shred","breaker"];
  const names = { basic:"ê¸°ë³¸", slow:"ê°ì†", splash:"ìŠ¤í”Œë˜ì‹œ", shred:"ì‹¤ë“œë¶„ì‡„", breaker:"ë°©í˜¸íŒŒê´´" };
  const total = keys.reduce((a,k)=> a + ((tb && tb[k])|0), 0);
  if (!total) return "ì—†ìŒ";
  const parts = keys
    .map(k=> ({k, n: (tb && tb[k])|0}))
    .filter(x=> x.n>0)
    .sort((a,b)=> b.n-a.n)
    .map(x=>{
      const pct = Math.round((x.n/total)*100);
      return `${names[x.k]||x.k} ${pct}%(${x.n})`;
    });
  return parts.join(" Â· ");
}

function buildRunSummary(isWin){
  const wave = isWin ? FINAL_WAVE : (state.wave|0);
  const time = Math.max(0, state.gtime||0);
  const passive = state.core ? (state.core.passiveId||null) : null;
  const basicEvo = state.basicEvo || null;
  const mapId = (state.mapId || (state.map && state.map.id) || null);
  const tb = (state.stats && state.stats.turretBuilt) ? state.stats.turretBuilt : null;
  const turretBuilt = {
    basic: (tb && tb.basic)|0,
    slow: (tb && tb.slow)|0,
    splash: (tb && tb.splash)|0,
    shred: (tb && tb.shred)|0,
    breaker: (tb && tb.breaker)|0,
  };
  return {
    at: Date.now(),
    win: !!isWin,
    wave,
    time,
    passive,
    basicEvo,
    mapId,
    turretBuilt
  };
}

function updateRecordsWithRun(run){
  if (!__records) __records = loadRecords();
  __records.lastRun = run;

  const best = __records.bestRun;
  const better =
    (!best) ||
    (run.wave > (best.wave|0)) ||
    (run.wave === (best.wave|0) && run.time < (best.time||1e18));
  if (better) __records.bestRun = run;

  saveRecords();
}

function renderRecords(force=false){
  if (!uiRecords) return;
  if (!__records) __records = loadRecords();

  const tNow = nowSec();
  if (!force && (tNow - __recordsLastRenderAt) < 0.6) return;
  __recordsLastRenderAt = tNow;

  const best = __records.bestRun;
  const last = __records.lastRun;

  const lines = [];
  if (best) {
    lines.push(`<b>ìµœê³  ì›¨ì´ë¸Œ</b>: WAVE ${best.wave} Â· ${formatTime(best.time||0)} Â· ${passiveName(best.passive)} Â· ë§µ ${mapName(best.mapId)}`);
    lines.push(`<span class="small">í¬íƒ‘ ë¹„ìœ¨: ${turretRatioText(best.turretBuilt)}</span>`);
    lines.push(`<span class="small">ê¸°ë³¸ í¬íƒ‘ ì§„í™”: ${basicEvoName(best.basicEvo)}</span>`);
  } else {
    lines.push("ì•„ì§ ì €ì¥ëœ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.");
    lines.push(`<span class="small">í•œ íŒ í”Œë ˆì´í•˜ë©´ ìë™ ì €ì¥ë©ë‹ˆë‹¤.</span>`);
  }

  if (last) {
    const sep = `<div style="height:8px;"></div>`;
    lines.push(sep + `<b>ë§ˆì§€ë§‰ ëŸ°</b>: WAVE ${last.wave} Â· ${formatTime(last.time||0)} Â· ${passiveName(last.passive)} ${last.win ? "(ìŠ¹ë¦¬)" : "(ì‹¤íŒ¨)"} Â· ë§µ ${mapName(last.mapId)}`);
    lines.push(`<span class="small">í¬íƒ‘ ë¹„ìœ¨: ${turretRatioText(last.turretBuilt)}</span>`);
    lines.push(`<span class="small">ê¸°ë³¸ í¬íƒ‘ ì§„í™”: ${basicEvoName(last.basicEvo)}</span>`);
  }

  uiRecords.innerHTML = lines.join("<br>");
}

if (btnResetRecords) {
  btnResetRecords.onclick = ()=>{
    try {
      __records = { bestRun:null, lastRun:null };
      saveRecords();
      renderRecords(true);
      try { SFX.play("click"); } catch(e) {}
      state.uiMsg = "ëŸ° ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.";
      state.uiMsgUntil = nowSec() + 2.0;
    } catch(e) {}
  };
}
// ===== End Records =====


// ===== Main Menu + Difficulty Pick (v11-step29) =====
const mainMenuMask = document.getElementById("mainMenuMask");
const diffPickMask = document.getElementById("diffPickMask");
const mmDiffBadge  = document.getElementById("mmDiffBadge");
const mmNote       = document.getElementById("mmNote");
const mmRecords    = document.getElementById("mmRecords");

const btnMMStart    = document.getElementById("btnMMStart");
const btnMMOpenDiff = document.getElementById("btnMMOpenDiff");
const btnMMResetRec = document.getElementById("btnMMResetRec");

const btnDiffPickEasy   = document.getElementById("btnDiffPickEasy");
const btnDiffPickNormal = document.getElementById("btnDiffPickNormal");
const btnDiffPickHard   = document.getElementById("btnDiffPickHard");
const btnDiffPickBack   = document.getElementById("btnDiffPickBack");
const btnDiffPickClose  = document.getElementById("btnDiffPickClose");

let __pendingDiffPick = null;

function setMainMenuOpen(on){
  if (!mainMenuMask) return;
  mainMenuMask.classList.toggle("hidden", !on);
  if (on) {
    try { updateMainMenuUI(true); } catch(e){}
  }
}

function setDiffPickOpen(on){
  if (!diffPickMask) return;
  diffPickMask.classList.toggle("hidden", !on);
  if (on) {
    // ê¸°ë³¸ ì„ íƒ: í˜„ì¬ ë‚œì´ë„
    __pendingDiffPick = (state && state.diffId) ? String(state.diffId) : "normal";
    try { updateDiffPickButtons(); } catch(e){}
  }
}

function updateDiffPickButtons(){
  const k = (__pendingDiffPick && typeof __pendingDiffPick === "string") ? __pendingDiffPick : "normal";
  if (btnDiffPickEasy)   btnDiffPickEasy.style.outline   = (k==="easy")   ? "2px solid rgba(255,255,255,.85)" : "none";
  if (btnDiffPickNormal) btnDiffPickNormal.style.outline = (k==="normal") ? "2px solid rgba(255,255,255,.85)" : "none";
  if (btnDiffPickHard)   btnDiffPickHard.style.outline   = (k==="hard")   ? "2px solid rgba(255,255,255,.85)" : "none";
}

function mainMenuRecordText(){
  if (!__records) __records = loadRecords();
  const best = __records.bestRun;
  const last = __records.lastRun;
  const lines = [];
  if (best) lines.push(`ìµœê³  ê¸°ë¡: WAVE ${best.wave}`);
  else lines.push("ìµœê³  ê¸°ë¡: ì—†ìŒ");
  if (last) lines.push(`ì§ì „ ê¸°ë¡: WAVE ${last.wave} ${last.win ? "(ìŠ¹ë¦¬)" : "(ì‹¤íŒ¨)"}`);
  else lines.push("ì§ì „ ê¸°ë¡: ì—†ìŒ");
  return lines.join("<br>");
}

function updateMainMenuUI(force=false){
  if (!mainMenuMask || mainMenuMask.classList.contains("hidden")) return;
  const d = getDiff();
  const key = d.key || (state && state.diffId) || "normal";
  const label = (key==="easy") ? "EASY" : (key==="hard") ? "HARD" : "NORMAL";
  if (mmDiffBadge) mmDiffBadge.textContent = label;
  if (mmNote) mmNote.textContent = `ë‚œì´ë„: ${d.name} Â· (1ì›¨ì´ë¸Œ ì‹œì‘ í›„ ë³€ê²½ ë¶ˆê°€)`;
  if (mmRecords) {
    try { mmRecords.innerHTML = mainMenuRecordText(); } catch(e){}
  }
}

if (btnMMStart) btnMMStart.onclick = ()=>{
  ensureAudio(); try { SFX.play("click"); } catch(e){}
  setMainMenuOpen(false);
  // ì‹œì‘í•˜ìë§ˆì ë°”ë¡œ ì›¨ì´ë¸ŒëŠ” ì•„ë‹ˆê³ , ê¸°ì¡´ëŒ€ë¡œ ë¹Œë“œ í™”ë©´ ìœ ì§€
  try { refreshUI(); } catch(e){}
};

if (btnMMOpenDiff) btnMMOpenDiff.onclick = ()=>{
  ensureAudio(); try { SFX.play("click"); } catch(e){}
  setMainMenuOpen(false);
  setDiffPickOpen(true);
};

if (btnMMResetRec) btnMMResetRec.onclick = ()=>{
  ensureAudio(); try { SFX.play("click"); } catch(e){}
  try {
    __records = { bestRun:null, lastRun:null };
    saveRecords();
    renderRecords(true);
    updateMainMenuUI(true);
    if (typeof setMsg === "function") setMsg("ëŸ° ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.", 2.0);
  } catch(e){}
};

if (btnDiffPickEasy) btnDiffPickEasy.onclick = ()=>{ ensureAudio(); try{SFX.play("click");}catch(e){} __pendingDiffPick="easy"; updateDiffPickButtons(); };
if (btnDiffPickNormal) btnDiffPickNormal.onclick = ()=>{ ensureAudio(); try{SFX.play("click");}catch(e){} __pendingDiffPick="normal"; updateDiffPickButtons(); };
if (btnDiffPickHard) btnDiffPickHard.onclick = ()=>{ ensureAudio(); try{SFX.play("click");}catch(e){} __pendingDiffPick="hard"; updateDiffPickButtons(); };

if (btnDiffPickBack) btnDiffPickBack.onclick = ()=>{
  ensureAudio(); try{SFX.play("click");}catch(e){}
  setDiffPickOpen(false);
  setMainMenuOpen(true);
};

if (btnDiffPickClose) btnDiffPickClose.onclick = ()=>{
  ensureAudio(); try{SFX.play("click");}catch(e){}
  const k = (__pendingDiffPick && typeof __pendingDiffPick === "string") ? __pendingDiffPick : "normal";
  setDiffPickOpen(false);
  // ì ìš©
  setDiffPreset(k);
  // ì„ íƒ í›„ ë©”ì¸ í™”ë©´ ë³µê·€
  setMainMenuOpen(true);
};

// ë°”ê¹¥ í´ë¦­ìœ¼ë¡œ ë‹«ê¸°
if (diffPickMask) diffPickMask.addEventListener("click", (e)=>{
  if (e.target === diffPickMask){
    ensureAudio(); try{SFX.play("click");}catch(e2){}
    setDiffPickOpen(false);
    setMainMenuOpen(true);
  }
});
if (mainMenuMask) mainMenuMask.addEventListener("click", (e)=>{
  // ë©”ì¸ë©”ë‰´ëŠ” ë°”ê¹¥ í´ë¦­ ë¬´ì‹œ(ì‹¤ìˆ˜ ë°©ì§€)
});





// ===== Risk Contracts (wave pre-choice) =====
const CONTRACTS = {
  none:   { id:"none",   name:"ì„ íƒ ì•ˆí•¨",       hpMul:1,    spdMul:1,    shieldMul:1,    grantShieldMul:0,    rewardMul:1.00, desc:"ê³„ì•½ ì—†ì´ ì§„í–‰í•©ë‹ˆë‹¤." },
  hp:     { id:"hp",     name:"ì  ì²´ë ¥ ê°•í™”",   hpMul:1.25, spdMul:1,    shieldMul:1,    grantShieldMul:0,    rewardMul:1.30, desc:"ì  HP +25%" },
  spd:    { id:"spd",    name:"ì  ì†ë„ ê°•í™”",   hpMul:1,    spdMul:1.18, shieldMul:1,    grantShieldMul:0,    rewardMul:1.25, desc:"ì  ì†ë„ +18%" },
  shield: { id:"shield", name:"ì  ë³´í˜¸ë§‰ ê°•í™”", hpMul:1,    spdMul:1,    shieldMul:1.35, grantShieldMul:0.25, rewardMul:1.30, desc:"ë³´í˜¸ë§‰ +35% (ì—†ëŠ” ì ì€ HPì˜ 25%ë§Œí¼ ì‹¤ë“œ ë¶€ì—¬)" },
};

function contractById(id){
  return CONTRACTS[id] || CONTRACTS.none;
}

function setContractPick(id){
  // ì›¨ì´ë¸Œ ì¤‘/ì‹¤íŒ¨/ìŠ¹ë¦¬ í™”ë©´ì—ì„œëŠ” ë³€ê²½ ë¶ˆê°€
  if (state.phase === "wave" || state.phase === "fail" || state.phase === "win") return;
  if ((state.wave|0) === FINAL_WAVE) id = "none";
  state.contractPick = (id in CONTRACTS) ? id : "none";
  try { refreshContractUI(); } catch(e) {}
}

function applyContractForWave(){
  let pick = state.contractPick || "none";
  if ((state.wave|0) === FINAL_WAVE) pick = "none";
  state.contractActive = pick;
  const c = contractById(pick);

  // resetMods() ì´í›„ í˜¸ì¶œëœë‹¤ê³  ê°€ì •
  state.mods.enemyHpMul *= (c.hpMul||1);
  state.mods.enemySpdMul *= (c.spdMul||1);
  state.mods.enemyShieldMul *= (c.shieldMul||1);
  state.mods.enemyGrantShieldMul = Math.max(state.mods.enemyGrantShieldMul||0, (c.grantShieldMul||0));
  state.mods.rewardMul *= (c.rewardMul||1);

  if (pick !== "none") {
    try {
      fxText(`ê³„ì•½: ${c.name} (ë³´ìƒÃ—${(c.rewardMul||1).toFixed(2)})`, CORE_POS.x, CORE_POS.y - 120, "#fbbf24");
      fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+12, CORE_RADIUS+120, "#fbbf24");
    } catch(e) {}
  }
}

function refreshContractUI(){
  if (!uiContractHint && !uiContractMul) return;

  const pick = state.contractPick || "none";
  const active = state.contractActive || "none";
  const isFinal = ((state.wave|0) === FINAL_WAVE);
  const locked = (state.phase === "wave" || state.phase === "fail" || state.phase === "win" || isFinal);

  const cPick = contractById(pick);
  const cAct  = contractById(active);

  if (uiContractMul) {
    const mul = (locked ? (cAct.rewardMul||1) : (cPick.rewardMul||1));
    uiContractMul.textContent = `Ã—${mul.toFixed(2)}`;
  }

  // ë²„íŠ¼ í•˜ì´ë¼ì´íŠ¸/ë¹„í™œì„±
  const setBtn = (btn, on)=>{ if (!btn) return; btn.classList.toggle("active", !!on); btn.disabled = !!locked; };
  setBtn(btnContractNone, pick==="none");
  setBtn(btnContractHP,   pick==="hp");
  setBtn(btnContractSPD,  pick==="spd");
  setBtn(btnContractSH,   pick==="shield");

  if (uiContractHint) {
    if (isFinal) {
      uiContractHint.innerHTML = "ìµœì¢… ì›¨ì´ë¸Œì—ëŠ” ìœ„í—˜ ê³„ì•½ì´ ì ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
    } else if (state.phase === "wave") {
      uiContractHint.innerHTML = `ì´ë²ˆ ì›¨ì´ë¸Œ: <b>${cAct.name}</b> â€” ${cAct.desc} / ë³´ìƒ <b>Ã—${(cAct.rewardMul||1).toFixed(2)}</b>`;
    } else {
      uiContractHint.innerHTML = `ì„ íƒ: <b>${cPick.name}</b> â€” ${cPick.desc} / ë³´ìƒ <b>Ã—${(cPick.rewardMul||1).toFixed(2)}</b>`;
    }
  }
}

// ë²„íŠ¼ ë°”ì¸ë”©
if (btnContractNone) btnContractNone.onclick = ()=>{ try{ ensureAudio(); }catch(e){} try{ SFX.play("click"); }catch(e){} setContractPick("none"); };
if (btnContractHP)   btnContractHP.onclick   = ()=>{ try{ ensureAudio(); }catch(e){} try{ SFX.play("click"); }catch(e){} setContractPick("hp"); };
if (btnContractSPD)  btnContractSPD.onclick  = ()=>{ try{ ensureAudio(); }catch(e){} try{ SFX.play("click"); }catch(e){} setContractPick("spd"); };
if (btnContractSH)   btnContractSH.onclick   = ()=>{ try{ ensureAudio(); }catch(e){} try{ SFX.play("click"); }catch(e){} setContractPick("shield"); };
// ===== End Risk Contracts =====
// ===== Wave Missions (Objectives) =====
const uiMission = document.getElementById("uiMission");
const uiMissionReward = document.getElementById("uiMissionReward");

// ë¯¸ì…˜ ëª©í‘œëŠ” "ë¶ˆê°€ëŠ¥í•œ ëª©í‘œ"ê°€ ëœ¨ì§€ ì•Šê²Œ, ì›¨ì´ë¸Œ/í…Œë§ˆì— ë§ì¶° ëª©í‘œì¹˜ë¥¼ ë™ì ìœ¼ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤.
// ë˜í•œ, ë‹¤ìŒ ì›¨ì´ë¸Œì˜ ëª©í‘œë¥¼ ë¯¸ë¦¬ ë½‘ì•„(build/clearì—ì„œ) í‘œì‹œí•˜ê³ , ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ í™•ì •ë˜ë„ë¡ í•©ë‹ˆë‹¤.

function buildEnemyPoolForWave(w, spec){
  // pickEnemyId()ì™€ ë™ì¼í•œ í’€/ê°€ì¤‘ì¹˜ë¥¼ (í™•ë¥  ê³„ì‚°ìš©ìœ¼ë¡œ) ë³µì œ
  const pool = [];
  pool.push(["grunt", 60]);

  if (w >= 2) pool.push(["shooter", 18]);
  if (w >= 3) pool.push(["shieldbreaker", 16]);
  if (w >= 4) pool.push(["piercer", 16]);
  if (w >= 2) pool.push(["runner", 14]);
  if (w >= 2) pool.push(["shooter", 18]);
  if (w >= 3) pool.push(["shieldbreaker", 16]);
  if (w >= 4) pool.push(["piercer", 16]);
  if (w >= 6) pool.push(["bruiser", 12]);
  if (w >= 6) pool.push(["bomber", 14]);
  if (w >= 8) pool.push(["disruptor", 12]);
  if (w >= 7) pool.push(["supporter", 12]);

  // boss wave ë³´ì •ì€ ì—¬ê¸°ì„œëŠ” ë¶ˆí•„ìš”(ë¯¸ì…˜ì€ ë³´ìŠ¤ ì›¨ì´ë¸Œì— ì•ˆ ëœ¸)ì´ë‚˜,
  // í–¥í›„ ë³€ê²½ì— ëŒ€ë¹„í•´ ë™ì¼í•˜ê²Œ ìœ ì§€
  if (spec && spec.isBoss) {
    for (let i=0;i<pool.length;i++) pool[i][1] *= (pool[i][0]==="grunt" ? 0.55 : 1.25);
  }

  // theme wave ë³´ì •(í™•ë¥  ê³„ì‚°ìš©)
  const tk = (spec && spec.themeKey) ? spec.themeKey : "";
  if (tk === "rush") {
    for (let i=0;i<pool.length;i++){
      const id = pool[i][0];
      if (id==="runner") pool[i][1] *= 2.4;
      else if (id==="piercer") pool[i][1] *= 1.35;
      else if (id==="shooter") pool[i][1] *= 0.75;
      else if (id==="bruiser") pool[i][1] *= 0.55;
    }
  } else if (tk === "siege") {
    for (let i=0;i<pool.length;i++){
      const id = pool[i][0];
      if (id==="bruiser") pool[i][1] *= 2.3;
      else if (id==="grunt") pool[i][1] *= 0.85;
      else if (id==="runner") pool[i][1] *= 0.55;
    }
  } else if (tk === "bomb") {
    for (let i=0;i<pool.length;i++){
      const id = pool[i][0];
      if (id==="bomber") pool[i][1] *= 2.1;
      else if (id==="shieldbreaker") pool[i][1] *= 1.45;
    }
  } else if (tk === "swarm") {
    for (let i=0;i<pool.length;i++){
      const id = pool[i][0];
      if (id==="grunt") pool[i][1] *= 1.55;
      else if (id==="runner") pool[i][1] *= 2.6;
      else if (id==="bruiser") pool[i][1] *= 0.45;
      else if (id==="shooter") pool[i][1] *= 0.75;
    }
  } else if (tk === "sniper") {
    for (let i=0;i<pool.length;i++){
      const id = pool[i][0];
      if (id==="shooter") pool[i][1] *= 2.35;
      else if (id==="piercer") pool[i][1] *= 1.65;
      else if (id==="bruiser") pool[i][1] *= 0.70;
      else if (id==="runner") pool[i][1] *= 0.70;
    }
  }

  return pool;
}

function poolProbFor(pool, id){
  let sum = 0, wgt = 0;
  for (const [pid, pw] of pool) { sum += pw; if (pid === id) wgt += pw; }
  return (sum > 0) ? (wgt / sum) : 0;
}

function estimateExpectedCount(w, spec, enemyId){
  const pool = buildEnemyPoolForWave(w, spec);
  const p = poolProbFor(pool, enemyId);
  const c = (spec && (spec.count|0) > 0) ? (spec.count|0) : 0;
  return c * p;
}

function calcRunnerTarget(w, spec){
  const exp = estimateExpectedCount(w, spec, "runner");
  // ë¶„ì‚°(ëœë¤ ìŠ¤í°)ì„ ê³ ë ¤í•´ ê¸°ëŒ€ê°’ë³´ë‹¤ ì•½ê°„ ë‚®ê²Œ ì„¤ì •
  let t = Math.round(exp * 0.75);
  // í…Œë§ˆ ì›¨ì´ë¸ŒëŠ” ëŸ¬ë„ˆ ë¹„ì¤‘ì´ ë†’ìœ¼ë¯€ë¡œ ì•½ê°„ ìƒí–¥
  if (spec && (spec.themeKey === "rush" || spec.themeKey === "swarm")) {
    t = Math.round(exp * 0.78);
  }
  const min = (w < 8) ? 2 : 3;
  t = clamp(t, min, 12);
  // ì•ˆì „ì¥ì¹˜: ì „ì²´ ìŠ¤í° ëŒ€ë¹„ ë„ˆë¬´ í¬ì§€ ì•Šê²Œ
  const cap = Math.max(min, Math.floor(((spec && spec.count) ? spec.count : 0) * 0.45));
  t = clamp(t, min, Math.max(min, Math.min(12, cap)));
  return t;
}

function calcTurretLimit(w){
  // í›„ë°˜ìœ¼ë¡œ ê°ˆìˆ˜ë¡(ë‚œì´ë„ ìƒìŠ¹) ì œí•œì„ ì¡°ê¸ˆ ì™„í™”
  // 3~9:2, 10~16:3, 17~23:4, 24+:5
  const ww = (w|0);
  const lim = 2 + Math.floor(Math.max(0, ww - 3) / 7);
  return clamp(lim, 2, 5);
}

const MISSION_DEFS = [
  {
    id:"runner", name:"ì§ˆì£¼ë³‘ ì‚¬ëƒ¥", kind:"kill_runner",
    canOffer:(w, spec)=>{
      if (!spec || spec.isBoss || spec.isFinal) return false;
      if ((w|0) < 3) return false;
      // í‰ê· ì ìœ¼ë¡œ 2ë§ˆë¦¬ ì´ìƒì€ ë‚˜ì˜¬ ì›¨ì´ë¸Œì—ì„œë§Œ
      const exp = estimateExpectedCount(w, spec, "runner");
      return exp >= 2.2;
    },
    make:(w, spec)=>{
      const target = calcRunnerTarget(w, spec);
      return { target, desc:`ì´ ì›¨ì´ë¸Œì— ì§ˆì£¼ë³‘ ${target}ë§ˆë¦¬ ì²˜ì¹˜` };
    },
    reward:(w, m)=> Math.floor(18 + (w|0)*3 + ((m && m.target)|0)*3),
  },
  {
    id:"nodmg", name:"ì½”ì–´ ë¬´í”¼í•´", kind:"no_hp_damage",
    canOffer:(w, spec)=>{
      if (!spec || spec.isBoss || spec.isFinal) return false;
      return (w|0) >= 3;
    },
    make:(w, spec)=>({ desc:"ì´ ì›¨ì´ë¸Œì— ì½”ì–´ HP í”¼í•´ ì—†ì´ ë²„í‹°ê¸°" }),
    reward:(w)=> Math.floor(30 + (w|0)*5),
  },
  {
    id:"limit", name:"ì†Œìˆ˜ ì •ì˜ˆ", kind:"turret_limit",
    canOffer:(w, spec)=>{
      if (!spec || spec.isBoss || spec.isFinal) return false;
      return (w|0) >= 3;
    },
    make:(w, spec)=>{
      const limit = calcTurretLimit(w);
      return { limit, desc:`ì´ ì›¨ì´ë¸Œ ë™ì•ˆ í¬íƒ‘ ${limit}ê°œ ì´í•˜ë¡œ ë²„í‹°ê¸°` };
    },
    reward:(w, m)=>{
      const lim = (m && m.limit) ? (m.limit|0) : 2;
      const hardBonus = Math.max(0, (4 - lim)) * 9;
      return Math.floor(26 + (w|0)*4 + hardBonus);
    },
  },
];

function shouldRollMission(w){
  const ww = (w|0);
  if (ww === FINAL_WAVE) return false;
  if (ww < 3) return false;
  const spec = (typeof waveSpec === 'function') ? waveSpec(ww) : null;
  if (spec && (spec.isBoss || spec.isFinal)) return false;
  // ì´ˆë°˜ì€ ì•½ê°„ ë‚®ê²Œ
  const p = (ww < 8) ? 0.45 : 0.55;
  return Math.random() < p;
}

function pickMissionDef(w, spec){
  let defs = MISSION_DEFS.slice();
  defs = defs.filter(d=>{
    try {
      return d && (!d.canOffer || d.canOffer(w, spec));
    } catch(e) {
      return false;
    }
  });
  if (!defs.length) return null;

  // ì•½í•œ ê°€ì¤‘ì¹˜: ëŸ¬ë„ˆ ë¯¸ì…˜ì€ ëŸ¬ì‹œ/ìŠ¤ì›œì—ì„œ ì¡°ê¸ˆ ë” ìì£¼
  const weights = defs.map(d=>{
    if (!d) return 1.0;
    if (d.id === 'runner') {
      const tk = spec ? spec.themeKey : '';
      return (tk === 'rush' || tk === 'swarm') ? 1.15 : 0.85;
    }
    return 1.0;
  });
  let sum = 0; for (const x of weights) sum += x;
  let r = Math.random() * sum;
  for (let i=0;i<defs.length;i++){
    r -= weights[i];
    if (r <= 0) return defs[i];
  }
  return defs[defs.length-1];
}

function rollMissionForWave(w){
  const ww = (w|0);
  if (!shouldRollMission(ww)) return null;
  const spec = (typeof waveSpec === 'function') ? waveSpec(ww) : null;
  const def = pickMissionDef(ww, spec);
  if (!def) return null;

  const extra = (def.make ? def.make(ww, spec) : {}) || {};

  const m = {
    id:def.id,
    name:def.name,
    kind:def.kind,
    desc: extra.desc || def.desc || "",
    wave: ww,
    startedAt: 0,
    failed:false,
    done:false,
    succeeded:false,
    rewardBase: 0,
    rewardGiven: 0,
    // progress
    target: (extra.target|0) || 0,
    progress: 0,
    limit: (extra.limit|0) || 0,
    maxTurrets: 0,
  };

  m.rewardBase = (def.reward ? def.reward(ww, m) : 0);
  return m;
}

function prepareNextMissionForWave(w){
  const ww = (w|0);
  if (ww === FINAL_WAVE) { state.nextMission = null; return; }
  const spec = (typeof waveSpec === 'function') ? waveSpec(ww) : null;
  if (spec && (spec.isBoss || spec.isFinal)) { state.nextMission = null; return; }
  state.nextMission = rollMissionForWave(ww);
}

function startMissionForWave(w){
  const ww = (w|0);
  if (ww === FINAL_WAVE) { state.mission = null; state.nextMission = null; return; }

  const spec = (typeof waveSpec === 'function') ? waveSpec(ww) : null;
  if (spec && (spec.isBoss || spec.isFinal)) {
    state.mission = null;
    state.nextMission = null;
    return;
  }

  // ë¯¸ë¦¬ ë½‘ì•„ë‘”(nextMission) ëª©í‘œê°€ ìˆìœ¼ë©´ ìŠ¹ê²©
  let m = null;
  if (state.nextMission && ((state.nextMission.wave|0) === ww)) {
    m = state.nextMission;
  } else {
    m = rollMissionForWave(ww);
  }

  state.mission = m;
  state.nextMission = null;

  const mm = state.mission;
  if (mm) {
    mm.startedAt = gameSec();
    // ì†Œìˆ˜ ì •ì˜ˆëŠ” ì›¨ì´ë¸Œ ì‹œì‘ ì‹œì ì˜ í¬íƒ‘ ìˆ˜ë¥¼ ë°”ë¡œ ë°˜ì˜
    if (mm.kind === "turret_limit") {
      const n = (state.turrets ? state.turrets.length : 0);
      mm.maxTurrets = n;
      if (n > mm.limit) mm.failed = true;
    }
    try { fxText(`ëª©í‘œ: ${mm.name}`, CORE_POS.x, CORE_POS.y - 140, "#fbbf24"); } catch(e) {}
  }
}

function missionTick(dt){
  const m = state.mission;
  if (!m || m.done) return;
  if (state.phase !== "wave") return;
  if (m.kind === "turret_limit") {
    const n = (state.turrets ? state.turrets.length : 0);
    if (n > m.maxTurrets) m.maxTurrets = n;
    if (m.maxTurrets > m.limit) m.failed = true;
  }
}

function onMissionEnemyKill(e){
  const m = state.mission;
  if (!m || m.done) return;
  if (state.phase !== "wave") return;
  if (m.kind === "kill_runner") {
    if (e && (e.kind === "runner")) {
      m.progress = Math.min(m.target, (m.progress|0) + 1);
    }
  }
}

function onMissionCoreHpDamage(hpLoss){
  const m = state.mission;
  if (!m || m.done) return;
  if (state.phase !== "wave") return;
  if (m.kind === "no_hp_damage" && hpLoss > 0.001) {
    m.failed = true;
  }
}

function missionSucceeded(m){
  if (!m || m.failed) return false;
  if (m.kind === "kill_runner") return (m.progress|0) >= (m.target|0);
  if (m.kind === "turret_limit") return (m.maxTurrets|0) <= (m.limit|0);
  if (m.kind === "no_hp_damage") return true;
  return false;
}

function finalizeMissionOnWaveClear(clearedWave){
  const m = state.mission;
  if (!m || m.done) return;
  if ((m.wave|0) !== (clearedWave|0)) return;

  const ok = missionSucceeded(m);
  m.done = true;
  m.succeeded = !!ok;

  if (ok) {
    const diff = state.diff || DIFF_PRESETS.normal;


    const bonus = Math.floor((m.rewardBase||0) * (state.mods.rewardMul||1) * (diff.rewardMul||1));
    m.rewardGiven = bonus;
    state.crystals += bonus;
    try {
      fxText(`ëª©í‘œ ë‹¬ì„±! +${bonus}`, CORE_POS.x, CORE_POS.y - 92, "#a7f3d0");
      fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+150, "#a7f3d0");
    } catch(e) {}
  } else {
    try {
      fxText("ëª©í‘œ ì‹¤íŒ¨", CORE_POS.x, CORE_POS.y - 92, "#fca5a5");
    } catch(e) {}
  }
}

function missionRewardEstimate(m){
  if (!m) return 0;
  const diff = state.diff || DIFF_PRESETS.normal;
  return Math.floor((m.rewardBase||0) * (state.mods.rewardMul||1) * (diff.rewardMul||1));
}

function missionHtml(m, inWave, label){
  if (!m) return "";

  let line = label ? `<span style="opacity:0.75">${label}</span> ` : "";
  line += `<b>${m.name}</b> â€” ${m.desc}`;

  if (m.kind === "kill_runner") {
    if (inWave) line += `<br>ì§„í–‰: <b>${m.progress||0}/${m.target||0}</b>`;
    else line += `<br>ëª©í‘œ: <b>${m.target||0}</b>ë§ˆë¦¬`;
  } else if (m.kind === "turret_limit") {
    const cur = (state.turrets ? state.turrets.length : 0);
    if (inWave) line += `<br>í˜„ì¬/ìµœëŒ€ í¬íƒ‘: <b>${cur}/${m.maxTurrets||0}</b> (ì œí•œ ${m.limit})`;
    else line += `<br>í˜„ì¬ í¬íƒ‘: <b>${cur}</b> (ì œí•œ ${m.limit})`;
  } else if (m.kind === "no_hp_damage") {
    if (inWave) line += `<br>ìƒíƒœ: <b>${m.failed ? "ì‹¤íŒ¨" : "ìœ ì§€ ì¤‘"}</b>`;
    else line += `<br>ì¡°ê±´: <b>ì½”ì–´ HP í”¼í•´ 0</b>`;
  }

  if (m.done) {
    line += `<br><span style="color:${m.succeeded ? '#a7f3d0' : '#fca5a5'}; font-weight:800">${m.succeeded ? 'ì„±ê³µ' : 'ì‹¤íŒ¨'}</span>`;
  } else if (m.failed) {
    line += `<br><span style="color:#fca5a5; font-weight:800">ì‹¤íŒ¨</span>`;
  }

  return line;
}

function refreshMissionUI(){
  if (!uiMission) return;

  const inWave = (state.phase === "wave");
  const m = state.mission;
  const nm = state.nextMission;

  // reward badge: ì „íˆ¬ ì¤‘ì—ëŠ” í˜„ì¬ ë¯¸ì…˜, ê·¸ ì™¸ì—ëŠ” ë‹¤ìŒ ë¯¸ì…˜(ìˆìœ¼ë©´)
  if (uiMissionReward) {
    let shown = 0;
    let op = 0.55;
    if (inWave) {
      if (m) {
        shown = m.done ? (m.rewardGiven||0) : missionRewardEstimate(m);
        op = m.done ? (m.succeeded ? 1.0 : 0.75) : 1.0;
      }
    } else {
      if (nm) {
        shown = missionRewardEstimate(nm);
        op = 1.0;
      }
    }
    uiMissionReward.textContent = `+${shown|0}`;
    uiMissionReward.style.opacity = String(op);
  }

  // ë³¸ë¬¸
  if (inWave) {
    if (!m) {
      uiMission.innerHTML = "ëª©í‘œ: ì—†ìŒ";
      return;
    }
    uiMission.innerHTML = missionHtml(m, true, "ëª©í‘œ:");
    return;
  }

  // build/clear/finalprep: ë‹¤ìŒ ë¯¸ì…˜ì„ ë¨¼ì € ë³´ì—¬ì£¼ê³ , ì§ì „ ë¯¸ì…˜ ê²°ê³¼ëŠ” ì•„ë˜ì— ì‘ê²Œ í‘œì‹œ
  let out = "";
  if (nm) {
    out = missionHtml(nm, false, "ë‹¤ìŒ ëª©í‘œ:");
  } else {
    out = "ë‹¤ìŒ ì›¨ì´ë¸Œ ëª©í‘œ: ì—†ìŒ";
  }

  if (m && m.done) {
    const tag = m.succeeded ? "ì„±ê³µ" : "ì‹¤íŒ¨";
    out += `<div style="margin-top:6px; opacity:0.70">ì§€ë‚œ ëª©í‘œ: <b>${tag}</b> â€” ${m.name}</div>`;
  }

  uiMission.innerHTML = out;
}
// ===== End Wave Missions =====



    const CORE_PASSIVES = {
    rebuild: {
      id:"rebuild", name:"ì¬ê±´ ì½”ì–´", colorClass:"passiveBlue",
      desc:[
        "ì €ì²´ë ¥(HP 70%â†“)ë¶€í„° í”¼í•´ê°ì†Œê°€ ë¶™ìŠµë‹ˆë‹¤. (10%ì—ì„œ ìµœëŒ€ -12%)",
        "ì‹¤ë“œê°€ ê¹¨ì§€ë©´ ì§§ì€ ì‹œê°„ â€˜ê¸´ê¸‰ ë³´ê°•â€™(í”¼í•´ -38%)ì´ ë°œë™í•©ë‹ˆë‹¤. (ì¿¨ 7ì´ˆ)",
        "ë³´í˜¸ë§‰ ì¬ìƒ +15% (ìµœì¢…ì „ ì¶”ê°€ +10%)",
        "ì €ì²´ë ¥ì¼ìˆ˜ë¡ ë°©ì–´/ë³´í˜¸ë§‰ë°©ì–´ê°€ ì¦ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ ë°©ì–´ +15 / ë³´í˜¸ë§‰ë°©ì–´ +7.5)",
        "HP ìë™ ìˆ˜ë¦¬ê°€ ê°•í™”ë©ë‹ˆë‹¤. (ì €ì²´ë ¥ì¼ìˆ˜ë¡ íšŒë³µëŸ‰â†‘ / ìµœì¢…ì „ ë”œë ˆì´â†“)"
      ]
    },
    resonance: {
      id:"resonance", name:"ê³µëª… ë°˜ê²© ì½”ì–´", colorClass:"passiveOrange",
      desc:[
        "ë³´í˜¸ë§‰ì´ í¡ìˆ˜í•œ í”¼í•´ë¡œ â€˜ê³µëª… ê²Œì´ì§€â€™ê°€ ì°¨ì˜¤ë¦…ë‹ˆë‹¤.",
        "ê²Œì´ì§€ì— ë”°ë¼ í¬íƒ‘ í”¼í•´/ê³µì†ì´ ì¦ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ í”¼í•´ +30%, ê³µì† +18%)",
        "ê²Œì´ì§€ 100%ê°€ ë˜ë©´ ìµœê·¼ í¡ìˆ˜ëŸ‰ ê¸°ë°˜ì˜ â€˜ê³µëª… ë°©ì¶œâ€™ì´ ìë™ ë°œë™í•©ë‹ˆë‹¤.",
        "ë°©ì¶œ ì‹œ ì£¼ë³€ í™•ì‚° í”¼í•´ + â€˜ë…¸ì¶œâ€™(ë°›ëŠ” í”¼í•´â†‘) ë””ë²„í”„ê°€ ê±¸ë¦½ë‹ˆë‹¤.",
	        "í”¼ê²© í›„ ì¦‰ì‹œ ë°˜ê²©í•˜ëŠ” íƒ€ì…ì´ ì•„ë‹ˆë¼, ëˆ„ì â†’ë°©ì¶œí˜• íŒ¨ì‹œë¸Œì…ë‹ˆë‹¤."
      ]
    },
    overload: {
      id:"overload", name:"ì„ê³„ ê³¼ë¶€í•˜", colorClass:"passiveRed",
      desc:[
        "HP 30%â†“ ì§„ì… ì‹œ(ë‚´ë ¤ì˜¬ ë•Œ) ì‡¼í¬ì›¨ì´ë¸Œ(ë„‰ë°±+ë‘”í™” 0.6s) + ê³¼ë¶€í•˜ ë²„ìŠ¤íŠ¸ 6s ë°œë™ (ì¿¨ 18s)",
        "í¬íƒ‘ ì ì¤‘ ì‹œ í‘œì‹(ìµœëŒ€ 5ì¤‘ì²©/4s ê°±ì‹ ): ì¼ë°˜/ì—˜ë¦¬íŠ¸ +3%pÃ—ì¤‘ì²©, ë³´ìŠ¤/ìµœì¢…ë³´ìŠ¤ +1.5%pÃ—ì¤‘ì²©",
        "ë²„ìŠ¤íŠ¸ 6ì´ˆ: í¬íƒ‘ íƒ„ ê´€í†µ +1 / (ìŠ¤í”Œë˜ì‹œ ì—†ëŠ” í¬íƒ‘ì€) 90px ì†Œí˜• í­ë°œ(35%) ì¶”ê°€",
        "ë²„ìŠ¤íŠ¸ 6ì´ˆ: ìµœì¢…ë³´ìŠ¤ â€˜í¬íƒ‘ ë‚´ì„±â€™ 25% ë¶€ë¶„ ë¬´ì‹œ + íˆ¬ì‚¬ì²´ ë¶‰ì€ íŠ¸ë ˆì¼",
        "ì—°ê³„: HPâ‰¤40% ìˆ˜ë¦¬ ì‹œ ì£¼ë³€ ì (ë³´ìŠ¤ ìš°ì„ ) í‘œì‹ +2 / ë²„ìŠ¤íŠ¸ ë‚¨ì€ <2së©´ +2s ì—°ì¥(20s ICD) / ê¸´ê¸‰ ë³´í˜¸ë§‰ ì‚¬ìš© ì‹œ ë‹¤ìŒ ì¿¨ -6s(20s ICD)"
]
    },
    overdrive: {
      id:"overdrive", name:"ì½”ì–´ ì˜¤ë²„ë“œë¼ì´ë¸Œ", colorClass:"passivePurple",
      desc:[
        "ìˆ˜ì •íƒ‘ì´ ì§ì ‘ ì ì„ ê³µê²©í•©ë‹ˆë‹¤.",
        "HPê°€ ë‚®ì„ìˆ˜ë¡ ê³µê²© ì†ë„ì™€ ê³µê²©ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤.",
        "ì €ì²´ë ¥ êµ¬ê°„ì—ì„œ ë³´í˜¸ë§‰ ì¬ìƒì´ ì¦ê°€í•©ë‹ˆë‹¤.",
        "ì €ì²´ë ¥ì¼ìˆ˜ë¡ ë°›ëŠ” í”¼í•´ê°€ ì†Œí­ ê°ì†Œí•©ë‹ˆë‹¤.",
        "ì—ë„ˆì§€í¬ê°€ ê´‘ì—­ í”¼í•´(30%)ë¥¼ ì¶”ê°€ë¡œ ì…í™ë‹ˆë‹¤."
      ]
    }

    };


  // ===== Passive tooltip (HARD: 80% ë°˜ì˜) =====
  function _fmtFixed(v, d){
    d = (typeof d === 'number') ? d : 1;
    const p = Math.pow(10, d);
    const n = Math.round(v * p) / p;
    let out = n.toFixed(d);
    out = out.replace(/\.0+$/, '');
    out = out.replace(/(\.\d*[1-9])0+$/, '$1');
    return out;
  }
  function _fmtPct(v){
    const isInt = Math.abs(v - Math.round(v)) < 1e-9;
    return _fmtFixed(v, isInt ? 0 : 1);
  }
  function _fmtSec(v){
    return _fmtFixed(v, 1);
  }
  function corePassiveDescLines(pid){
    const d = (typeof CORE_PASSIVES === 'object' && CORE_PASSIVES) ? CORE_PASSIVES[pid] : null;
    if (!d) return [];
    const hard = (state && state.diffId === 'hard');
    if (!hard) return d.desc || [];
    const m = passiveHardMul(); // 0.8

    if (pid === 'rebuild'){
      return [
        `ì €ì²´ë ¥(HP 70%â†“)ë¶€í„° í”¼í•´ê°ì†Œê°€ ë¶™ìŠµë‹ˆë‹¤. (10%ì—ì„œ ìµœëŒ€ -${_fmtPct(12*m)}%)`,
        `ì‹¤ë“œê°€ ê¹¨ì§€ë©´ ì§§ì€ ì‹œê°„ â€˜ê¸´ê¸‰ ë³´ê°•â€™(í”¼í•´ -${_fmtPct(38*m)}%)ì´ ë°œë™í•©ë‹ˆë‹¤. (ì¿¨ 7ì´ˆ)`,
        `ë³´í˜¸ë§‰ ì¬ìƒ +${_fmtPct(15*m)}% (ìµœì¢…ì „ ì¶”ê°€ +${_fmtPct(10*m)}%)`,
        `ì €ì²´ë ¥ì¼ìˆ˜ë¡ ë°©ì–´/ë³´í˜¸ë§‰ë°©ì–´ê°€ ì¦ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ ë°©ì–´ +${_fmtFixed(15*m,1)} / ë³´í˜¸ë§‰ë°©ì–´ +${_fmtFixed(7.5*m,1)})`,
        `HP ìë™ ìˆ˜ë¦¬ê°€ ê°•í™”ë©ë‹ˆë‹¤. (ì €ì²´ë ¥ì¼ìˆ˜ë¡ íšŒë³µëŸ‰â†‘ / ìµœì¢…ì „ ë”œë ˆì´â†“)`
      ];
    }

    if (pid === 'resonance'){
      return [
        `ë³´í˜¸ë§‰ì´ í¡ìˆ˜í•œ í”¼í•´ë¡œ â€˜ê³µëª… ê²Œì´ì§€â€™ê°€ ì°¨ì˜¤ë¦…ë‹ˆë‹¤.`,
        `ê²Œì´ì§€ì— ë”°ë¼ í¬íƒ‘ í”¼í•´/ê³µì†ì´ ì¦ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ í”¼í•´ +${_fmtPct(30*m)}%, ê³µì† +${_fmtPct(18*m)}%)`,
        `ê²Œì´ì§€ 100%ê°€ ë˜ë©´ ìµœê·¼ í¡ìˆ˜ëŸ‰ ê¸°ë°˜ì˜ â€˜ê³µëª… ë°©ì¶œâ€™ì´ ìë™ ë°œë™í•©ë‹ˆë‹¤. (ë°©ì¶œ í”¼í•´ ê³„ìˆ˜ ${_fmtPct(105*m)}%)`,
        `ë°©ì¶œ ì‹œ ì£¼ë³€ í™•ì‚° í”¼í•´ + â€˜ë…¸ì¶œâ€™ ë””ë²„í”„ê°€ ê±¸ë¦½ë‹ˆë‹¤. (ë…¸ì¶œ: ì¼ë°˜ +${_fmtPct(24*m)}% / ë³´ìŠ¤ +${_fmtPct(13*m)}%)`,
        `í”¼ê²© í›„ ì¦‰ì‹œ ë°˜ê²©í•˜ëŠ” íƒ€ì…ì´ ì•„ë‹ˆë¼, ëˆ„ì â†’ë°©ì¶œí˜• íŒ¨ì‹œë¸Œì…ë‹ˆë‹¤.`
      ];
    }

    if (pid === 'overload'){
      // OVERLOAD_CFG ê°’ì€ ì‹¤í–‰ ì‹œì ì— ì´ë¯¸ ì •ì˜ë˜ì–´ ìˆìŒ
      const slowDur  = (OVERLOAD_CFG && OVERLOAD_CFG.shockSlowDur ? OVERLOAD_CFG.shockSlowDur : 0.6) * m;
      const burstDur = (OVERLOAD_CFG && OVERLOAD_CFG.burstDur ? OVERLOAD_CFG.burstDur : 6.0) * m;
      const markDur  = (OVERLOAD_CFG && OVERLOAD_CFG.markDur ? OVERLOAD_CFG.markDur : 4.0) * m;
      const markN    = (OVERLOAD_CFG && OVERLOAD_CFG.markBonus ? OVERLOAD_CFG.markBonus : 0.03) * 100 * m;
      const markB    = (OVERLOAD_CFG && OVERLOAD_CFG.markBonusBoss ? OVERLOAD_CFG.markBonusBoss : 0.015) * 100 * m;
      const miniR    = (OVERLOAD_CFG && OVERLOAD_CFG.miniSplashR ? OVERLOAD_CFG.miniSplashR : 90) * m;
      const miniMul  = (OVERLOAD_CFG && OVERLOAD_CFG.miniSplashMul ? OVERLOAD_CFG.miniSplashMul : 0.35) * 100 * m;
      const ignore   = (OVERLOAD_CFG && OVERLOAD_CFG.finalBossResistIgnore ? OVERLOAD_CFG.finalBossResistIgnore : 0.25) * 100 * m;
      const extend   = (OVERLOAD_CFG && OVERLOAD_CFG.extendAdd ? OVERLOAD_CFG.extendAdd : 2.0) * m;
      const cdReduce = (OVERLOAD_CFG && OVERLOAD_CFG.aegisCdReduce ? OVERLOAD_CFG.aegisCdReduce : 6.0) * m;

      return [
        `HP 30%â†“ ì§„ì… ì‹œ(ë‚´ë ¤ì˜¬ ë•Œ) ì‡¼í¬ì›¨ì´ë¸Œ(ë„‰ë°±+ë‘”í™” ${_fmtSec(slowDur)}s) + ê³¼ë¶€í•˜ ë²„ìŠ¤íŠ¸ ${_fmtSec(burstDur)}s ë°œë™ (ì¿¨ 18s)`,
        `í¬íƒ‘ ì ì¤‘ ì‹œ í‘œì‹(ìµœëŒ€ 5ì¤‘ì²©/${_fmtSec(markDur)}s ê°±ì‹ ): ì¼ë°˜/ì—˜ë¦¬íŠ¸ +${_fmtPct(markN)}%pÃ—ì¤‘ì²©, ë³´ìŠ¤/ìµœì¢…ë³´ìŠ¤ +${_fmtPct(markB)}%pÃ—ì¤‘ì²©`,
        `ë²„ìŠ¤íŠ¸ ${_fmtSec(burstDur)}ì´ˆ: í¬íƒ‘ íƒ„ ê´€í†µ +1 / (ìŠ¤í”Œë˜ì‹œ ì—†ëŠ” í¬íƒ‘ì€) ${Math.round(miniR)}px ì†Œí˜• í­ë°œ(${_fmtPct(miniMul)}%) ì¶”ê°€`,
        `ë²„ìŠ¤íŠ¸ ${_fmtSec(burstDur)}ì´ˆ: ìµœì¢…ë³´ìŠ¤ â€˜í¬íƒ‘ ë‚´ì„±â€™ ${_fmtPct(ignore)}% ë¶€ë¶„ ë¬´ì‹œ + íˆ¬ì‚¬ì²´ ë¶‰ì€ íŠ¸ë ˆì¼`,
        `ì—°ê³„: HPâ‰¤40% ìˆ˜ë¦¬ ì‹œ ì£¼ë³€ ì (ë³´ìŠ¤ ìš°ì„ ) í‘œì‹ +2 / ë²„ìŠ¤íŠ¸ ë‚¨ì€ <2së©´ +${_fmtSec(extend)}s ì—°ì¥(20s ICD) / ê¸´ê¸‰ ë³´í˜¸ë§‰ ì‚¬ìš© ì‹œ ë‹¤ìŒ ì¿¨ -${_fmtSec(cdReduce)}s(20s ICD)`
      ];
    }

    if (pid === 'overdrive'){
      return [
        `ìˆ˜ì •íƒ‘ì´ ì§ì ‘ ì ì„ ê³µê²©í•©ë‹ˆë‹¤.`,
        `HPê°€ ë‚®ì„ìˆ˜ë¡ ê³µê²© ì†ë„ì™€ ê³µê²©ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤.`,
        `ì €ì²´ë ¥ êµ¬ê°„ì—ì„œ ë³´í˜¸ë§‰ ì¬ìƒì´ ì¦ê°€í•©ë‹ˆë‹¤.`,
        `ì €ì²´ë ¥ì¼ìˆ˜ë¡ ë°›ëŠ” í”¼í•´ê°€ ì†Œí­ ê°ì†Œí•©ë‹ˆë‹¤.`,
        `ì—ë„ˆì§€í¬ê°€ ê´‘ì—­ í”¼í•´(${_fmtPct(30*m)}%)ë¥¼ ì¶”ê°€ë¡œ ì…í™ë‹ˆë‹¤.`
      ];
    }

    return d.desc || [];
  }

  // ---------- Resonance core (ê³µëª… ë°˜ê²©) ----------
  const RESONANCE_CFG = {
    // âœ… ê³µëª… ë°˜ê²©: íŒ¨ë„í‹° ì—†ì´(ì¿¨/ìƒí•œìœ¼ë¡œë§Œ) ìš´ì˜ + HP í”¼í•´ë„ ì¶©ì „(Bì•ˆ í™•ì¥)
    denomMul: 0.40,        // shieldMax * 0.40 ë¥¼ 100% ê¸°ì¤€ í¡ìˆ˜ëŸ‰ìœ¼ë¡œ(ì¡°ê¸ˆ ë” ì˜ ì°¸)
    hitCap: 30,            // 1íšŒ ì¶©ì „ ìƒí•œ(+%)
    secCap: 60,            // 1ì´ˆ ì¶©ì „ ìƒí•œ(+%)
    hpMul: 0.60,           // HP í”¼í•´ í™˜ì‚° ê³„ìˆ˜(ê³µëª… ì¶©ì „)
    decayWait: 4.0,        // í¡ìˆ˜ ê³µë°±(ì´ˆ)
    decayPerSec: 4.0,      // ê³µë°± ì´í›„ ì´ˆë‹¹ ê°ì†Œ(%p)
    dischargeCd: 2.5,      // ë°©ì¶œ ì¿¨(ì´ˆ)
    dischargeMul: 1.05,    // ìµœê·¼ í¡ìˆ˜ëŸ‰ì˜ 105%
    dischargeCapMul: 3.00  // ë°©ì¶œ í”¼í•´ ìƒí•œ(=shieldMax*3.0)
  };

  // ---------- Overload core (ì„ê³„ ê³¼ë¶€í•˜) ----------
  const OVERLOAD_CFG = {
    triggerHp: 0.30,
    shockR: 240,
    shockKnock: 78,
    shockSlowDur: 0.6,
    shockSlowMul: 0.55,
    burstDur: 6.0,
    burstCd: 18.0,

    markMax: 5,
    markDur: 4.0,
    markBonus: 0.03,       // normal/elite
    markBonusBoss: 0.015,  // boss/final

    burstPierceAdd: 1,
    miniSplashR: 90,
    miniSplashMul: 0.35,

    finalBossResistIgnore: 0.25,

    repairMarkHp: 0.40,
    repairMarkAdd: 2,
    repairMarkTargets: 4,

    extendIfRemainLt: 2.0,
    extendAdd: 2.0,
    extendIcd: 20.0,

    aegisCdReduce: 6.0,
    aegisIcd: 20.0,
  };


  function resonanceEnsure(){
    const c = state.core;
    if (typeof c.resGauge !== 'number') c.resGauge = 0;
    if (typeof c.resLastAbsorbAt !== 'number') c.resLastAbsorbAt = -999;
    if (typeof c.resChargeSecStartAt !== 'number') c.resChargeSecStartAt = gameSec();
    if (typeof c.resChargeThisSec !== 'number') c.resChargeThisSec = 0;
    if (typeof c.resDischargeReadyAt !== 'number') c.resDischargeReadyAt = 0;
    if (!Array.isArray(c.resAbsorbEvents)) c.resAbsorbEvents = [];
  }

  function resonanceReset(){
    const c = state.core;
    c.resGauge = 0;
    c.resLastAbsorbAt = -999;
    c.resChargeSecStartAt = gameSec();
    c.resChargeThisSec = 0;
    c.resDischargeReadyAt = 0;
    c.resAbsorbEvents = [];
  }

  function resonanceGauge01(){
    resonanceEnsure();
    return clamp((state.core.resGauge||0)/100, 0, 1);
  }

  function resonancePrune(){
    const c = state.core;
    if (!Array.isArray(c.resAbsorbEvents) || c.resAbsorbEvents.length === 0) return;
    const t = gameSec();
    // 5.7ì´ˆ ì´ìƒ ì§€ë‚œ ê¸°ë¡ ì œê±°(ì—¬ìœ )
    let cut = 0;
    while (cut < c.resAbsorbEvents.length && (t - c.resAbsorbEvents[cut].t) > 5.7) cut++;
    if (cut > 0) c.resAbsorbEvents.splice(0, cut);
  }

  function resonanceRecentAbsSum(){
    const c = state.core;
    if (!Array.isArray(c.resAbsorbEvents) || c.resAbsorbEvents.length === 0) return 0;
    const t = gameSec();
    let sum = 0;
    for (let i = c.resAbsorbEvents.length - 1; i >= 0; i--) {
      const a = c.resAbsorbEvents[i];
      if ((t - a.t) > 5.5) break;
      sum += (a.v||0);
    }
    return sum;
  }

  function resonanceOnAbsorb(absAmt){
    if (state.core.passiveId !== 'resonance') return;
    resonanceEnsure();
    const c = state.core;
    const t = gameSec();
    c.resAbsorbEvents.push({ t, v: absAmt });
    c.resLastAbsorbAt = t;

    // 1íšŒ/ì´ˆ ìƒí•œ í¬í•¨ ì¶©ì „
    if ((t - c.resChargeSecStartAt) >= 1.0) { c.resChargeSecStartAt = t; c.resChargeThisSec = 0; }
    const denom = Math.max(1, c.shieldMax * RESONANCE_CFG.denomMul);
    let add = (absAmt / denom) * 100;

    

    add *= passiveHardMul();
// âœ… íŒ¨ë„í‹° ì œê±°: ì¶©ì „ íš¨ìœ¨ 100% ê³ ì •

    add = Math.min(add, RESONANCE_CFG.hitCap);
    const room = RESONANCE_CFG.secCap - (c.resChargeThisSec||0);
    if (room <= 0) return;
    add = Math.min(add, room);
    if (add <= 0.01) return;
    c.resChargeThisSec += add;
    c.resGauge = clamp((c.resGauge||0) + add, 0, 100);
  }

  function resonancePenaltyHp(){ /* íŒ¨ë„í‹° ì œê±°ë¨ */ }


  function resonancePenaltyBreak(){ /* íŒ¨ë„í‹° ì œê±°ë¨ */ }


  function resonancePickTarget(){
    if (!state.enemies || state.enemies.length === 0) return null;
    // ë³´ìŠ¤ ìš°ì„ 
    for (const e of state.enemies) {
      if (e && e.kind === 'boss' && e.hp > 0) return e;
    }
    // ê·¸ ì™¸: ì½”ì–´ì— ê°€ì¥ ê°€ê¹Œìš´ ì 
    let best = null, bestD = 1e9;
    for (const e of state.enemies) {
      if (!e || e.hp <= 0) continue;
      const d = dist(e.x, e.y, CORE_POS.x, CORE_POS.y);
      if (d < bestD) { bestD = d; best = e; }
    }
    return best;
  }
  function resonanceDischarge(){
    const c = state.core;
    const t = gameSec();
    const target = resonancePickTarget();
    if (!target) { c.resDischargeReadyAt = t + RESONANCE_CFG.dischargeCd; return; }

    resonancePrune();
    const recent = resonanceRecentAbsSum();

    // ë©”ì¸ ë°ë¯¸ì§€(ìµœê·¼ 5.5ì´ˆ í¡ìˆ˜ëŸ‰ ê¸°ë°˜)
    let dmg = recent * RESONANCE_CFG.dischargeMul;
    const cap = c.shieldMax * RESONANCE_CFG.dischargeCapMul;
    dmg = Math.min(dmg, cap);

    // ìµœì†Œ ë³´ì¥(ë„ˆë¬´ ì•½í•˜ê²Œ ëŠê»´ì§€ëŠ” ìƒí™© ë°©ì§€)
    dmg = Math.max(dmg, Math.max(c.shieldMax * 0.75, 40 + state.wave*3));

    

    // í•˜ë“œëª¨ë“œ: ê³µëª… ë°˜ê²© íš¨ê³¼ 80%
    dmg *= passiveHardMul();
// ìµœì¢…ë³´ìŠ¤ ë‚´ì„± ë¡œì§ë§Œ ì ìš©(ì¶”ê°€ ê°ì‡„ ì—†ìŒ)
    if (target.isFinalBoss) dmg *= finalBossIncomingMul();

    const mainDmg = dmg;

    // ë©”ì¸ íƒ€ê²© + ë…¸ì¶œ
    target.hp -= mainDmg;
    applyResExpose(target, 4.0);

    // ì£¼ë³€ í™•ì‚° í”¼í•´(190px)
    const R = 205;
    for (const e of state.enemies) {
      if (!e || e.hp <= 0 || e === target) continue;
      const d = dist(e.x, e.y, target.x, target.y);
      if (d > R) continue;
      const k = clamp(d / R, 0, 1);
      const fall = lerp(1.0, 0.40, k); // edge => 0.35
      let sdmg = mainDmg * 0.40 * fall; // center 0.35, edge 0.1225
      if (e.isFinalBoss) sdmg *= finalBossIncomingMul();
      e.hp -= sdmg;
      applyResExpose(e, 3.2);
    }

    // ì—°ì¶œ: ë‹¤ì¤‘ ë¹”(2ê²¹) + ë§ 2ì¤‘ + í™”ë©´ í”Œë˜ì‹œ + ì¹´ë©”ë¼ í”ë“¤ë¦¼
    fxLine(CORE_POS.x, CORE_POS.y, target.x, target.y, '#fb923c', 0.55, 10);
    fxLine(CORE_POS.x, CORE_POS.y, target.x, target.y, '#fdba74', 0.55, 3);
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+12, CORE_RADIUS+170, '#fdba74');
    fxRing(target.x, target.y, 10, 120, '#fdba74');
    fxRing(target.x, target.y, 16, 160, '#fb923c');

    fxText(`ê³µëª… ë°©ì¶œ! -${Math.round(mainDmg)}`, CORE_POS.x, CORE_POS.y - 128, '#fdba74');

    // ì—°ì¶œ: ë„ˆë¬´ ìì£¼ ëœ¨ì§€ ì•Šë„ë¡ 3ì´ˆ ê°„ê²© ì œí•œ
    if (t >= (c.resCineAt||0)) {
      try { cineToast("ê³µëª… ë°©ì¶œ", `í”¼í•´ -${Math.round(mainDmg)}`, "#fdba74", 1.05); } catch {}
      c.resCineAt = t + 3.0;
    }

    state.resFlashX = target.x;
    state.resFlashY = target.y;
    state.resFlashDur = 0.16;
    state.resFlashUntil = t + state.resFlashDur;

    state.camShakeMag = 10;
    state.camShakeDur = 0.11;
    state.camShakeUntil = t + state.camShakeDur;

    try { SFX.play('blast'); } catch {}
    try { sfxShieldHit(); } catch {}

    // ëŠê¹€ ì™„í™”: 0ì´ ì•„ë‹ˆë¼ 25% ë‚¨ê¹€
    c.resGauge = 25;
    c.resDischargeReadyAt = t + RESONANCE_CFG.dischargeCd;
  }

  function updateResonance(dt){
    if (state.core.passiveId !== 'resonance') return;
    if (state.phase !== "wave") return; // ëŒ€ê¸°ì‹œê°„ì—ëŠ” ê³µëª… ê²Œì´ì§€/ìë™ë°©ì¶œ ìœ ì§€
    resonanceEnsure();
    const c = state.core;
    const t = gameSec();
    resonancePrune();

    // í¡ìˆ˜ ê³µë°± í›„ ê°ì‡  (ìµœì¢…ì „ì€ ìœ ì§€ì‹œê°„ì„ ì¡°ê¸ˆ ë” ëŠ˜ë ¤ ì²´ê° ê°•í™”)
    const since = t - (c.resLastAbsorbAt||-999);
    const isFinal = (state.wave === FINAL_WAVE);
    const decayWait = isFinal ? (RESONANCE_CFG.decayWait + 1.0) : RESONANCE_CFG.decayWait;
    const decayPerSec = isFinal ? (RESONANCE_CFG.decayPerSec * 0.60) : RESONANCE_CFG.decayPerSec;
    if (since > decayWait && (c.resGauge||0) > 0) {
      c.resGauge = clamp((c.resGauge||0) - decayPerSec*dt, 0, 100);
    }

    // 100% ë„ë‹¬ ì‹œ ìë™ ë°©ì¶œ
    if ((c.resGauge||0) >= 100 && t >= (c.resDischargeReadyAt||0)) {
      resonanceDischarge();
    }
  }


function passiveSelected(){ return !!state.core.passiveId; }

  // UI glow trigger guard
  let _lastCorePassiveShowId = null;
  let _lastCorePassiveConfirmedId = null;

  function pulseCorePassiveBox(){
    if (!uiCorePassiveChosenWrap) return;
    uiCorePassiveChosenWrap.classList.remove("glowPulse");
    // reflow to restart CSS animation
    void uiCorePassiveChosenWrap.offsetWidth;
    uiCorePassiveChosenWrap.classList.add("glowPulse");
  }

  function refreshCorePassiveUI(){
    const id = state.core.passiveId;
    const preview = state.core.passivePreviewId;
    const showId = id || preview || null;
    const locked = !!(id && state.core.passiveLocked);

    // (PC) ìƒë‹¨ ë¯¸ì„ íƒ ë°°ì§€ëŠ” ì œê±°ë¨ â€” ëŒ€ì‹  ì•„ë˜ ë°•ìŠ¤ì— ê¸€ë¡œìš°ë¥¼ ì¤Œ
    if (uiCorePassiveChosenWrap) {
      // (Fix) ìƒ‰ìƒ í´ë˜ìŠ¤ ë™ê¸°í™” â€” ì¬ê±´(íŒŒë‘) / ê³µëª…(ì£¼í™©) / ê³¼ë¶€í•˜(ë¹¨ê°•) / ì˜¤ë²„ë“œë¼ì´ë¸Œ(ë³´ë¼)
      uiCorePassiveChosenWrap.classList.remove("passiveBlue","passiveOrange","passiveRed","passivePurple");
      if (showId && CORE_PASSIVES[showId] && CORE_PASSIVES[showId].colorClass) {
        uiCorePassiveChosenWrap.classList.add(CORE_PASSIVES[showId].colorClass);
      }

      // confirmed/preview passive: subtle always-on glow loop
      uiCorePassiveChosenWrap.classList.toggle("glowLoop", !!showId);

      const changedPreview = (showId && showId !== _lastCorePassiveShowId);
      _lastCorePassiveShowId = showId || null;

      const changedConfirmed = (id && id !== _lastCorePassiveConfirmedId);
      _lastCorePassiveConfirmedId = id || null;

      if (changedPreview || changedConfirmed) pulseCorePassiveBox();
    }

    // ìŠ¤ì¼€ì¹˜ UI: ìƒë‹¨(ë¬´ì—‡ì„ ê³¨ëëŠ”ì§€) í‘œì‹œ
    if (uiCorePassiveChosenName) {
      uiCorePassiveChosenName.textContent = showId ? CORE_PASSIVES[showId].name : "ë¯¸ì„ íƒ";
    }
    if (uiCorePassiveChosenTag) {
      if (!showId) uiCorePassiveChosenTag.textContent = "ê²Œì„ í™”ë©´ì—ì„œ ì½”ì–´ íŒ¨ì‹œë¸Œë¥¼ ì„ íƒí•˜ì‹­ì‹œì˜¤.";
      else uiCorePassiveChosenTag.textContent = CORE_PASSIVE_TAG[showId] || "";
    }

    const setActive = (btn, on) => { if(!btn) return; btn.classList.toggle("active", !!on); };
    const setDisabled = (btn, v) => { if(!btn) return; btn.disabled = !!v; btn.classList.toggle("isDisabled", !!v); };

    setActive(btnCoreRebuild,   showId==="rebuild");
    setActive(btnCoreResonance, showId==="resonance");
    setActive(btnCoreOverload,  showId==="overload");
    setActive(btnCoreOverdrive, showId==="overdrive");

    // âœ… ìµœì´ˆ ì„ íƒ í›„ ì¬ì‹œì‘ ì „ê¹Œì§€ëŠ” ë³€ê²½ ë¶ˆê°€
    setDisabled(btnCoreRebuild,   locked);
    setDisabled(btnCoreResonance, locked);
    setDisabled(btnCoreOverload,  locked);
    setDisabled(btnCoreOverdrive, locked);

    // ì›¨ì´ë¸Œ ì‹œì‘ì€ 'ë¯¸ë¦¬ë³´ê¸°(ì„ íƒ ëŒ€ìƒ)' ë˜ëŠ” 'ì„ íƒ ì™„ë£Œ' ìƒíƒœì—ì„œ ê°€ëŠ¥
    if (btnWave) btnWave.disabled = !(id || preview);

    if (uiCorePassiveDesc) {
      if (!showId) {
        uiCorePassiveDesc.innerHTML = `íŒ¨ì‹œë¸Œë¥¼ ì„ íƒí•˜ë©´ <span class=\"kbd\">ì›¨ì´ë¸Œ ì‹œì‘</span>ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. (ì¬ì‹œì‘ ì‹œ ë‹¤ì‹œ ì„ íƒ)`;
      } else {
        const d = CORE_PASSIVES[showId];
        const hint = id
          ? (locked ? "ì¬ì‹œì‘ ì „ê¹Œì§€ íŒ¨ì‹œë¸Œ ë³€ê²½ ë¶ˆê°€" : "ì²« ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ ì ê¹€")
          : "ì˜¤ë¥¸ìª½ ì•„ë˜ [ì ìš©]ì„ ëˆ„ë¥´ë©´ í™•ì •ë©ë‹ˆë‹¤.";
        const lines = corePassiveDescLines(showId);
        const hardInfo = (state && state.diffId === "hard")
          ? `<div class=\"muted\" style=\"margin-top:6px;\">HARD: íŒ¨ì‹œë¸Œ ëª¨ë“  íš¨ê³¼ Ã—0.8 ì ìš©</div>`
          : "";
        uiCorePassiveDesc.innerHTML =
          lines.map(s=>`â€¢ ${s}`).join("<br>") +
          hardInfo +
          `<div class=\"muted\" style=\"margin-top:6px;\">${hint}</div>`;
      }
    }
  }



  function selectCorePassive(id){
    if (!(id in CORE_PASSIVES)) return;
    ensureAudio();
    SFX.play("click");

    // ì›¨ì´ë¸Œ ì¤‘ì—ëŠ” ë³€ê²½ ë¶ˆê°€
    if (!(state.phase==="build" || state.phase==="clear" || state.phase==="finalprep")) {
      setMsg("ì›¨ì´ë¸Œ ì¤‘ì—ëŠ” íŒ¨ì‹œë¸Œë¥¼ ë°”ê¿€ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", 2.0);
      return;
    }

    // âœ… ì¬ì‹œì‘ ì „ê¹Œì§€ëŠ” ë³€ê²½ ë¶ˆê°€(ìµœì´ˆ ì„ íƒë§Œ í—ˆìš©)
    if (state.core.passiveLocked && state.core.passiveId) {
      setMsg("íŒ¨ì‹œë¸ŒëŠ” ì¬ì‹œì‘ ì „ê¹Œì§€ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", 2.2);
      return;
    }

    state.core.passiveId = id;
    // passiveLockedëŠ” "ì²« ì›¨ì´ë¸Œ ì‹œì‘" ì‹œì ì— ì ê¸ˆë©ë‹ˆë‹¤.
    state.core.passiveStacks = 0;
    state.core.passiveLastHitAt = gameSec();
    state.core.passiveStackDecayAcc = 0;
    state.core.overdriveShotAcc = 0;
    state.core.hpDirectDamaged = false;

    // íŒ¨ì‹œë¸Œë³„ ëˆ„ì  ìƒíƒœ ë¦¬ì…‹
    resonanceReset();
    state.core.rebuildEmergencyUntil = 0;
    state.core.rebuildEmergencyReadyAt = 0;

    // ì„ê³„ ê³¼ë¶€í•˜ ëˆ„ì  ìƒíƒœ ë¦¬ì…‹
    state.core.overloadBurstUntil = 0;
    state.core.overloadBurstReadyAt = 0;
    state.core.overloadWasAbove30 = true;
    state.core.overloadExtendReadyAt = 0;
    state.core.overloadKickReadyAt = 0;

    // ì—°ì¶œ: íŒ¨ì‹œë¸Œ ì„ íƒ ì¹´ë“œ + ì½”ì–´ í„ìŠ¤
    try {
      const col = passiveAccent(id);
      cineCard("íŒ¨ì‹œë¸Œ ì„ íƒ", CORE_PASSIVES[id].name, col, 1.45);
      fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+160, col);
    } catch {}

    setMsg(`íŒ¨ì‹œë¸Œ ì„ íƒ: ${CORE_PASSIVES[id].name}`, 2.0);
    refreshCorePassiveUI();
    refreshUI();
  }

  const corePassivePanelClick = (pid) => {
    // ìƒíƒœ íŒ¨ë„ì—ì„œëŠ” 'ì„ íƒ'ì„ í•˜ì§€ ì•Šê³ , ë¯¸ë¦¬ë³´ê¸°ë§Œ ê°±ì‹ í•©ë‹ˆë‹¤.
    // (ì„ íƒ í™•ì •ì€ ê²Œì„ í™”ë©´ì˜ íŒ¨ë„ ì˜¤ë¥¸ìª½ ì•„ë˜ [ì ìš©] ë²„íŠ¼ìœ¼ë¡œ)
    if (state.core.passiveId) {
      setMsg("íŒ¨ì‹œë¸ŒëŠ” ìƒíƒœ íŒ¨ë„ì—ì„œ í™•ì¸ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤. (ë³€ê²½ì€ ì¬ì‹œì‘ í›„)", 2.2);
      return;
    }
    state.core.passivePreviewId = pid;
    setMsg("ê²Œì„ í™”ë©´ ì¤‘ì•™ íŒ¨ë„ ì˜¤ë¥¸ìª½ ì•„ë˜ [ì ìš©]ìœ¼ë¡œ í™•ì •í•˜ì‹­ì‹œì˜¤.", 2.0);
    refreshUI();
  };

  if (btnCoreRebuild)   btnCoreRebuild.addEventListener("click", ()=>corePassivePanelClick("rebuild"));
  if (btnCoreResonance) btnCoreResonance.addEventListener("click", ()=>corePassivePanelClick("resonance"));
  if (btnCoreOverload)  btnCoreOverload.addEventListener("click", ()=>corePassivePanelClick("overload"));
  if (btnCoreOverdrive) btnCoreOverdrive.addEventListener("click", ()=>corePassivePanelClick("overdrive"));

function selectFinalChoice(choice){
  if (state.phase !== "finalprep") return;
  state.finalChoice = choice;
  SFX.play("click");
  refreshUI();
}
if (btnFinalOffense) btnFinalOffense.addEventListener("click", ()=>selectFinalChoice("offense"));
if (btnFinalDefense) btnFinalDefense.addEventListener("click", ()=>selectFinalChoice("defense"));

// ì—…ê·¸ë ˆì´ë“œ ì…ë ¥: í´ë¦­ì´ ì”¹íˆëŠ” í™˜ê²½(í”„ë ˆì„ë§ˆë‹¤ innerHTML ê°±ì‹  ë“±) ëŒ€ë¹„
// - pointerdownì—ì„œ "ì¦‰ì‹œ êµ¬ë§¤" ì²˜ë¦¬(ë§ˆìš°ìŠ¤ ì—… ì „ì— DOMì´ ë°”ë€Œì–´ë„ í™•ì‹¤íˆ ë°˜ì˜)
// - í´ë¦­ ì´ë²¤íŠ¸ëŠ” ë°±ì—…ìš©
if (upgContainers.length) {
  let lastUpgHandledAt = 0;
  const handleUpg = (ev) => {
    const now = performance.now();
    if (ev.type === "click" && (now - lastUpgHandledAt) < 350) return;
    lastUpgHandledAt = now;
    const row = ev.target.closest("[data-upg]");
    if (!row) return;

    // íŒ¨ë„ í´ë¦­ì´ ìº”ë²„ìŠ¤ ì„¤ì¹˜ ë“±ìœ¼ë¡œ í˜ëŸ¬ê°€ì§€ ì•Šê²Œ
    ev.preventDefault();
    ev.stopPropagation();

    ensureAudio();

    const id = row.dataset.upg;
    const def = UPGRADE_DEFS.find(d=>d.id===id);
    if (!def) return;

    const lv = state.upg[id];
    const cost = upgCost(def);

    const canBuy = (lv < def.max) && (state.phase !== "fail") && (state.phase !== "win") && (state.crystals >= cost);
    if (!canBuy) {
      SFX.play("click");
      const msg =
        (lv >= def.max) ? "ì´ë¯¸ MAXì…ë‹ˆë‹¤!" :
        (state.phase === "fail") ? "ë¶•ê´´ í›„ì—ëŠ” ê°•í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!" :
        (state.crystals < cost) ? `ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! (${state.crystals}/${cost})` :
        "ì§€ê¸ˆì€ ê°•í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!";
      fxText(msg, CORE_POS.x, CORE_POS.y - 92, "#ff9fb2");
      setMsg("ì—…ê·¸ë ˆì´ë“œ ì‹¤íŒ¨: " + msg, 2.2);
      return;
    }

    buyUpgrade(id);
    // ì¦‰ì‹œ UI ê°±ì‹ (ë‹¤ìŒ í”„ë ˆì„ ê¸°ë‹¤ë¦¬ì§€ ì•Šê¸°)
    window.__upgLastRenderAt = 0;
    window.__upgForceRender = true;
    refreshUI();
  };

  for (const el of upgContainers) {
    el.addEventListener("pointerdown", handleUpg, { capture:true });
    el.addEventListener("click", handleUpg, { capture:true });
  }
  }

  const btnWave = document.getElementById("btnWave");
  const btnRestart = document.getElementById("btnRestart");
  const chkAutoStart = document.getElementById("chkAutoStart");
  const autoStartSlider = document.getElementById("autoStartSlider");
  const autoStartVal = document.getElementById("autoStartVal");
  const btnRepair  = document.getElementById("btnRepair");
  const btnEnergy = document.getElementById("btnEnergy");
  const btnBarrier = document.getElementById("btnBarrier");

  const btnItemRepair = document.getElementById("btnItemRepair");
  const btnItemFire   = document.getElementById("btnItemFire");
  const btnItemSlow   = document.getElementById("btnItemSlow");
  const uiShopItemHint = document.getElementById("uiShopItemHint");
  const btnBg = document.getElementById("btnBg");
  const btnDiffEasy = document.getElementById("btnDiffEasy");
  const btnDiffNormal = document.getElementById("btnDiffNormal");
  const btnDiffHard = document.getElementById("btnDiffHard");

  const btnSound = document.getElementById("btnSound");
  const btnVol   = document.getElementById("btnVol");
  
  const volSlider = document.getElementById("volSlider");
  const volVal    = document.getElementById("volVal");
const btnToggleWire = document.getElementById("btnToggleWire");
  const btnSpeed = document.getElementById("btnSpeed");
  const btnCheat = document.getElementById("btnCheat");
  const btnBugReport = document.getElementById("btnBugReport");
  const btnSelfCheck = document.getElementById("btnSelfCheck");


  // ---------- Mobile / Touch controls ----------
  const mobileBar = document.getElementById("mobileBar");
  const mbBasic = document.getElementById("mbBasic");
  const mbSlow = document.getElementById("mbSlow");
  const mbSplash = document.getElementById("mbSplash");
  const mbShred = document.getElementById("mbShred");
  const mbBreaker = document.getElementById("mbBreaker");
  const mbWave = document.getElementById("mbWave");
  const mbRepair = document.getElementById("mbRepair");
  const mbAegis = document.getElementById("mbAegis");
  const mbSell = document.getElementById("mbSell");
const mbFinalRow = document.getElementById("mbFinalRow");
const mbFinalOffense = document.getElementById("mbFinalOffense");
const mbFinalDefense = document.getElementById("mbFinalDefense");


  const mbCheatRow = document.getElementById("mbCheatRow");
  const mbCheat = document.getElementById("mbCheat");
  const mbCheatMenu = document.getElementById("mbCheatMenu");
  const mbEnergy = document.getElementById("mbEnergy");
  const mbBarrier = document.getElementById("mbBarrier");

  
  const mbMenu = document.getElementById("mbMenu");
  const panelEl = document.querySelector(".panel");
  const panelBackdrop = document.getElementById("panelBackdrop");
  const btnPanelClose = document.getElementById("btnPanelClose");
const cheatModal = document.getElementById("cheatModal");
  const chCrystals = document.getElementById("chCrystals");
  const chMaxUpg = document.getElementById("chMaxUpg");
  const chHeal = document.getElementById("chHeal");
  const chShield = document.getElementById("chShield");
  const chKill = document.getElementById("chKill");
  const chSkip = document.getElementById("chSkip");
  const chPassiveFull = document.getElementById("chPassiveFull");
  const chGod = document.getElementById("chGod");
  const chClose = document.getElementById("chClose");

  // Final support buttons (mobile)
  if (mbFinalOffense) mbFinalOffense.addEventListener("click", ()=>selectFinalChoice("offense"));
  if (mbFinalDefense) mbFinalDefense.addEventListener("click", ()=>selectFinalChoice("defense"));

  // Mobile cheat menu
  function setCheatModalOpen(on){
    if (!cheatModal) return;
    cheatModal.classList.toggle("hidden", !on);
  }

  function syncCheatButtons(){
    if (mbCheat){
      mbCheat.firstElementChild.textContent = state.cheat ? "ì¹˜íŠ¸ ON" : "ì¹˜íŠ¸ OFF";
    }
    if (mbCheatMenu){
      mbCheatMenu.disabled = !state.cheat;
    }
    if (chGod){
      chGod.textContent = state.god ? "ë¬´ì  OFF" : "ë¬´ì  ON";
    }
  }

  if (mbCheat) mbCheat.addEventListener("click", ()=>{
    ensureAudio(); SFX.play("click"); toggleCheat(); syncCheatButtons();
  });
  if (mbCheatMenu) mbCheatMenu.addEventListener("click", ()=>{
    ensureAudio();
    if (!state.cheat){ setMsg("ì¹˜íŠ¸ê°€ OFF ì…ë‹ˆë‹¤. (T)", 1.6); SFX.play("click"); return; }
    SFX.play("click");
    setCheatModalOpen(true);
  });

  if (cheatModal) cheatModal.addEventListener("click", (e)=>{
    if (e.target === cheatModal){
      ensureAudio(); SFX.play("click"); setCheatModalOpen(false);
    }
  });
  if (chClose) chClose.addEventListener("click", ()=>{
    ensureAudio(); SFX.play("click"); setCheatModalOpen(false);
  });

  const bindCheatBtn = (el, fn) => {
    if (!el) return;
    el.addEventListener("click", ()=>{
      ensureAudio(); SFX.play("click");
      fn();
      syncCheatButtons();
    });
  };

  bindCheatBtn(chCrystals, ()=>cheatAddCrystals(500));
  bindCheatBtn(chMaxUpg, ()=>cheatMaxUpgrades());
  bindCheatBtn(chHeal, ()=>cheatHealHP());
  bindCheatBtn(chShield, ()=>cheatRefillShield());
  bindCheatBtn(chKill, ()=>cheatKillAll());
  bindCheatBtn(chSkip, ()=>cheatSkipWave());
  bindCheatBtn(chPassiveFull, ()=>cheatPassiveFull());
  bindCheatBtn(chGod, ()=>toggleGod());



  state.mobileSellMode = false;

  function detectMobile(){
    try{
      if (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) return true;
    }catch(e){}
    return (window.innerWidth < 900);
  }

  // Wire panel toggle (mobile + desktop button)
  function setWireVisible(show){
    const p = document.getElementById("wirePanel");
    if (!p) return;
    p.classList.toggle("hidden", !show);
    if (btnToggleWire) btnToggleWire.textContent = show ? "ì™€ì´ì–´ ìˆ¨ê¹€" : "ì™€ì´ì–´ í‘œì‹œ";
  }

  try{
    const p = document.getElementById("wirePanel");
    setWireVisible(p && !p.classList.contains("hidden"));
  }catch(e){}


  function setMobileUIEnabled(on){
    if (!mobileBar) return;
    if (on){
      mobileBar.classList.remove("hidden");
      document.body.classList.add("hasMobileBar");
      // ì‹¤ì œ ëª¨ë°”ì¼ ë°” ë†’ì´ì— ë§ì¶° ì—¬ë°± ì¡°ì • (ì¤„ë°”ê¿ˆ/ì¶”ê°€ ë²„íŠ¼ì—ë„ ì•ˆì „)
      requestAnimationFrame(updateMobilePad);
      // ëª¨ë°”ì¼ì—ì„œëŠ” íŒ¨ë„ì„ ì›ë˜ëŒ€ë¡œ í•­ìƒ í‘œì‹œ (ì˜¤ë²„ë ˆì´ ë¹„í™œì„±í™”)
      // Mobile default: show wire panel
      setWireVisible(true);
    } else {
      mobileBar.classList.add("hidden");
      document.body.classList.remove("hasMobileBar");
      state.mobileSellMode = false;
      if (panelEl) panelEl.classList.remove("mobileOpen");
      if (panelBackdrop) panelBackdrop.classList.add("hidden");
    }
  }


  function updateMobilePad(){
    if (!mobileBar) return;
    const h = mobileBar.getBoundingClientRect().height || 0;
    document.documentElement.style.setProperty("--mbPad", Math.ceil(h) + "px");
  }

  function openMobilePanel(open){
    if (!panelEl || !panelBackdrop) return;
    if (open){
      panelEl.classList.add("mobileOpen");
      panelBackdrop.classList.remove("hidden");
      panelBackdrop.setAttribute("aria-hidden","false");
      updateMobilePad();
    } else {
      panelEl.classList.remove("mobileOpen");
      panelBackdrop.classList.add("hidden");
      panelBackdrop.setAttribute("aria-hidden","true");
    }
  }

  // ëª¨ë°”ì¼ ë©”ë‰´(ì—…ê·¸ë ˆì´ë“œ/íŒ¨ì‹œë¸Œ/ì¹˜íŠ¸ ë“±) ì—´ê¸°/ë‹«ê¸°

  if (mbMenu){
    mbMenu.addEventListener("click", ()=>{
      const isOpen = panelEl && panelEl.classList.contains("mobileOpen");
      openMobilePanel(!isOpen);
      try{ SFX.play("click"); }catch{}
    });
  }
  if (btnPanelClose){
    btnPanelClose.addEventListener("click", ()=>{
      openMobilePanel(false);
      try{ SFX.play("click"); }catch{}
    });
  }
  if (panelBackdrop){
    panelBackdrop.addEventListener("click", ()=> openMobilePanel(false));
  }
  window.addEventListener("resize", ()=> requestAnimationFrame(updateMobilePad), {passive:true});

  function setSelectedTurret(type){
    if (!TURRET_TYPES[type]) return;
    state.selected = type;
    ensureAudio();
    SFX.play("click");
    syncMobileButtons();
  }

  function syncMobileButtons(){
    if (!mobileBar || mobileBar.classList.contains("hidden")) return;
    const s = state.selected;
    if (mbBasic)   mbBasic.classList.toggle("active", s==="basic");
    if (mbSlow)    mbSlow.classList.toggle("active", s==="slow");
    if (mbSplash)  mbSplash.classList.toggle("active", s==="splash");
    if (mbShred)   mbShred.classList.toggle("active", s==="shred");
    if (mbBreaker) mbBreaker.classList.toggle("active", s==="breaker");

    if (mbSell){
      mbSell.classList.toggle("on", !!state.mobileSellMode);
      mbSell.firstElementChild.textContent = state.mobileSellMode ? "íŒë§¤ ON" : "íŒë§¤ OFF";
    }

    // ë²„íŠ¼ì— í˜„ì¬ ë¹„ìš© í‘œì‹œ(ë‚œì´ë„/ë°¸ëŸ°ìŠ¤ ë°”ë€Œì–´ë„ ìë™ ë°˜ì˜)
    if (mbBasic)   mbBasic.querySelector("small").textContent = `ì„¤ì¹˜(${TURRET_TYPES.basic.cost})`;
    if (mbSlow)    mbSlow.querySelector("small").textContent = `ì„¤ì¹˜(${TURRET_TYPES.slow.cost})`;
    if (mbSplash)  mbSplash.querySelector("small").textContent = `ì„¤ì¹˜(${TURRET_TYPES.splash.cost})`;
    if (mbShred)   mbShred.querySelector("small").textContent = `ì„¤ì¹˜(${TURRET_TYPES.shred.cost})`;
    if (mbBreaker) mbBreaker.querySelector("small").textContent = `ì„¤ì¹˜(${TURRET_TYPES.breaker.cost})`;
  }

  function canvasXYFromClient(cx, cy){
    const r = canvas.getBoundingClientRect();
    const mx = (cx - r.left) * (canvas.width / r.width);
    const my = (cy - r.top)  * (canvas.height / r.height);
    return {mx, my};
  }

  function mobileSellAt(mx, my){
    const ok = sellTurretAt(mx,my);
    if (!ok) fxText("íŒë§¤í•  í¬íƒ‘ì´ ì—†ìŠµë‹ˆë‹¤.", mx, my, "#fcd34d");
  }

  function mobilePlaceAt(mx, my){
    const tt = TURRET_TYPES[state.selected];
    const dCore = dist(mx,my, CORE_POS.x, CORE_POS.y);
    if (dCore < CORE_RADIUS + 30) return;
    if (dCore > BUILD_RADIUS) return;
    if (overlapsTurret(mx,my)) return;

    if (state.crystals < tt.cost) { fxText("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!", mx, my, "#ff9fb2"); return; }

    state.crystals -= tt.cost;
    state.turrets.push({ type: state.selected, x: mx, y: my, cd: 0 });
    try { if (state.stats && state.stats.turretBuilt) state.stats.turretBuilt[state.selected] = (state.stats.turretBuilt[state.selected]|0) + 1; } catch(e) {}
    fxRing(mx,my, 14, 64, "#7dd3fc");
    SFX.play("place");
  }

  if (mbBasic)   mbBasic.onclick = ()=> setSelectedTurret("basic");
  if (mbSlow)    mbSlow.onclick = ()=> setSelectedTurret("slow");
  if (mbSplash)  mbSplash.onclick = ()=> setSelectedTurret("splash");
  if (mbShred)   mbShred.onclick = ()=> setSelectedTurret("shred");
  if (mbBreaker) mbBreaker.onclick = ()=> setSelectedTurret("breaker");

  if (mbWave)   mbWave.onclick = ()=> { ensureAudio(); SFX.play("click"); if (state.phase==="win") return; if (state.phase==="build"||state.phase==="clear"||state.phase==="finalprep") startWave(); };
  if (mbRepair) mbRepair.onclick = ()=> { ensureAudio(); tryRepair(); };
  if (mbAegis)  mbAegis.onclick  = ()=> { ensureAudio(); tryAegis(); };
  if (mbEnergy) mbEnergy.onclick = ()=> { ensureAudio(); tryEnergyCannon(); };
  if (mbBarrier) mbBarrier.onclick = ()=> { ensureAudio(); tryBarrier(); };
  if (mbSell)   mbSell.onclick   = ()=> { ensureAudio(); SFX.play("click"); state.mobileSellMode = !state.mobileSellMode; syncMobileButtons(); };

  // Touch: tap to place / sell. Long-press sells (even if sell-mode off).
  let _lpTimer = null;
  let _lpFired = false;
  let _down = null;

  canvas.addEventListener("pointerdown", (e)=>{
    if (!detectMobile()) return;
    if (e.pointerType === "mouse") return; // ë°ìŠ¤í¬íƒ‘ ë§ˆìš°ìŠ¤ëŠ” ê¸°ì¡´ ë¡œì§ ì‚¬ìš©
    ensureAudio();
    canvas.setPointerCapture(e.pointerId);
    const {mx, my} = canvasXYFromClient(e.clientX, e.clientY);
    _lpFired = false;
    _down = { id: e.pointerId, mx, my, cx: e.clientX, cy: e.clientY };

    // ê¸¸ê²Œ ëˆ„ë¥´ë©´ íŒë§¤(ë¹Œë“œ/í´ë¦¬ì–´ì—ì„œë§Œ)
    if (state.phase === "build" || state.phase === "clear" || state.phase === "finalprep"){
      clearTimeout(_lpTimer);
      _lpTimer = setTimeout(()=>{
        if (!_down) return;
        const dx = Math.abs(_down.cx - e.clientX);
        const dy = Math.abs(_down.cy - e.clientY);
        if (dx > 14 || dy > 14) return; // ë“œë˜ê·¸ë©´ ì·¨ì†Œ
        mobileSellAt(_down.mx, _down.my);
        _lpFired = true;
      }, 420);
    }
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener("pointermove", (e)=>{
    if (!detectMobile()) return;
    if (e.pointerType === "mouse") return;
    // í”„ë¦¬ë·°/í˜¸ë²„ìš© ì¢Œí‘œ ê°±ì‹ 
    try{
      const r = canvas.getBoundingClientRect();
      if (typeof mouse !== "undefined"){
        mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
        mouse.y = (e.clientY - r.top)  * (canvas.height / r.height);
        mouse.inside = (mouse.x>=0 && mouse.x<=W && mouse.y>=0 && mouse.y<=H);
      }
    }catch(err){} 

    // ë“œë˜ê·¸í•˜ë©´ ë¡±í”„ë ˆìŠ¤ ì·¨ì†Œ
    if (_down){
      const dx = Math.abs(_down.cx - e.clientX);
      const dy = Math.abs(_down.cy - e.clientY);
      if (dx > 14 || dy > 14) { clearTimeout(_lpTimer); }
    }
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener("pointerup", (e)=>{
    if (!detectMobile()) return;
    if (e.pointerType === "mouse") return;
    clearTimeout(_lpTimer);
    if (_lpFired){ _down=null; return; }

    const {mx, my} = canvasXYFromClient(e.clientX, e.clientY);
    if (state.phase === "build" || state.phase === "clear" || state.phase === "finalprep"){
      if (state.mobileSellMode) mobileSellAt(mx,my);
      else mobilePlaceAt(mx,my);
    }
    _down = null;
    e.preventDefault();
  }, {passive:false});

  // ëª¨ë°”ì¼ UI í‘œì‹œ ì´ˆê¸°í™”
  setMobileUIEnabled(detectMobile());
  syncMobileButtons();
  window.addEventListener("resize", ()=>{
    const on = detectMobile();
    setMobileUIEnabled(on);
    syncMobileButtons();
  });

  btnWave.onclick = () => { ensureAudio(); SFX.play("click"); if (state.phase === "win") { setMsg("ìŠ¹ë¦¬! ì¬ì‹œì‘ìœ¼ë¡œ ìƒˆ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”.", 2.2); return; } if (state.phase === "build" || state.phase === "clear" || state.phase === "finalprep") startWave(); };
  btnRestart.onclick = () => { ensureAudio(); SFX.play("click"); restart(); };
  // ë‹¤ìŒ ì›¨ì´ë¸Œ ìë™ ì‹œì‘(ì €ì¥ ì•ˆ í•¨)
  if (chkAutoStart) {
    chkAutoStart.checked = !!state.ui.autoStartEnabled;
    chkAutoStart.addEventListener("change", ()=>{
      state.ui.autoStartEnabled = chkAutoStart.checked;
      if (!state.ui.autoStartEnabled) {
        state.autoStartAt = 0;
      } else if (state.phase === "clear" && state.autoStartAt <= 0) {
        state.autoStartAt = gameSec() + state.autoStartDelay;
      }
      refreshUI();
    });
  }
  if (autoStartSlider) {
    autoStartSlider.value = String(Math.round(state.autoStartDelay||0));
    const syncVal = ()=>{
      const v = Math.max(0, Math.min(15, Math.round(Number(autoStartSlider.value)||0)));
      state.autoStartDelay = v;
      if (autoStartVal) autoStartVal.textContent = `${v}s`;
      if (state.ui.autoStartEnabled && state.phase === "clear") state.autoStartAt = gameSec() + state.autoStartDelay;
      refreshUI();
    };
    autoStartSlider.addEventListener("input", syncVal);
    autoStartSlider.addEventListener("change", syncVal);
    if (autoStartVal) autoStartVal.textContent = `${Math.round(state.autoStartDelay||0)}s`;
  }

  btnRepair.onclick  = () => { ensureAudio(); tryRepair(); };
  if (btnBarrier) btnBarrier.onclick = () => { ensureAudio(); tryBarrier(); };
  if (btnItemRepair) btnItemRepair.onclick = () => { ensureAudio(); useShopItemRepair(); };
  if (btnItemFire)   btnItemFire.onclick   = () => { ensureAudio(); useShopItemFire(); };
  if (btnItemSlow)   btnItemSlow.onclick   = () => { ensureAudio(); useShopItemSlow(); };
  if (btnEnergy) btnEnergy.onclick = () => { ensureAudio(); tryEnergyCannon(); };
  if (btnBg) btnBg.onclick = () => {
    ensureAudio(); SFX.play("click");
    state.ui.bgMode = ((state.ui.bgMode||0) + 1) % 3;
    syncBackground();
  };
  if (btnDiffEasy) btnDiffEasy.onclick = () => { ensureAudio(); SFX.play("click"); setDiffPreset("easy"); };
  if (btnDiffNormal) btnDiffNormal.onclick = () => { ensureAudio(); SFX.play("click"); setDiffPreset("normal"); };
  if (btnDiffHard) btnDiffHard.onclick = () => { ensureAudio(); SFX.play("click"); setDiffPreset("hard"); };
  try { refreshDiffUI(); } catch {}

  // ---------- Sound UI ----------
  // ë²„íŠ¼(í”„ë¦¬ì…‹) + ìŠ¬ë¼ì´ë”(ì •ë°€)ë¡œ ë³¼ë¥¨ì„ ì¡°ì ˆí•©ë‹ˆë‹¤.
  const VOL_PRESETS = [0.00, 0.25, 0.50, 0.75, 1.00];
  let presetIdx = 0;

  function syncPresetIdx(){
    const v = SFX.getVolume();
    let best = 0, bestD = 999;
    for (let i=0;i<VOL_PRESETS.length;i++){
      const d = Math.abs(VOL_PRESETS[i] - v);
      if (d < bestD){ bestD = d; best = i; }
    }
    presetIdx = best;
  }

  function refreshSoundUI(){
    btnSound.textContent = SFX.getEnabled() ? "ì‚¬ìš´ë“œ ON" : "ì‚¬ìš´ë“œ OFF";
    const pct = Math.round(SFX.getVolume() * 100);
    btnVol.textContent   = `ë³¼ë¥¨ ${pct}%`;
    if (volSlider) volSlider.value = String(pct);
    if (volVal)    volVal.textContent = `${pct}%`;
  }
  refreshSoundUI();

  btnSound.onclick = () => {
    ensureAudio();
    const next = !SFX.getEnabled();
    SFX.setEnabled(next);
    SFX.play("click");
    refreshSoundUI();
  };

  if (volSlider){
    volSlider.addEventListener("input", () => {
      ensureAudio();
      const v = clamp(parseInt(volSlider.value, 10) / 100, 0, 1);
      SFX.setVolume(v);
      refreshSoundUI();
    });
    volSlider.addEventListener("change", () => {
      ensureAudio();
      if (SFX.getVolume() > 0) SFX.play("click");
      syncPresetIdx();
      refreshSoundUI();
    });
  }

  btnVol.onclick = () => {
    ensureAudio();
    syncPresetIdx();
    presetIdx = (presetIdx + 1) % VOL_PRESETS.length;
    SFX.setVolume(VOL_PRESETS[presetIdx]);
    // ë³¼ë¥¨ 0ì´ë©´ ìë™ìœ¼ë¡œ ë”ì²˜ëŸ¼ ëŠê»´ì§€ë‹ˆ, enabledëŠ” ìœ ì§€
    if (SFX.getVolume() > 0) SFX.play("click");
    refreshSoundUI();
  };

  if (btnToggleWire) btnToggleWire.onclick = () => {
    const p = document.getElementById("wirePanel");
    if (!p) return;
    const hidden = p.classList.contains("hidden");
    setWireVisible(hidden);
  };

  if (btnSpeed) btnSpeed.onclick = () => { ensureAudio(); SFX.play("click"); cycleSpeed(); };
  if (btnCheat) btnCheat.onclick = () => { ensureAudio(); SFX.play("click"); toggleCheat(); };


  setupErrorCapture();

  if (btnBugReport) btnBugReport.onclick = () => {
    ensureAudio();
    SFX.play("click");
    const txt = collectBugReport();
    copyText(txt).then(()=>{
      setMsg("ë²„ê·¸ ë¦¬í¬íŠ¸ ë³µì‚¬ë¨ (í´ë¦½ë³´ë“œ)", 1.8);
    }).catch(()=>{
      try{
        window.prompt("ë²„ê·¸ ë¦¬í¬íŠ¸(ë³µì‚¬í•´ì„œ ë³´ë‚´ì„¸ìš”):", txt);
        setMsg("ë³µì‚¬ ì‹¤íŒ¨: í”„ë¡¬í”„íŠ¸ë¡œ ì¶œë ¥í–ˆìŠµë‹ˆë‹¤.", 2.5);
      }catch(e){
        setMsg("ë³µì‚¬ ì‹¤íŒ¨: ë¸Œë¼ìš°ì € ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.", 2.5);
      }
    });
  };

  if (btnSelfCheck) btnSelfCheck.onclick = () => {
    ensureAudio();
    SFX.play("click");
    runSelfCheck();
  };
  window.addEventListener("keydown", (e) => {
    if (["Digit1","Digit2","Digit3","Digit4","Digit5","Space","KeyR","KeyF","KeyX","KeyE"].includes(e.code)) e.preventDefault();
    if (["Digit1","Digit2","Digit3","Digit4","Digit5","Space","KeyR","KeyF","KeyX","KeyE"].includes(e.code)) ensureAudio();
    if (e.code === "Digit1") { state.selected = "basic"; 
    state.basicEvo = null;
SFX.play("click"); }
    if (e.code === "Digit2") {
      if (state.phase === "wave") {
        tryEnergyCannon();
      } else {
        state.selected = "slow";
        SFX.play("click");
      }
    }
    if (e.code === "Digit3") { state.selected = "splash"; SFX.play("click"); }
    if (e.code === "Digit4") { state.selected = "shred";  SFX.play("click"); }
    if (e.code === "Digit5") { state.selected = "breaker"; SFX.play("click"); }
    if (e.code === "Space")  tryAegis();
    if (e.code === "KeyF")  tryRepair();
    if (e.code === "KeyE")  tryEnergyCannon();
    if (e.code === "KeyX")  { if (state.phase==="build" || state.phase==="clear") { const ok = sellTurretAt(mouse.x, mouse.y); if (!ok) fxText("íŒë§¤í•  í¬íƒ‘ì´ ì—†ìŠµë‹ˆë‹¤.", mouse.x, mouse.y, "#fcd34d"); } }
    if (e.code === "KeyR") { SFX.play("click"); restart(); }
    // Speed controls
    if (["Minus","Equal","BracketLeft","BracketRight"].includes(e.code)) { e.preventDefault(); ensureAudio(); }
    if (e.code === "Minus" || e.code === "BracketLeft") { SFX.play("click"); setSpeed(state.speed/1.25); setMsg(`ë°°ì†: ${state.speed.toFixed(2).replace(/\.00$/,".0")}x`, 1.6); }
    if (e.code === "Equal" || e.code === "BracketRight") { SFX.play("click"); setSpeed(state.speed*1.25); setMsg(`ë°°ì†: ${state.speed.toFixed(2).replace(/\.00$/,".0")}x`, 1.6); }

    // Cheat toggle
    if (e.code === "KeyT") { e.preventDefault(); ensureAudio(); SFX.play("click"); toggleCheat(); }

    // Cheat actions (only when cheat ON)
    if (state.cheat){
      if (["KeyK","KeyH","KeyJ","KeyB","KeyN","KeyU","KeyG","KeyP"].includes(e.code)) { e.preventDefault(); ensureAudio(); }
      if (e.code === "KeyK") cheatAddCrystals(500);
      if (e.code === "KeyH") cheatHealHP();
      if (e.code === "KeyJ") cheatRefillShield();
      if (e.code === "KeyB") cheatKillAll();
      if (e.code === "KeyN") cheatSkipWave();
      if (e.code === "KeyU") cheatMaxUpgrades();
      if (e.code === "KeyP") cheatPassiveFull();
      if (e.code === "KeyG") toggleGod();
    }

  });

  // ---------- Build placement ----------
  const mouse = { x:0, y:0, inside:false };
  canvas.addEventListener("mousemove", (e)=>{
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (e.clientY - r.top)  * (canvas.height / r.height);
    mouse.inside = (mouse.x>=0 && mouse.x<=W && mouse.y>=0 && mouse.y<=H);
  });
  canvas.addEventListener("mouseleave", ()=> mouse.inside=false);
  canvas.addEventListener("contextmenu", (e)=>e.preventDefault());

  canvas.addEventListener("mousedown", (e) => {
    if (state.phase !== "build" && state.phase !== "clear") return;

    ensureAudio();

    const r = canvas.getBoundingClientRect();
    const mx = (e.clientX - r.left) * (canvas.width / r.width);
    const my = (e.clientY - r.top)  * (canvas.height / r.height);

    // ì¢Œí´ë¦­: ì„¤ì¹˜ / ìš°í´ë¦­: íŒë§¤
    if (e.button === 2) {
      const ok = sellTurretAt(mx,my);
      if (!ok) fxText("íŒë§¤í•  í¬íƒ‘ì´ ì—†ìŠµë‹ˆë‹¤.", mx, my, "#fcd34d");
      return;
    }

    // âœ… ì™¼ìª½ í´ë¦­ë§Œ ì„¤ì¹˜
    if (e.button !== 0) return;

    const tt = TURRET_TYPES[state.selected];
    const dCore = dist(mx,my, CORE_POS.x, CORE_POS.y);

    if (dCore < CORE_RADIUS + 30) return;
    if (dCore > BUILD_RADIUS) return;
    if (overlapsTurret(mx,my)) return;

    if (state.crystals < tt.cost) { fxText("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!", mx, my, "#ff9fb2"); return; }

    state.crystals -= tt.cost;
    state.turrets.push({ type: state.selected, x: mx, y: my, cd: 0 });
    try { if (state.stats && state.stats.turretBuilt) state.stats.turretBuilt[state.selected] = (state.stats.turretBuilt[state.selected]|0) + 1; } catch(e) {}
    fxRing(mx,my, 14, 64, "#7dd3fc");
    SFX.play("place");
  });

  function overlapsTurret(x,y){
    for (const t of state.turrets) if (dist(x,y, t.x,t.y) < 34) return true;
    return false;
  }

  // ---------- Wave Spec ----------
  function waveTheme(w){
  if (w === FINAL_WAVE) return { key:"final", name:"ìµœì¢…", desc:"ìµœì¢… ë³´ìŠ¤" };
  if (w % 5 === 0) return { key:"boss", name:"ë³´ìŠ¤", desc:"ì •ì˜ˆ ë“±ì¥" };

  // í…Œë§ˆ ì›¨ì´ë¸Œ(ê°€ë³ê²Œ ë³€ì£¼)
  // - ëŸ¬ì‹œ: ë¹ ë¥¸ ì  ìœ„ì£¼ + ìŠ¤í° ì†ë„â†‘
  // - ì¤‘ì¥ê°‘: ì²´ë ¥ ë†’ì€ ì  ìœ„ì£¼ + ìŠ¤í° ìˆ˜â†“
  // - í­íŒŒ: í­íŒŒ/ì‹¤ë“œë¸Œë ˆì´ì»¤ ë¹„ì¤‘â†‘
  if (w % 10 === 3 || w % 10 === 8) return { key:"rush", name:"ëŸ¬ì‹œ", desc:"ë¹ ë¥¸ ì  ê¸‰ìŠµ" };
  if (w % 10 === 4 || w % 10 === 9) return { key:"siege", name:"ì¤‘ì¥ê°‘", desc:"ë‹¨ë‹¨í•œ ì " };
  if (w % 10 === 6 || w % 10 === 1) return { key:"bomb", name:"í­íŒŒ", desc:"í­íŒŒ/ë¸Œë ˆì´ì»¤" };
  if (w % 10 === 2) return { key:"swarm", name:"êµ°ë‹¨", desc:"ë‹¤ìˆ˜ì˜ ì•½í•œ ì " };
  if (w % 10 === 7) return { key:"sniper", name:"ì €ê²©", desc:"ì›ê±°ë¦¬ ì••ë°•" };
  return { key:"mix", name:"í˜¼í•©", desc:"í˜¼í•© í¸ì„±" };
}

function waveSpec(w){
  const isBoss = (w % 5 === 0) || (w === FINAL_WAVE);
  const isFinal = (w === FINAL_WAVE);
  const th = waveTheme(w);

  // ìµœì¢… ì›¨ì´ë¸Œ(30): ë³´ìŠ¤ 1ë§ˆë¦¬ë§Œ ê¸°ë³¸ ìŠ¤í°. (ì¶”ê°€ ì†Œí™˜ì€ ë³´ìŠ¤ íŒ¨í„´ì—ì„œ ì²˜ë¦¬)
  const baseCount = Math.floor(10 + w*2.0);
  let count = isFinal ? 1 : (isBoss ? Math.max(8, Math.floor(baseCount*0.65)) : baseCount);

  let hp  = (25 + w*5.8) * (isFinal ? 4.2 : (isBoss ? 2.25 : 1.0));
  let spd = (42 + w*2.2) * (isFinal ? 0.95 : (isBoss ? 0.92 : 1.0));
  let spawnRate = (isFinal ? 0.88 : (isBoss ? 0.88 : 1.22)) + w*0.028;

  // í…Œë§ˆ ì›¨ì´ë¸Œ ë³´ì • (ì²´ê°ë§Œ ì£¼ê³  ê³¼í•˜ì§€ ì•Šê²Œ)
  if (!isBoss && !isFinal){
    if (th.key === "rush"){
      spd *= 1.14; hp *= 0.93; spawnRate *= 1.12;
    } else if (th.key === "siege"){
      hp *= 1.18; spd *= 0.93; count = Math.max(8, Math.floor(count*0.88));
    } else if (th.key === "bomb"){
      hp *= 1.05; spawnRate *= 1.04;
    } else if (th.key === "swarm"){
      spd *= 1.05; hp *= 0.90; count = Math.max(10, Math.floor(count*1.15)); spawnRate *= 1.08;
    } else if (th.key === "sniper"){
      hp *= 1.04; spd *= 0.97; count = Math.max(8, Math.floor(count*0.97)); spawnRate *= 0.99;
    }
  }

  return { count, hp, spd, spawnRate, isBoss, isFinal, themeKey: th.key, themeName: th.name, themeDesc: th.desc };
}



  // ---------- Enemy types ----------
  const ENEMY_ARCH = {
    grunt: { name:"ëŒê²©ë³‘",  hpMul:1.00, spdMul:1.00, r:12, reward:10, touchDmg:9,  touchCd:0.70, color:"#fb7185" },
    shooter:{ name:"ì‚¬ìˆ˜",    hpMul:0.90, spdMul:0.92, r:11, reward:12, touchDmg:7,  touchCd:0.85,
              ranged:true, shootRange:260, holdDist:230, shotCd:1.15, projDmg:8, projSpd:320,
              coreOpts:{ hpArmorPierce:0.20 }, color:"#fbbf24" },
    shieldbreaker:{ name:"ì‹¤ë“œ ë¸Œë ˆì´ì»¤", hpMul:1.05, spdMul:1.02, r:12, reward:13, touchDmg:8, touchCd:0.72,
              coreOpts:{ shieldBonusMul:1.55 }, color:"#60a5fa" },
    piercer:{ name:"ê´€í†µë³‘",  hpMul:0.95, spdMul:1.12, r:12, reward:13, touchDmg:10, touchCd:0.72,
              coreOpts:{ hpArmorPierce:0.65 }, color:"#a78bfa" },
    
    runner:{ name:"ì§ˆì£¼ë³‘",  hpMul:0.70, spdMul:1.65, r:11, reward:9, touchDmg:7, touchCd:0.65,
              coreOpts:{}, color:"#fca5a5" },
    bruiser:{ name:"ì¤‘ì¥ê°‘", hpMul:1.85, spdMul:0.78, r:14, reward:16, touchDmg:12, touchCd:0.78,
              coreOpts:{ shieldBonusMul:1.10 }, color:"#94a3b8" },


    supporter:{ name:"ì‹¤ë“œ ì„œí¬í„°", hpMul:0.95, spdMul:0.92, r:12, reward:15, touchDmg:6, touchCd:0.92,
              shieldMul:0.55,
              supportCd:1.80, supportR:170, supportMul:0.18, supportMulBoss:0.10,
              coreOpts:{}, color:"#38bdf8" },

    disruptor:{ name:"êµë€ê¸°", hpMul:1.18, spdMul:0.90, r:12, reward:15, touchDmg:6, touchCd:0.95,
              ranged:true, shootRange:280, holdDist:245, shotCd:1.45, projDmg:7, projSpd:330,
              shieldMul:0.75,
              coreOpts:{ empDur:2.4, empMul:0.72, shieldRegenBlockDur:2.4, repairBlockDur:2.4 }, color:"#22c55e" },

bomber:{ name:"í­íŒŒë³‘",   hpMul:0.82, spdMul:1.25, r:12, reward:14, touchDmg:0, touchCd:0,
              bomber:true, explodeDmg:32, explodeRad:120, turretBreakChance:0.35,
              coreOpts:{ shieldBonusMul:1.20 }, color:"#34d399" },

    boss: { name:"ì •ì˜ˆ ì½”ì–´ë¸Œë ˆì´ì»¤", hpMul:6.5, spdMul:0.85, r:22, reward:80, touchDmg:20, touchCd:0.55,
            ranged:true, shootRange:320, holdDist:260, shotCd:0.95, projDmg:14, projSpd:360,
            coreOpts:{ hpArmorPierce:0.35, shieldBonusMul:1.15 }, color:"#f472b6" },
  };

  function pickEnemyId(w, spec, idx){
    // boss wave: ì²« ìŠ¤í°ì€ ë³´ìŠ¤ 1ë§ˆë¦¬
    if (spec.isBoss && idx === 0) return "boss";

    const pool = [];
    pool.push(["grunt",  60]);

    if (w >= 2) pool.push(["shooter", 18]);
    if (w >= 3) pool.push(["shieldbreaker", 16]);
    if (w >= 4) pool.push(["piercer", 16]);
    if (w >= 2) pool.push(["runner", 14]);
    if (w >= 2) pool.push(["shooter", 18]);
    if (w >= 3) pool.push(["shieldbreaker", 16]);
    if (w >= 4) pool.push(["piercer", 16]);
    if (w >= 6) pool.push(["bruiser", 12]);
    if (w >= 6) pool.push(["bomber", 14]);
    if (w >= 8) pool.push(["disruptor", 12]);

    if (w >= 7) pool.push(["supporter", 12]);
    // boss wave: íŠ¹ìˆ˜ ëª¹ ë¹„ì¤‘ ì¦ê°€
    if (spec.isBoss) {
      for (let i=0;i<pool.length;i++) pool[i][1] *= (pool[i][0]==="grunt" ? 0.55 : 1.25);
    }

    // theme wave: í…Œë§ˆë³„ ê°€ì¤‘ì¹˜ ì¡°ì •(ì²´ê°ìš©, ê³¼í•˜ì§€ ì•Šê²Œ)
    if (spec.themeKey === "rush") {
      for (let i=0;i<pool.length;i++){
        const id = pool[i][0];
        if (id==="runner") pool[i][1] *= 2.4;
        else if (id==="piercer") pool[i][1] *= 1.35;
        else if (id==="shooter") pool[i][1] *= 0.75;
        else if (id==="bruiser") pool[i][1] *= 0.55;
      }
    } else if (spec.themeKey === "siege") {
      for (let i=0;i<pool.length;i++){
        const id = pool[i][0];
        if (id==="bruiser") pool[i][1] *= 2.3;
        else if (id==="grunt") pool[i][1] *= 0.85;
        else if (id==="runner") pool[i][1] *= 0.55;
      }
    } else if (spec.themeKey === "bomb") {
      for (let i=0;i<pool.length;i++){
        const id = pool[i][0];
        if (id==="bomber") pool[i][1] *= 2.1;
        else if (id==="shieldbreaker") pool[i][1] *= 1.45;
      }
    } else if (spec.themeKey === "swarm") {
      for (let i=0;i<pool.length;i++){
        const id = pool[i][0];
        if (id==="grunt") pool[i][1] *= 1.55;
        else if (id==="runner") pool[i][1] *= 2.6;
        else if (id==="bruiser") pool[i][1] *= 0.45;
        else if (id==="shooter") pool[i][1] *= 0.75;
      }
    } else if (spec.themeKey === "sniper") {
      for (let i=0;i<pool.length;i++){
        const id = pool[i][0];
        if (id==="shooter") pool[i][1] *= 2.35;
        else if (id==="piercer") pool[i][1] *= 1.65;
        else if (id==="bruiser") pool[i][1] *= 0.70;
        else if (id==="runner") pool[i][1] *= 0.70;
      }
    }

    let sum = 0; for (const [,wgt] of pool) sum += wgt;
    let r = Math.random()*sum;
    for (const [id,wgt] of pool) { r -= wgt; if (r <= 0) return id; }
    return "grunt";
  }

  function resetMods(){
    state.mods.shieldAbsorbMul = 1;
    state.mods.shieldRegenMul  = 1;
    state.mods.turretDmgMul    = 1;
    state.mods.turretProjMul   = 1;
    state.mods.turretFireMul   = 1;
    state.mods.rewardMul       = 1;
    state.mods.enemyHpMul      = 1;
    state.mods.enemySpdMul     = 1;
    state.mods.enemyShieldMul  = 1;
    state.mods.enemyGrantShieldMul = 0;
  }

  // ===== Map Gimmicks (run modifier) =====
  const MAP_DEFS = {
    sanctuary: { id:"sanctuary", name:"ì„±ì—­", desc:"ë³´í˜¸ë§‰ ì¬ìƒ +10%", shieldRegenMul:1.10, enemySpdMul:1.00, turretRangeMul:1.00, rewardMul:1.00 },
    void:      { id:"void",      name:"ê³µí—ˆ", desc:"EMP ì´ë²¤íŠ¸ ë¹ˆë„â†‘ Â· ë³´ìƒ +8%", shieldRegenMul:1.00, enemySpdMul:1.00, turretRangeMul:1.00, rewardMul:1.08, empBias:2 },
    wasteland: { id:"wasteland", name:"í™©ë¬´ì§€", desc:"ì  ì†ë„ +8% Â· í¬íƒ‘ ì‚¬ê±°ë¦¬ +8%", shieldRegenMul:1.00, enemySpdMul:1.08, turretRangeMul:1.08, rewardMul:1.04 },
  };
  const MAP_LIST = [MAP_DEFS.sanctuary, MAP_DEFS.void, MAP_DEFS.wasteland];

  function mapById(id){
    return MAP_DEFS[id] || MAP_DEFS.sanctuary;
  }

  let __mapUiLastId = null;
  function refreshMapUI(force=false){
    if (!uiMap) return;
    const id = (state.mapId || (state.map && state.map.id) || "sanctuary");
    if (!force && id === __mapUiLastId) return;
    __mapUiLastId = id;
    const m = mapById(id);
    state.map = m;
    if (uiMapBonus) uiMapBonus.textContent = `Ã—${(m.rewardMul||1).toFixed(2)}`;
    uiMap.innerHTML = `<b>${m.name}</b> â€” ${m.desc}`;
  }

  function rollMapForRun(){
    const pick = MAP_LIST[Math.floor(Math.random()*MAP_LIST.length)];
    state.mapId = pick.id;
    state.map = pick;
    __mapUiLastId = null;
  }

  function applyMapVisual(){
    try {
      const cls = document.body.classList;
      cls.remove('map-sanctuary','map-void','map-wasteland');
      cls.add('map-' + (state.mapId || 'sanctuary'));
    } catch(e) {}
  }

  function applyMapModsForWave(){
    const m = state.map || mapById(state.mapId);
    state.map = m;
    if (!m) return;
    if (m.shieldRegenMul) state.mods.shieldRegenMul *= m.shieldRegenMul;
    if (m.enemySpdMul)    state.mods.enemySpdMul    *= m.enemySpdMul;
    if (m.rewardMul)      state.mods.rewardMul      *= m.rewardMul;
  }
  // ===== End Map Gimmicks =====
  function chooseEvent(){
    if (state.wave % 3 !== 0) return null;
    const mid = (state.mapId || (state.map && state.map.id) || 'sanctuary');
    if (mid === 'void') {
      // ê³µí—ˆ: EMP ì´ë²¤íŠ¸ í™•ë¥ â†‘
      const pool = EVENTS.slice();
      const emp = EVENTS.find(e=>e.id==='emp_storm');
      if (emp) { pool.push(emp, emp); }
      return pool[Math.floor(Math.random()*pool.length)];
    }
    return EVENTS[Math.floor(Math.random()*EVENTS.length)];
  }
  // ---------- Emergency barrier ----------
  function tryAegis(){
    if (state.phase === "fail") return;
    const t = gameSec();
    if (t < state.core.aegisReadyAt) return;

    state.core.aegisReadyAt = t + state.core.aegisCd;
    state.core.aegisActiveUntil = t + 3.0;
    state.core.shield = clamp(state.core.shield + 90, 0, state.core.shieldMax);

    SFX.play("aegis");

    fxText("ê¸´ê¸‰ ë³´í˜¸ë§‰!", CORE_POS.x, CORE_POS.y - 64, "#93c5fd");
    fxShieldWave(CORE_POS.x, CORE_POS.y, CORE_RADIUS + 18);
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, 120, "#60a5fa");

    // ì„ê³„ ê³¼ë¶€í•˜ ì—°ê³„: ë‹¤ìŒ ë²„ìŠ¤íŠ¸/ì‡¼í¬ ì¿¨ -6s (20s ICD)
    overloadOnAegis();
  }

  
  function tryRepair(){
    if (state.phase === "fail") return;

    const t = gameSec();
    const hpFracBefore = (state.core.hpMax>0) ? (state.core.hp / state.core.hpMax) : 1;
    const cdLeft = Math.max(0, state.core.repairReadyAt - t);

    const blockLeft = Math.max(0, (state.core.repairBlockedUntil||0) - t);
    if (blockLeft > 0) {
      fxText(`ìˆ˜ë¦¬ ì°¨ë‹¨ ${blockLeft.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#fbbf24");
      SFX.play("click");
      return;
    }

    if (cdLeft > 0) {
      fxText(`ìˆ˜ë¦¬ ì¿¨ë‹¤ìš´ ${cdLeft.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#ffd166");
      SFX.play("click");
      return;
    }
    if (state.core.hp >= state.core.hpMax - 0.01) {
      fxText("HPê°€ ì´ë¯¸ ê°€ë“í•©ë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
      SFX.play("click");
      return;
    }
    if (state.crystals < state.core.repairCost) {
      fxText("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#ff9fb2");
      SFX.play("click");
      return;
    }

    state.crystals -= state.core.repairCost;
    state.stats.repairs = (state.stats.repairs|0) + 1;

    const want = state.core.repairAmount;
    const heal = Math.min(want, state.core.hpMax - state.core.hp);
    state.core.hp = clamp(state.core.hp + heal, 0, state.core.hpMax);

    state.core.repairReadyAt = t + state.core.repairCd;

    SFX.play("repair");
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+90, "#67f3a6");
    fxText(`ìˆ˜ë¦¬ +${(heal|0)}`, CORE_POS.x, CORE_POS.y - 64, "#67f3a6");

    // ì„ê³„ ê³¼ë¶€í•˜ ì—°ê³„(HP<=40% í‘œì‹/ë²„ìŠ¤íŠ¸ ì—°ì¥)
    overloadOnRepair(hpFracBefore);
  }

// (11) ë°©ì–´ì„ : ë°©ë²½(1ì´ˆ) â€” ì½”ì–´ í”¼í•´ ë¬´íš¨
function tryBarrier(){
  if (state.phase === "fail" || state.phase === "win") return;

  // ë°©ë²½ì€ ì „íˆ¬(ì›¨ì´ë¸Œ) ì¤‘ì—ë§Œ ì‚¬ìš©
  if (state.phase !== "wave") {
    fxText("ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
    try{ SFX.play("click"); }catch{}
    return;
  }

  const t = gameSec();
  const cdLeft = Math.max(0, (state.core.barrierReadyAt||0) - t);

  // ë§Œë£Œ ì •ë¦¬
  if (state.core.barrierActive && t >= (state.core.barrierUntil||0)) {
    state.core.barrierActive = false;
  }

  if (state.core.barrierActive) {
    const left = Math.max(0, (state.core.barrierUntil||0) - t);
    fxText(`ë°©ë²½ ${left.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (cdLeft > 0.05) {
    fxText(`ë°©ë²½ ì¿¨ë‹¤ìš´ ${cdLeft.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#ffd166");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (state.crystals < BARRIER_COST) {
    fxText("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#ff9fb2");
    try{ SFX.play("click"); }catch{}
    return;
  }

  state.crystals -= BARRIER_COST;
  state.core.barrierActive = true;
  state.core.barrierUntil = t + 1.0;
  state.core.barrierReadyAt = t + BARRIER_CD;

  fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+12, CORE_RADIUS+120, "#93c5fd");
  fxText("ë°©ë²½!", CORE_POS.x, CORE_POS.y - 64, "#93c5fd");
  try{ SFX.play("shield"); }catch{ try{ SFX.play("click"); }catch{} }
}

// (12) ìƒì  ì†Œë¹„ ì•„ì´í…œ: ì¦‰ì‹œ ìˆ˜ë¦¬
function useShopItemRepair(){
  if (state.phase === "fail" || state.phase === "win") return;

  const t = gameSec();
  const cdLeft = Math.max(0, (state.shop.repairReadyAt||0) - t);
  const blockLeft = Math.max(0, (state.core.repairBlockedUntil||0) - t);

  if (blockLeft > 0) {
    fxText(`ìˆ˜ë¦¬ ì°¨ë‹¨ ${blockLeft.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#fbbf24");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (cdLeft > 0) {
    fxText(`ì•„ì´í…œ ì¿¨ë‹¤ìš´ ${cdLeft.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#ffd166");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (state.core.hp >= state.core.hpMax - 0.01) {
    fxText("HPê°€ ì´ë¯¸ ê°€ë“í•©ë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (state.crystals < SHOP_ITEM_REPAIR_COST) {
    fxText("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#ff9fb2");
    try{ SFX.play("click"); }catch{}
    return;
  }

  const hpFracBefore = (state.core.hpMax>0) ? (state.core.hp / state.core.hpMax) : 1;

  state.crystals -= SHOP_ITEM_REPAIR_COST;
  const missing = Math.max(0, state.core.hpMax - state.core.hp);
  const want = Math.max(SHOP_ITEM_REPAIR_MIN, missing * SHOP_ITEM_REPAIR_MISS);
  const heal = Math.min(want, missing);
  state.core.hp = clamp(state.core.hp + heal, 0, state.core.hpMax);

  state.shop.repairReadyAt = t + SHOP_ITEM_REPAIR_CD;

  try{ SFX.play("repair"); }catch{ try{ SFX.play("click"); }catch{} }
  fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+98, "#67f3a6");
  fxText(`ì¦‰ì‹œ ìˆ˜ë¦¬ +${(heal|0)}`, CORE_POS.x, CORE_POS.y - 64, "#67f3a6");

  // ì„ê³„ ê³¼ë¶€í•˜ ì—°ê³„(ê¸°ì¡´ ìˆ˜ë¦¬ ë²„íŠ¼ê³¼ ë™ì¼)
  overloadOnRepair(hpFracBefore);
}

// (12) ìƒì  ì†Œë¹„ ì•„ì´í…œ: ê³µì† 10ì´ˆ
function useShopItemFire(){
  if (state.phase === "fail" || state.phase === "win") return;

  const t = gameSec();
  const cdLeft = Math.max(0, (state.shop.fireReadyAt||0) - t);
  if (state.phase !== "wave") {
    fxText("ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (cdLeft > 0) {
    fxText(`ì•„ì´í…œ ì¿¨ë‹¤ìš´ ${cdLeft.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#ffd166");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (state.crystals < SHOP_ITEM_FIRE_COST) {
    fxText("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#ff9fb2");
    try{ SFX.play("click"); }catch{}
    return;
  }

  state.crystals -= SHOP_ITEM_FIRE_COST;
  state.shop.fireReadyAt = t + SHOP_ITEM_FIRE_CD;
  state.shop.fireUntil = t + SHOP_ITEM_FIRE_DUR;

  fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+16, CORE_RADIUS+140, "#fcd34d");
  fxText(`ê³µì† ì¦ê°€! Ã—${SHOP_ITEM_FIRE_MUL.toFixed(2)}`, CORE_POS.x, CORE_POS.y - 64, "#fcd34d");
  try{ SFX.play("click"); }catch{}
}

// (12) ìƒì  ì†Œë¹„ ì•„ì´í…œ: 1 ì›¨ì´ë¸Œ ìŠ¬ë¡œìš°
function useShopItemSlow(){
  if (state.phase === "fail" || state.phase === "win") return;

  const t = gameSec();
  const cdLeft = Math.max(0, (state.shop.slowReadyAt||0) - t);
  if (state.phase !== "wave") {
    fxText("ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (state.shop.slowWave === state.wave) {
    fxText("ì´ë²ˆ ì›¨ì´ë¸ŒëŠ” ì´ë¯¸ ìŠ¬ë¡œìš° ì ìš© ì¤‘", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (cdLeft > 0) {
    fxText(`ì•„ì´í…œ ì¿¨ë‹¤ìš´ ${cdLeft.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#ffd166");
    try{ SFX.play("click"); }catch{}
    return;
  }
  if (state.crystals < SHOP_ITEM_SLOW_COST) {
    fxText("ìì›ì´ ë¶€ì¡±í•©ë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#ff9fb2");
    try{ SFX.play("click"); }catch{}
    return;
  }

  state.crystals -= SHOP_ITEM_SLOW_COST;
  state.shop.slowReadyAt = t + SHOP_ITEM_SLOW_CD;
  state.shop.slowWave = state.wave;

  fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+16, CORE_RADIUS+140, "#a7f3d0");
  fxText(`ìŠ¬ë¡œìš° ì›¨ì´ë¸Œ! Ã—${SHOP_ITEM_SLOW_MUL.toFixed(2)}`, CORE_POS.x, CORE_POS.y - 64, "#a7f3d0");
  try{ SFX.play("click"); }catch{}
}


    function pickEnergyTarget(){
    if (!state.enemies) return null;

    // ìš°ì„ ìˆœìœ„: ë³´ìŠ¤(kind==="boss") â†’ ê·¸ ë‹¤ìŒ í˜„ì¬ HP ìµœëŒ€
    let target = null;
    let bestHp = -1;

    for (const e of state.enemies) {
      if (!e || e.hp <= 0) continue;
      if (e.kind === "boss") {
        if (e.hp > bestHp) { bestHp = e.hp; target = e; }
      }
    }
    if (!target) {
      bestHp = -1;
      for (const e of state.enemies) {
        if (!e || e.hp <= 0) continue;
        if (e.hp > bestHp) { bestHp = e.hp; target = e; }
      }
    }
    return target;
  }

  function updateEnergyCharge(){
    if (!state.core.energyCharging) return;

    // ì›¨ì´ë¸Œê°€ ì•„ë‹ˆë©´ ì¶©ì „ ì·¨ì†Œ
    if (state.phase !== "wave") {
      state.core.energyCharging = false;
      state.core.energyLock = null;
      state.core.energyChargeOrbs = [];
      state.core.energyChargeReadySfx = false;
      state.core.energyFlashUntil = 0;
      return;
    }

    const t = gameSec();
    const dur = state.core.energyChargeDur || 3.0;
    const rem = state.core.energyChargeUntil - t;
    const prog = clamp(1 - (rem / dur), 0, 1);

    // dt(í”„ë ˆì„ ê°„ê²©)
    const lastT = state.core.energyChargeLastT || t;
    const dt = clamp(t - lastT, 0, 0.05);
    state.core.energyChargeLastT = t;

    // --- ì½”ì–´ë¡œ ë¹¨ë ¤ë“œëŠ” ì˜¤ë¸Œ(ë¹›) ---
    if (!state.core.energyChargeOrbs) state.core.energyChargeOrbs = [];
    if (t >= (state.core.energyChargeOrbAt || 0)) {
      // í›„ë°˜ìœ¼ë¡œ ê°ˆìˆ˜ë¡ ë” ì´˜ì´˜í•˜ê²Œ
      const interval = lerp(0.12, 0.045, prog);
      state.core.energyChargeOrbAt = t + interval;

      const a = Math.random() * Math.PI * 2;
      const r = lerp(170, 110, prog) + (Math.random()*26);
      const life = lerp(0.58, 0.34, prog);
      state.core.energyChargeOrbs.push({ a, r, t:0, life });
    }

    // ì˜¤ë¸Œ ì´ë™/ì†Œë©¸
    const orbs = state.core.energyChargeOrbs;
    for (let i = orbs.length - 1; i >= 0; i--) {
      const o = orbs[i];
      o.t += dt;
      o.r -= (lerp(260, 520, prog)) * dt;
      // ì•½ê°„ì˜ í”ë“¤ë¦¼(ì—ë„ˆì§€ ë¶ˆì•ˆì •)
      o.a += (0.9 + 1.6*prog) * dt * (Math.random() < 0.5 ? -1 : 1);

      if (o.t >= o.life || o.r <= 6) orbs.splice(i, 1);
    }

    // --- ë½ì˜¨ íƒ€ê²Ÿ ìœ ì§€(ì£½ì—ˆìœ¼ë©´ ì¬íƒìƒ‰) ---
    let lock = state.core.energyLock;
    if (!lock || lock.hp <= 0 || !(state.enemies && state.enemies.includes(lock))) {
      lock = pickEnergyTarget();
      state.core.energyLock = lock;
    }

    // --- ì¶©ì „ ì‚¬ìš´ë“œ: ì§„í–‰ë„ì— ë”°ë¼ ì ì  ì´˜ì´˜í•˜ê³  ë†’ì€ í†¤ ---
    if (t >= (state.core.energyChargeSfxAt || 0)) {
      const interval = lerp(0.34, 0.12, prog);
      state.core.energyChargeSfxAt = t + interval;

      if (prog < 0.40) SFX.play("y_charge1");
      else if (prog < 0.75) SFX.play("y_charge2");
      else SFX.play("y_charge3");
    }

    // ë°œì‚¬ ì§ì „(ê±°ì˜ ì™„ì¶©) ì‚¬ìš´ë“œ 1íšŒ
    if (prog >= 0.92 && !state.core.energyChargeReadySfx) {
      state.core.energyChargeReadySfx = true;
      SFX.play("y_charge_ready");
    }

    // ì¶©ì „ ì¤‘ ì´í™íŠ¸(ê³¼ë„í•œ ìƒì„± ë°©ì§€) â€” íƒ€ê²Ÿ ë¼ì¸/ë§ì€ FXë¡œ ìœ ì§€
    if (t >= (state.core.energyChargeFxAt || 0)) {
      state.core.energyChargeFxAt = t + 0.18; // ì•½ 5~6íšŒ/ì´ˆ

      const r0 = CORE_RADIUS + 8 + prog*6;
      const r1 = CORE_RADIUS + 54 + prog*92;
      fxRing(CORE_POS.x, CORE_POS.y, r0, r1, "#93c5fd");

      if (lock && lock.hp > 0) {
        fxRing(lock.x, lock.y, 12, 46, "#93c5fd");
        fxLine(CORE_POS.x, CORE_POS.y, lock.x, lock.y, "#93c5fd", 0.16, 2.2);
      }
    }

    // 3ì´ˆ(ë˜ëŠ” ì„¤ì •ê°’) í›„ ìë™ ë°œì‚¬ â€” ì½”ì–´ê°€ ê°€ì¥ ë°ì•„ì§€ëŠ” ìˆœê°„
    if (rem <= 0) fireEnergyCannon();
  }

  function fireEnergyCannon(){
    const t = gameSec();

    // ë°œì‚¬ ìˆœê°„ ë¯¸ì„¸ ì¹´ë©”ë¼ í”ë“¤ë¦¼(ì§§ê²Œ)
    state.camShakeDur = 0.12;
    state.camShakeMag = 6.0;
    state.camShakeUntil = t + state.camShakeDur;

    // ë°œì‚¬ ìˆœê°„: ì½”ì–´ê°€ ê°€ì¥ ë°ì•„ì§€ëŠ” í”Œë˜ì‹œ
    state.core.energyFlashUntil = t + 0.16;

    // ë½ì˜¨ íƒ€ê²Ÿì´ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì¬íƒìƒ‰
    let target = state.core.energyLock;
    if (!target || target.hp <= 0 || !(state.enemies && state.enemies.includes(target))) {
      target = pickEnergyTarget();
    }

    // ì¶©ì „ ìƒíƒœ ì¢…ë£Œ
    state.core.energyCharging = false;
    state.core.energyLock = null;

    if (!target) {
      SFX.play("click");
      fxText("ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
      return;
    }

    const dmg = (state.core.energyDmg || 800) * (1 + Math.max(0, state.wave-1)*0.018);
    target.hp -= dmg;

    // ì˜¤ë²„ë“œë¼ì´ë¸Œ íŒ¨ì‹œë¸Œ: ì—ë„ˆì§€í¬ê°€ ê´‘ì—­ í”¼í•´(30%)ë¥¼ ì¶”ê°€ë¡œ ì…í˜
    if (state.core.passiveId === "overdrive") {
      const splashMul = passiveScale(0.30);
      const splashDmg = dmg * splashMul;
      const rad = 120 * passiveHardMul();
      let hitN = 0;

      if (state.enemies && state.enemies.length) {
        for (const e of state.enemies) {
          if (!e || e === target || e.hp <= 0) continue;
          const d = dist(e.x, e.y, target.x, target.y);
          if (d <= rad + (e.r||0)) {
            e.hp -= splashDmg;
            hitN++;
          }
        }
      }

      if (hitN > 0) {
        fxRing(target.x, target.y, 26, rad, "#c4b5fd");
        fxText(`ì˜¤ë²„ë“œë¼ì´ë¸Œ ê´‘ì—­ x${hitN}`, target.x, target.y - 40, "#c4b5fd");
        try { SFX.play("shield_hit"); } catch {}
      }
    }

    // ì•¼ë§ˆí† í¬ ìŠ¤íƒ€ì¼ ë¹”(êµµì€ ì½”ì–´ + í•˜ì´ë¼ì´íŠ¸)
    fxLine(CORE_POS.x, CORE_POS.y, target.x, target.y, "#93c5fd", 0.26, 16);
    fxLine(CORE_POS.x, CORE_POS.y, target.x, target.y, "#cbe6ff", 0.22, 7);
    fxLine(CORE_POS.x, CORE_POS.y, target.x, target.y, "rgba(255,255,255,0.85)", 0.14, 2.2);

    // ë°œì‚¬ ì‡¼í¬(ì½”ì–´/íƒ€ê²Ÿ)
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+8, CORE_RADIUS+140, "#93c5fd");
    fxRing(target.x, target.y, 14, 92, "#93c5fd");
    fxRing(target.x, target.y, 10, 64, "#cbe6ff");

    fxText(`-${Math.round(dmg)}`, target.x, target.y - 18, "#93c5fd");
    SFX.play("y_fire");

    // ì¿¨íƒ€ì„ì€ ë°œì‚¬ ì‹œì ë¶€í„°
    state.core.energyReadyAt = t + state.core.energyCd;
  }

  function tryEnergyCannon(){
    if (state.phase === "fail") return;

    const t = gameSec();

    // ì´ë¯¸ ì¶©ì „ ì¤‘ì´ë©´ ì•ˆë‚´ë§Œ
    if (state.core.energyCharging) {
      const rem = Math.max(0, state.core.energyChargeUntil - t);
      fxText(`ì—ë„ˆì§€í¬ ì¶©ì „ì¤‘ ${rem.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
      SFX.play("click");
      return;
    }

    const cdLeft = Math.max(0, state.core.energyReadyAt - t);

    if (state.phase !== "wave") {
      fxText("ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ ì‚¬ìš© ê°€ëŠ¥", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
      SFX.play("click");
      return;
    }
    if (cdLeft > 0) {
      fxText(`ì—ë„ˆì§€í¬ ì¿¨ë‹¤ìš´ ${cdLeft.toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 70, "#ffd166");
      SFX.play("click");
      return;
    }

    const target = pickEnergyTarget();
    if (!target) {
      fxText("ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
      SFX.play("click");
      return;
    }

    // âœ… ëˆ„ë¥´ë©´ ì•½ 3ì´ˆ ì¶©ì „ í›„ ìë™ ë°œì‚¬ (SC2 ì•¼ë§ˆí† í¬ ëŠë‚Œ)
    state.core.energyCharging = true;
    state.core.energyChargeStartAt = t;
    state.core.energyChargeUntil = t + (state.core.energyChargeDur || 3.0);
    state.core.energyChargeFxAt = t; // ì¦‰ì‹œ ì´í™íŠ¸ 1íšŒ
    state.core.energyLock = target;

    // ì¶©ì „ ì‹œì‘ ì‚¬ìš´ë“œ(í´ë¦­ ëŒ€ì‹  ì§‘ì† ì‚¬ìš´ë“œ)
    SFX.play("y_charge1");

    // ì¶©ì „ ì¤‘ ì‚¬ìš´ë“œ/ì—°ì¶œ ìƒíƒœ ì´ˆê¸°í™”
    state.core.energyChargeSfxAt = t + 0.18;
    state.core.energyChargeReadySfx = false;
    state.core.energyChargeOrbAt = t;
    state.core.energyChargeOrbs = [];
    state.core.energyChargeLastT = t;

    fxText("ì—ë„ˆì§€ ì§‘ì†â€¦", CORE_POS.x, CORE_POS.y - 70, "#93c5fd");
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+6, CORE_RADIUS+70, "#93c5fd");
    fxRing(target.x, target.y, 10, 46, "#93c5fd");
  }



// ---------- Spawning ----------
  function spawnEnemy(spec, idx){
    const isMainBoss = !!(spec && spec.isBoss) && ((idx||0)===0);
    if (!isMainBoss && state.enemies.length >= enemyCap()) return;
    const side = (Math.random()*4)|0;
    const pad = 26;
    let x,y;
    if (side===0){ x = rand(pad, W-pad); y = -pad; }
    if (side===1){ x = W+pad; y = rand(pad, H-pad); }
    if (side===2){ x = rand(pad, W-pad); y = H+pad; }
    if (side===3){ x = -pad; y = rand(pad, H-pad); }

        const id = pickEnemyId(state.wave, spec, idx||0);
    const arch = ENEMY_ARCH[id] || ENEMY_ARCH.grunt;

    const diff = state.diff || DIFF_PRESETS.normal;

    // Difficulty multipliers (per spec: normal/boss/final)
    const isBossSpec = !!(spec && spec.isBoss);
    const isFinalBossSpawn = (state.wave === FINAL_WAVE && isBossSpec && id === "boss" && ((idx||0) === 0));

    let diffHpMul = (diff.hpMul||1), diffSpdMul = (diff.spdMul||1);
    let diffPatternMul = 1.0;
    let diffRewardMul = (diff.rewardMul||1);
    if (isBossSpec) {
      diffHpMul = (diff.bossHpMul||diffHpMul);
      diffSpdMul = (diff.bossSpdMul||diffSpdMul);
      diffPatternMul = (diff.bossPatternMul||diffPatternMul);
      diffRewardMul = (diff.bossRewardMul||diffRewardMul);
    }
    if (isFinalBossSpawn) {
      diffHpMul = (diff.finalHpMul||diffHpMul);
      diffSpdMul = (diff.finalSpdMul||diffSpdMul);
      diffPatternMul = (diff.finalPatternMul||diffPatternMul);
      diffRewardMul = (diff.finalRewardMul||diffRewardMul);
    }


    const baseEliteChance = (state.wave < 4) ? 0 : (spec.isBoss ? 0.22 : (0.03 + Math.min(0.07, Math.max(0, state.wave - 4) * 0.002)));
    const eliteChance = clamp(baseEliteChance + ((state.wave >= 4) ? (diff.eliteAdd||0) : 0), 0, 0.95);
    const elite = (id !== "boss") && Math.random() < eliteChance;
    const eliteKind = elite ? (
      (id === "runner" || id === "shieldrunner") ? "runner" :
      (id === "warden") ? "warden" :
      (id === "disruptor") ? "disruptor" :
      "generic"
    ) : null;

    // Elite per-kind tuning
    let eliteRmul = 1.0, eliteHpMul = 1.0, eliteSpdMul = 1.0, eliteRewardMul = 1.0;
    if (elite) { eliteRmul = 1.15; eliteHpMul = 1.60; eliteSpdMul = 0.95; eliteRewardMul = 1.35; }
    if (eliteKind === "runner")    { eliteHpMul = 1.45; eliteSpdMul = 1.35; eliteRewardMul = 1.40; }
    if (eliteKind === "warden")    { eliteHpMul = 1.75; eliteSpdMul = 0.90; eliteRewardMul = 1.45; }
    if (eliteKind === "disruptor") { eliteHpMul = 1.65; eliteSpdMul = 0.92; eliteRewardMul = 1.45; }

    const r = (arch.r || 12) * eliteRmul;
    const hp = spec.hp * arch.hpMul * eliteHpMul * diffHpMul * (state.mods.enemyHpMul||1);
    const spd = spec.spd * arch.spdMul * eliteSpdMul * (0.92 + 0.16*Math.random()) * diffSpdMul * (state.mods.enemySpdMul||1);
// ì›¨ì´ë¸Œê°€ ì˜¤ë¥¼ìˆ˜ë¡ "ìœ„ë ¥(í”¼í•´)"ë„ ìƒìŠ¹
    // - ë„ˆë¬´ ê°€íŒŒë¥´ì§€ ì•Šê²Œ ì„ í˜• ì¦ê°€ (ì›í•˜ë©´ 0.06 ê°’ì„ ì¡°ì ˆ)
    const dmgMul = (1 + Math.max(0, state.wave - 1) * 0.06) * (spec.isBoss ? 1.15 : 1.0);

        const eObj = {
          x,y, hp, hpMax: hp, spd, r,
          kind: id,
          color: arch.color,
          seedAng: Math.random()*Math.PI*2,
          orbitDir: (Math.random()<0.5 ? -1 : 1),
          reward: arch.reward * eliteRewardMul,
          diffRewardMul: diffRewardMul,
          slowMul: 1.0, slowUntil: 0,
          touchCd: 0,
          touchBase: arch.touchDmg * dmgMul,
          touchInterval: arch.touchCd,
          ranged: !!arch.ranged,
          bomber: !!arch.bomber,
          explodeDmg: (arch.explodeDmg||0) * dmgMul,
          explodeRad: arch.explodeRad||0,
          turretBreakChance: arch.turretBreakChance||0,
          shootRange: arch.shootRange||0,
          holdDist: arch.holdDist||0,
          shotCd: (arch.shotCd||0) * diffPatternMul,
          shotTimer: rand(0.15, arch.shotCd||0.8),
          projDmg: (arch.projDmg||0) * dmgMul,
          projSpd: arch.projSpd||0,
          coreOpts: (arch.coreOpts ? ({...arch.coreOpts}) : null),
          elite,

          eliteKind,

          eliteColor: (eliteKind === "runner") ? "#fb7185" : (eliteKind === "warden") ? "#60a5fa" : (eliteKind === "disruptor") ? "#f59e0b" : (elite ? "#fbbf24" : null),
          // visuals
          drawR: r
        };

        // Wave 30 final boss: keep gameplay hitbox (r) but render bigger + special styling
        if (isFinalBossSpawn) {
          eObj.isFinalBoss = true;



          
          // gameplay buffs (rollback): Wave 30 final boss
          // (HPÃ—2.05 / í”¼í•´Ã—1.25 / ë°œì‚¬ì¿¨Ã—0.82 / ì ‘ì´‰Ã—1.25 / ì†ë„Ã—1.10)
          // NOTE: Hard ëª¨ë“œì—ì„œë§Œ HP ë²„í”„ë¥¼ 2.30ìœ¼ë¡œ ìƒí–¥ ì ìš©.
          const fbHpMul = (state && state.diffId === "hard") ? 2.30 : 2.05;
          const fbDmgMul = 1.25;
          const fbSpdMul = 1.10;
          const fbShotCdMul = 0.82;
          const fbTouchMul = 1.25;

          eObj.hpMax *= fbHpMul;
          eObj.hp *= fbHpMul;
          eObj.spd *= fbSpdMul;

          eObj.projDmg *= fbDmgMul;
          eObj.explodeDmg *= fbDmgMul;
          eObj.touchBase *= fbTouchMul;

          if (eObj.shotCd > 0) {
            eObj.shotCd *= fbShotCdMul;
            eObj.shotTimer *= fbShotCdMul;
          }
// visuals
          eObj.drawR = r * 2.00;
          eObj.color = "#a855f7"; // violet
        } else {
          eObj.isFinalBoss = false;
        }

        // difficulty pattern cooldown (boss/final only)
        if (diffPatternMul !== 1.0 && eObj.shotCd > 0) {
          eObj.shotCd *= diffPatternMul;
          eObj.shotTimer *= diffPatternMul;
        }

        // enemy shield(ì¼ë¶€ ì  ì „ìš©)
        const shMul = arch.shieldMul || 0;
        if (shMul > 0) {
          eObj.shieldMax = eObj.hpMax * shMul;
          eObj.shield = eObj.shieldMax;
        } else {
          eObj.shieldMax = 0;
          eObj.shield = 0;
        }

    // Elite kind extras
    if (elite) {
      if (eliteKind === "warden" && eObj.shieldMax > 0) {
        eObj.shieldMax *= 1.55;
        eObj.shield *= 1.55;
      }
      if (eliteKind === "disruptor" && eObj.coreOpts) {
        const kMul = 1.45;
        if (eObj.coreOpts.shieldRegenBlockDur) eObj.coreOpts.shieldRegenBlockDur *= kMul;
        if (eObj.coreOpts.repairBlockDur) eObj.coreOpts.repairBlockDur *= kMul;
        if (eObj.coreOpts.empDur) eObj.coreOpts.empDur *= kMul;
      }
    }


        // ìœ„í—˜ ê³„ì•½: ì  ë³´í˜¸ë§‰ ê°•í™”/ë¶€ì—¬
        try {
          const _shMul = (state.mods.enemyShieldMul||1);
          const _grant = (state.mods.enemyGrantShieldMul||0);
          if (eObj.shieldMax > 0) {
            eObj.shieldMax *= _shMul;
            eObj.shield = eObj.shieldMax;
          } else if (_grant > 0) {
            eObj.shieldMax = eObj.hpMax * _grant;
            eObj.shield = eObj.shieldMax;
          }
        } catch(e) {}
    // ì‹¤ë“œ ì„œí¬í„°: ì£¼ë³€ ì ì—ê²Œ ì–‡ì€ ì‹¤ë“œ ë¶€ì—¬/ì¬ì¶©ì „
    if (id === "supporter") {
      eObj.supportCd = arch.supportCd || 1.80;
      eObj.supportTimer = rand(0.25, eObj.supportCd);
      eObj.supportR = arch.supportR || 170;
      eObj.supportMul = arch.supportMul || 0.18;
      eObj.supportMulBoss = arch.supportMulBoss || 0.10;
      eObj.supportFx = 0;
    }



state.enemies.push(eObj);
  }
// ---------- Final boss helpers ----------
function finalBossIncomingMul(){
  // ì›¨ì´ë¸Œ30 ìµœì¢…ë³´ìŠ¤ ì „ìš©: ë•ì¹ (í¬íƒ‘ ê°œìˆ˜) ê¸°ë°˜ ë‚´ì„±ë§Œ ì ìš© (ì—…ê·¸ë ˆì´ë“œ ë‚´ì„± ì œê±°)
  const tc = state.turrets.length;
  const extra = Math.max(0, tc - 10);
  const spamDR = clamp(extra * 0.055, 0, 0.70); // í¬íƒ‘ ë§ì„ìˆ˜ë¡ ìµœëŒ€ 70%ê¹Œì§€ ê°ì‡„
  const mul = 1 - spamDR;
  // ìµœì†Œ í”¼í•´ 22% ë³´ì¥
  return clamp(mul, 0.22, 1.0);
}

// ---------- Expose (Resonance) ----------
function enemyExposeMul(e){
  const t = gameSec();
  if (e && t < (e.resExposeUntil||0)) return 1 + (e.resExposeBonus||0);
  return 1.0;
}
function applyResExpose(e, dur=3.2){
  const t = gameSec();
  const isBoss = (e && (e.kind === 'boss' || e.isFinalBoss));
  const bonus = passiveScale(isBoss ? 0.13 : 0.24);
  e.resExposeBonus = bonus;
  e.resExposeUntil = Math.max(e.resExposeUntil||0, t + dur * passiveHardMul());
}

// ---------- Overload (mark/burst) ----------
function overloadEnsure(){
  const c = state.core;
  if (typeof c.overloadBurstUntil !== 'number') c.overloadBurstUntil = 0;
  if (typeof c.overloadBurstReadyAt !== 'number') c.overloadBurstReadyAt = 0;
  if (typeof c.overloadWasAbove30 !== 'boolean') c.overloadWasAbove30 = true;
  if (typeof c.overloadExtendReadyAt !== 'number') c.overloadExtendReadyAt = 0;
  if (typeof c.overloadKickReadyAt !== 'number') c.overloadKickReadyAt = 0;
}
function overloadBurstActive(){
  overloadEnsure();
  return gameSec() < (state.core.overloadBurstUntil||0);
}
function applyOverloadMark(e, add=1){
  if (!e) return;
  const t = gameSec();
  e.ovMarkStacks = clamp((e.ovMarkStacks||0) + add, 0, OVERLOAD_CFG.markMax);
  e.ovMarkUntil  = Math.max(e.ovMarkUntil||0, t + OVERLOAD_CFG.markDur * passiveHardMul());
}
function overloadMarkBonus(e){
  if (!e) return 0;
  const t = gameSec();
  if (t >= (e.ovMarkUntil||0)) return 0;
  const st = clamp(e.ovMarkStacks||0, 0, OVERLOAD_CFG.markMax);
  if (st <= 0) return 0;
  const isBoss = (e.kind === 'boss') || e.isFinalBoss;
  return st * passiveScale(isBoss ? OVERLOAD_CFG.markBonusBoss : OVERLOAD_CFG.markBonus);
}

function overloadShockBurst(){
  overloadEnsure();
  const t = gameSec();
  state.core.overloadBurstUntil   = t + OVERLOAD_CFG.burstDur * passiveHardMul();
  state.core.overloadBurstReadyAt = t + OVERLOAD_CFG.burstCd;

  // ì—°ì¶œ: ë²„ìŠ¤íŠ¸ ì¹´ë“œ
  try { cineToast("ì„ê³„ ê³¼ë¶€í•˜", `ë²„ìŠ¤íŠ¸ ${Math.round(OVERLOAD_CFG.burstDur * passiveHardMul())}s`, "#fb7185", 1.05); } catch {}

  // Shockwave: knockback + slow
  const R = OVERLOAD_CFG.shockR * passiveHardMul();
  const slowMul = passiveScaleToward1(OVERLOAD_CFG.shockSlowMul);
  for (const e of state.enemies) {
    const dx = e.x - CORE_POS.x, dy = e.y - CORE_POS.y;
    const d = Math.hypot(dx,dy) || 1;
    if (d > R) continue;
    const k = 1 - (d / R);
    const push = (OVERLOAD_CFG.shockKnock * passiveHardMul()) * (0.35 + 0.65*k);
    e.x += (dx/d) * push;
    e.y += (dy/d) * push;
    // slow
    e.slowMul  = Math.min(e.slowMul || 1.0, slowMul);
    e.slowUntil = Math.max(e.slowUntil || 0, t + OVERLOAD_CFG.shockSlowDur * passiveHardMul());
  }

  // FX + camera shake
  fxFlash(CORE_POS.x, CORE_POS.y, 640, 'rgba(251,113,133,1)');
  fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+14, CORE_RADIUS+R, '#fb7185');
  fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+28, CORE_RADIUS+R*0.78, '#fda4af');
  fxText('ì‡¼í¬ì›¨ì´ë¸Œ!', CORE_POS.x, CORE_POS.y - 156, '#fb7185');
  fxText(`ê³¼ë¶€í•˜ ë²„ìŠ¤íŠ¸ ${Math.round(OVERLOAD_CFG.burstDur * passiveHardMul())}s`, CORE_POS.x, CORE_POS.y - 138, '#fda4af');

  state.camShakeUntil = t + 0.14;
  state.camShakeDur   = 0.14;
  state.camShakeMag   = 10;

  try { SFX.play('blast'); } catch {}
  try { SFX.play('shield_hit'); } catch {}
}

function updateOverload(dt){
  if (state.core.passiveId !== 'overload') return;
  overloadEnsure();
  const hpFrac = (state.core.hpMax>0) ? (state.core.hp/state.core.hpMax) : 1;
  const above = hpFrac > OVERLOAD_CFG.triggerHp + 1e-6;
  if (state.core.overloadWasAbove30 && !above) {
    const t = gameSec();
    if (t >= (state.core.overloadBurstReadyAt||0)) {
      overloadShockBurst();
    }
  }
  state.core.overloadWasAbove30 = above;
}

function overloadOnRepair(hpFracBefore){
  if (state.core.passiveId !== 'overload') return;
  overloadEnsure();
  const t = gameSec();

  if (hpFracBefore <= OVERLOAD_CFG.repairMarkHp) {
    const list = state.enemies.slice();
    list.sort((a,b)=>{
      const ap = (a.isFinalBoss?2:(a.kind==='boss'?1:0));
      const bp = (b.isFinalBoss?2:(b.kind==='boss'?1:0));
      if (ap !== bp) return bp - ap;
      return dist(a.x,a.y, CORE_POS.x, CORE_POS.y) - dist(b.x,b.y, CORE_POS.x, CORE_POS.y);
    });
    const n = Math.min(OVERLOAD_CFG.repairMarkTargets, list.length);
    for (let i=0;i<n;i++){
      applyOverloadMark(list[i], OVERLOAD_CFG.repairMarkAdd);
      fxRing(list[i].x, list[i].y, 10, (list[i].r||12)+22, '#fb7185');
    }
    if (n>0) fxText('í‘œì‹ +2', CORE_POS.x, CORE_POS.y - 84, '#fb7185');
  }

  if (t >= (state.core.overloadExtendReadyAt||0) && overloadBurstActive()) {
    const rem = (state.core.overloadBurstUntil||0) - t;
    if (rem > 0 && rem < OVERLOAD_CFG.extendIfRemainLt) {
      state.core.overloadBurstUntil = t + rem + OVERLOAD_CFG.extendAdd * passiveHardMul();
      state.core.overloadExtendReadyAt = t + OVERLOAD_CFG.extendIcd;
      fxText(`ë²„ìŠ¤íŠ¸ ì—°ì¥ +${(OVERLOAD_CFG.extendAdd * passiveHardMul()).toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 104, '#fda4af');
    }
  }
}

function overloadOnAegis(){
  if (state.core.passiveId !== 'overload') return;
  overloadEnsure();
  const t = gameSec();
  if (t < (state.core.overloadKickReadyAt||0)) return;
  state.core.overloadKickReadyAt = t + OVERLOAD_CFG.aegisIcd;
  state.core.overloadBurstReadyAt = Math.max(t, (state.core.overloadBurstReadyAt||0) - OVERLOAD_CFG.aegisCdReduce * passiveHardMul());
  fxText(`ê³¼ë¶€í•˜ ì¿¨ -${(OVERLOAD_CFG.aegisCdReduce * passiveHardMul()).toFixed(1)}s`, CORE_POS.x, CORE_POS.y - 88, '#fb7185');
}


function spawnEnemyForced(id, spec, x, y, elite=false){
  const arch = ENEMY_ARCH[id] || ENEMY_ARCH.grunt;

    const diff = state.diff || DIFF_PRESETS.normal;
  const dmgMul = (1 + Math.max(0, state.wave - 1) * 0.06);
  const r = (arch.r || 12) * (elite ? 1.15 : 1.0);
  const hp = spec.hp * (arch.hpMul||1) * (elite ? 1.8 : 1.0) * (diff.hpMul||1) * (state.mods.enemyHpMul||1);
  const spd = spec.spd * (arch.spdMul||1) * (elite ? 0.90 : 1.0) * (0.92 + 0.16*Math.random()) * (diff.spdMul||1) * (state.mods.enemySpdMul||1);

  const eObj = {
    x, y,
    hp, hpMax: hp,
    shieldMax: (arch.shieldMul ? (hp*arch.shieldMul) : 0),
    shield: (arch.shieldMul ? (hp*arch.shieldMul) : 0),
    spd, r,
    kind: id,
    color: arch.color || "#f87171",
    seedAng: Math.random()*Math.PI*2,
    orbitDir: (Math.random()<0.5 ? -1 : 1),

    reward: (arch.reward || 12) * (elite ? 1.35 : 1.0),

    slowMul: 1.0,
    slowUntil: 0,

    touchBase: (arch.touchDmg || 9) * dmgMul,
    touchInterval: (arch.touchCd || 0.70),
    touchCd: rand(0.05, arch.touchCd || 0.70),

    ranged: !!arch.ranged,
    bomber: !!arch.bomber,
    explodeDmg: (arch.explodeDmg || 0) * dmgMul,
    explodeRad: arch.explodeRad || 0,
    turretBreakChance: arch.turretBreakChance || 0,

    shootRange: arch.shootRange || 0,
    holdDist: arch.holdDist || 0,
    shotCd: arch.shotCd || 0,
    shotTimer: rand(0.15, arch.shotCd || 0.8),
    projDmg: (arch.projDmg || 0) * dmgMul,
    projSpd: arch.projSpd || 0,
    coreOpts: arch.coreOpts || null,

    elite
  };

  // ìœ„í—˜ ê³„ì•½: ì  ë³´í˜¸ë§‰ ê°•í™”/ë¶€ì—¬
  try {
    const shMul = (state.mods.enemyShieldMul||1);
    const grant = (state.mods.enemyGrantShieldMul||0);
    if (eObj.shieldMax > 0) {
      eObj.shieldMax *= shMul;
      eObj.shield = eObj.shieldMax;
    } else if (grant > 0) {
      eObj.shieldMax = eObj.hpMax * grant;
      eObj.shield = eObj.shieldMax;
    }
  } catch(e) {}

  state.enemies.push(eObj);
}

function spawnEnemyEdgeForced(id, spec, elite=false){
  const side = (Math.random()*4)|0;
  const pad = 26;
  let x,y;
  if (side===0){ x = rand(pad, W-pad); y = -pad; }
  if (side===1){ x = W+pad; y = rand(pad, H-pad); }
  if (side===2){ x = rand(pad, W-pad); y = H+pad; }
  if (side===3){ x = -pad; y = rand(pad, H-pad); }
  spawnEnemyForced(id, spec, x, y, elite);
}

function spawnFinalOrbs(n=3){
  for (let i=0;i<n;i++){
    const side = (Math.random()*4)|0;
    const pad = 30;
    let x,y;
    if (side===0){ x = rand(pad, W-pad); y = -pad; }
    if (side===1){ x = W+pad; y = rand(pad, H-pad); }
    if (side===2){ x = rand(pad, W-pad); y = H+pad; }
    if (side===3){ x = -pad; y = rand(pad, H-pad); }

    const dx = CORE_POS.x - x;
    const dy = CORE_POS.y - y;
    const d = Math.hypot(dx,dy) || 1;
    const sp = 140 + Math.random()*55;
    if (state.projectiles.length >= projCap()) return;
    state.projectiles.push({
      kind:"enemy",
      x, y,
      vx: dx/d * sp,
      vy: dy/d * sp,
      dmg: 18,
      life: 7.0,
      r: 10,
      coreOpts: { shieldArmorPierce: 0.30, hpArmorPierce: 0.10 }
    });
    fxRing(x,y, 8, 60, "#fbbf24");
  }
}

function updateFinalBoss(dt){
  const boss = state.enemies.find(e=>e.kind==="boss");
  if (!boss) return;

  if (!state.final) {
    state.final = {
      phase: 1,
      nextSummonAt: gameSec() + 4.5,
      nextShieldJamAt: gameSec() + 7.0,
      nextLaserAt: gameSec() + 6.0,
      nextEmpAt: gameSec() + 9.0,
      nextOrbsAt: gameSec() + 8.0,
      empUntil: 0,
      empMul: 0.55,
      pending: []
    };
  }
  if (!state.final.pending) state.final.pending = [];

  const t = gameSec();
  const hpFrac = (boss.hpMax>0) ? (boss.hp / boss.hpMax) : 1;
  let phase = 1;
  if (hpFrac <= 0.70) phase = 2;
  if (hpFrac <= 0.35) phase = 3;

  if (phase !== state.final.phase) {
    state.final.phase = phase;

    // ì—°ì¶œ/UX: í˜ì´ì¦ˆ ì „í™˜(ì™„ì„±ê°)
    try {
      cineCard("ìµœì¢… ë³´ìŠ¤", `í˜ì´ì¦ˆ ${phase}`, "#f472b6", 1.65);
      fxFlash(CORE_POS.x, CORE_POS.y, 820, "rgba(244,114,182,1)");
      fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+18, CORE_RADIUS+260, "#f472b6");
      state.camShakeUntil = t + 0.18;
      state.camShakeDur   = 0.18;
      state.camShakeMag   = 10.5;
    } catch {}
    try { SFX.setBgmMode(phase === 1 ? "final1" : phase === 2 ? "final2" : "final3"); } catch {}
    boss.awakeFlash = 1.0;
    boss.awakeFlashPhase = phase;
  }

  // awaken flash decay (visual)
  boss.awakeFlash = Math.max(0, (boss.awakeFlash||0) - dt*1.8);

  // ---- Summons ----
  if (t >= state.final.nextSummonAt) {
    const spec = waveSpec(FINAL_WAVE);
    const s = { hp: spec.hp*0.55, spd: spec.spd*1.05, isBoss:false };
    const n = (phase===1) ? 2 : (phase===2 ? 3 : 4);
    for (let i=0;i<n;i++){
      let id;
      const r = Math.random();
      if (phase===1){
        id = (r < 0.60) ? "grunt" : "shooter";
      } else if (phase===2){
        id = (r < 0.40) ? "shooter" : "shieldbreaker";
      } else {
        id = (r < 0.35) ? "shieldbreaker" : (r < 0.70 ? "bomber" : "shooter");
      }
      spawnEnemyEdgeForced(id, s, Math.random()<0.18);
    }
    fxText("ì†Œí™˜!", boss.x, boss.y - 28, "#fbbf24");
    state.final.nextSummonAt = t + ((phase===1)?5.0: (phase===2?4.2:3.6));
  }

  // ---- Shield jam ----
  if (phase >= 2 && t >= state.final.nextShieldJamAt) {
    fxWarnCircle(CORE_POS.x, CORE_POS.y, CORE_RADIUS+24, CORE_RADIUS+140, "#60a5fa", 0.95);
    state.final.pending.push({ kind:"jam", at: t + 0.95, dur: 4.2 });
    state.final.nextShieldJamAt = t + (phase===2 ? 9.5 : 7.5);
  }

  // ---- Laser / EMP / Orbs ----
  if (phase === 3) {
    if (t >= state.final.nextLaserAt) {
      fxLine(boss.x, boss.y, CORE_POS.x, CORE_POS.y, "#f472b6", 1.05, 5);
      state.final.pending.push({ kind:"laser", at: t + 1.05 });
      state.final.nextLaserAt = t + 6.8;
    }
    if (t >= state.final.nextEmpAt) {
      fxWarnCircle(CORE_POS.x, CORE_POS.y, CORE_RADIUS+34, CORE_RADIUS+165, "#fbbf24", 0.9);
      state.final.pending.push({ kind:"emp", at: t + 0.9, dur: 3.6 });
      state.final.nextEmpAt = t + 10.0;
    }
    if (t >= state.final.nextOrbsAt) {
      spawnFinalOrbs(3);
      state.final.nextOrbsAt = t + 8.5;
    }
  }

  // ---- Resolve pending attacks ----
  for (let i = state.final.pending.length - 1; i >= 0; i--) {
    const a = state.final.pending[i];
    if (t < a.at) continue;

    if (a.kind === "jam") {
      state.core.shieldRegenBlockedUntil = Math.max(state.core.shieldRegenBlockedUntil, t + (a.dur||3.0));
      fxText("ì‹¤ë“œ ì¬ìƒ ì°¨ë‹¨!", CORE_POS.x, CORE_POS.y - 142, "#60a5fa");
    }
    if (a.kind === "laser") {
      damageCore(46, { hpArmorPierce:0.45, shieldArmorPierce:0.35 });
      fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+12, CORE_RADIUS+160, "#f472b6");
      fxText("ì½”ì–´ ë ˆì´ì €!", CORE_POS.x, CORE_POS.y - 160, "#f472b6");
    }
    if (a.kind === "emp") {
      state.final.empUntil = Math.max(state.final.empUntil, t + (a.dur||2.5));
      fxText("EMP! í¬íƒ‘ ë‘”í™”", CORE_POS.x, CORE_POS.y - 156, "#fbbf24");
    }

    state.final.pending.splice(i,1);
  }
}



  // ---------- Turrets / Projectiles ----------
  function turretBase(t){
    const b = TURRET_TYPES[t.type];
    const u = state.upg;
    // global upgrades
    const dmgMul  = 1 + 0.15*u.turretDmg;
    const fireMul = 1 + 0.10*u.turretFire;
    const rangeAdd = 12*u.turretRange;

    const out = { ...b };
    out.dmg = b.dmg * dmgMul;
    out.fireRate = b.fireRate * fireMul;
    out.range = b.range + rangeAdd;

    // map gimmick: turret range multiplier
    try {
      const m = state.map || mapById(state.mapId);
      if (m && m.turretRangeMul) out.range *= m.turretRangeMul;
    } catch(e) {}

    // type-specific upgrades
    if (t.type === "slow") {
      out.slow = clamp(b.slow + 0.06*u.slowPower, 0, 0.85);
    }
    if (t.type === "splash") {
      out.splash = b.splash + 8*u.splashRadius;
    }
    if (t.type === "shred") {
      // ë³´í˜¸ë§‰ ì¶”ê°€í”¼í•´ ë°°ìœ¨ ê°•í™”
      const baseMul = (b.shieldMul||1.0);
      out.shieldMul = baseMul + 0.15*u.shredFocus;
    }
    if (t.type === "breaker") {
      // ì·¨ì•½ í‘œì‹(ë°›í”¼ì¦/ì§€ì†) ê°•í™”
      out.vulnBonus = clamp((b.vulnBonus||0) + 0.03*u.breakerMark, 0, 0.60);
      out.vulnDur = (b.vulnDur||2.6) + 0.2*u.breakerMark;
    }

    // ê¸°ë³¸ í¬íƒ‘ ì§„í™”(A/B)
    if (t.type === "basic") {
      const evo = state.basicEvo || "none";
      if (evo === "pierce") {
        out.pierce = Math.max(out.pierce||0, 2);
        out.dmg *= 0.88;
        out.projSpd *= 1.10;
        out.range *= 1.05;
      } else if (evo === "focus") {
        out.dmg *= 1.55;
        out.fireRate *= 0.70;
        out.bossMul = 1.35;
        out.range *= 1.08;
      }
    }

    // ì½”ì–´ íŒ¨ì‹œë¸Œ: í¬íƒ‘ ë³´ë„ˆìŠ¤
    if (state.core.passiveId === "resonance") {
      const g = resonanceGauge01();
      // ê²Œì´ì§€ ê¸°ë°˜(ìµœëŒ€): í”¼í•´ +30%, ê³µì† +18%
      out.dmg *= (1 + passiveScale(0.30)*g);
      out.fireRate *= (1 + passiveScale(0.18)*g);
    }
    // ì„ê³„ ê³¼ë¶€í•˜: ì €ì²´ë ¥ì¼ìˆ˜ë¡ í¬íƒ‘ í™”ë ¥/ê³µì† ì¦ê°€
    if (state.core.passiveId === "overload") {
      const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
      // HP 40% ì´í•˜ë¶€í„° ê°€ì†, 10%ì—ì„œ ìµœëŒ€
      const tO = clamp((0.40 - hpFrac) / 0.30, 0, 1);
      // ìµœëŒ€: í”¼í•´ +75%, ê³µì† +55%
      out.dmg *= (1 + passiveScale(0.75)*tO);
      out.fireRate *= (1 + passiveScale(0.55)*tO);
      // ê·¹ì €ì²´ë ¥: ì•½í•œ ê´€í†µ 1íšŒ
      const pierceTh = passiveScaleThresholdToward1(0.95);

      if (tO >= pierceTh) out.pierce = Math.max(out.pierce||0, 1);
}
    // ì½”ì–´ ì˜¤ë²„ë“œë¼ì´ë¸Œ: í¬íƒ‘ ë³´ë„ˆìŠ¤ ì—†ìŒ (ìˆ˜ì •íƒ‘ ì§ì ‘ ê³µê²©)
    if (state.core.passiveId === "overdrive") {
      // intentionally no turret stat bonuses
    }
    return out;
  }

  function fireTurret(t, target){
    const s = turretBase(t);
    const dx = target.x - t.x, dy = target.y - t.y;
    const d = Math.hypot(dx,dy) || 1;

    const projMul = 1 + 0.15*state.upg.projSpeed;
    const sp = s.projSpd * state.mods.turretProjMul * projMul;

    let dmg = s.dmg * state.mods.turretDmgMul;
    const isHard = (state.diffId === "hard");
    const critBase = isHard ? 0.15 : 0.0;
    const critPer  = isHard ? 0.04 : 0.02;
    const critChance = critBase + critPer*state.upg.turretCrit;
    const isCrit = (critChance > 0) && (Math.random() < Math.min(0.95, critChance));
    if (isCrit) dmg *= (isHard ? 2.0 : 1.5);

    if (state.projectiles.length >= projCap()) return;

    const isOvBurst = (state.core.passiveId === "overload") && overloadBurstActive();

    state.projectiles.push({
      kind: "turret",
      x: t.x, y: t.y,
      vx: dx/d * sp,
      vy: dy/d * sp,
      dmg: dmg,
      crit: isCrit,
      splash: s.splash,
      slow: s.slow,
      shieldMul: (s.shieldMul||1.0),
      vulnBonus: (s.vulnBonus||0),
      vulnDur: (s.vulnDur||0),
      life: ((s.pierce||0) > 0 ? 2.2 : 1.7),
      r: isCrit ? 4.6 : 3.5,
      pierce: (s.pierce||0) + (isOvBurst ? OVERLOAD_CFG.burstPierceAdd : 0),
      ovBurst: isOvBurst,
      ovMiniSplash: (isOvBurst && ((s.splash||0) <= 0)),
      ovTrail: isOvBurst,
      chain: (s.chain||0),
      chainRange: (s.chainRange||0),
      chainMul: (s.chainMul||0),
      hitSet: null,
      // visual-only: for projectile styling
      tType: t.type
    });

    // turret-type muzzle ring (visual only)
    const mCol = (t.type === "basic")   ? "#93c5fd" :
                 (t.type === "slow")    ? "#a7f3d0" :
                 (t.type === "shred")   ? "#22d3ee" :
                 (t.type === "breaker") ? "#fbbf24" :
                 (t.type === "splash")  ? "#f472b6" : "#93c5fd";
    fxRing(t.x,t.y, 6, 28, mCol);
    if (isCrit) sfxCritTing(); else sfxShoot();
  }

  
  function enemyShoot(e){
    const dx = CORE_POS.x - e.x, dy = CORE_POS.y - e.y;
    const d = Math.hypot(dx,dy) || 1;
    const sp = e.projSpd || 320;

    if (state.projectiles.length >= projCap()) return;

    const isOvBurst = (state.core.passiveId === "overload") && overloadBurstActive();

    const diff = state.diff || DIFF_PRESETS.normal;

    state.projectiles.push({
      kind: "enemy",
      x: e.x, y: e.y,
      vx: dx/d * sp,
      vy: dy/d * sp,
      dmg: (e.projDmg || 8) * (e.elite ? 1.10 : 1.0) * (diff.dmgMul||1),
      life: 2.2,
      r: 3,
      coreOpts: e.coreOpts || null,
      projCol: (e.kind==="disruptor" ? "#22c55e" : "#fbbf24")
    });

    SFX.play("enemy_shoot");
    fxRing(e.x, e.y, 6, 26, (e.kind==="disruptor" ? "#22c55e" : "#fbbf24"));
  }

  function bombExplode(e){
    const diff = state.diff || DIFF_PRESETS.normal;
    SFX.play("blast");
    fxRing(e.x, e.y, 16, e.explodeRad || 120, "#34d399");
    fxText("í­ë°œ!", e.x, e.y - 16, "#34d399");

    const dmg = (e.explodeDmg || 32) * (e.elite ? 1.10 : 1.0) * (diff.dmgMul||1);
    damageCore(dmg, e.coreOpts || null);

    // í­ë°œ ë°˜ê²½ ë‚´ í¬íƒ‘ íŒŒì†(í™•ë¥ )
    const rad = e.explodeRad || 120;
    const chance = e.turretBreakChance || 0.35;
    for (let j = state.turrets.length - 1; j >= 0; j--) {
      const t = state.turrets[j];
      if (dist(t.x,t.y, e.x,e.y) <= rad) {
        if (Math.random() < chance) {
          fxText("í¬íƒ‘ íŒŒì†!", t.x, t.y - 10, "#ff9fb2");
          fxRing(t.x,t.y, 10, 70, "#ff9fb2");
          state.turrets.splice(j,1);
        }
      }
    }
  }


function enemyVulnMul(e){
    const t = gameSec();
    if (!e) return 1.0;
    if (t < (e.vulnUntil||0)) return 1.0 + (e.vulnBonus||0);
    return 1.0;
  }

  function dealDamageEnemy(e, rawDmg, p){
    if (!e) return { hpLost:0, shieldLost:0 };
    const hpBefore = e.hp;
    const shBefore = e.shield||0;
    let remain = rawDmg;
    let shLost = 0;

    if (shBefore > 0.01) {
      const sm = (p && p.shieldMul) ? p.shieldMul : 1.0;
      const shWanted = remain * sm;
      const absorbed = Math.min(shBefore, shWanted);
      e.shield = shBefore - absorbed;
      shLost = absorbed;
      remain -= absorbed / sm;
      if (absorbed > 0.01) {
        const gt = gameSec();
        if (gt - (e._shFxAt||0) > 0.06) {
          e._shFxAt = gt;
          const inten = clamp(absorbed / Math.max(24, shBefore), 0.25, 1);
          fxEnemyShieldHit(e.x, e.y, inten, e);
        }
      }
    }

    if (remain > 0) e.hp -= remain;
    if ((e.shield||0) < 0) e.shield = 0;

    const hpLost = Math.max(0, hpBefore - e.hp);
    const shLost2 = Math.max(0, shBefore - (e.shield||0));

    if (hpLost > 0.01) {
      const gt = gameSec();
      if (gt - (e._hpFxAt||0) > 0.07) {
        e._hpFxAt = gt;
        const inten = clamp(hpLost / Math.max(30, hpBefore), 0.25, 1);
        fxEnemyHpHit(e.x, e.y, inten, e);
      }
    }

    return { hpLost: hpLost, shieldLost: shLost2 };
  }

function applyProjectileHit(p, hit){
    // ì„ê³„ ê³¼ë¶€í•˜: í¬íƒ‘ ì ì¤‘ ì‹œ í‘œì‹(ìµœëŒ€ 5ì¤‘ì²©/4s)
    if (p.kind === "turret" && state.core.passiveId === "overload") {
      applyOverloadMark(hit, 1);
    }

    const tNow = nowSec();

    function calcDmg(target, base){
      let dmg = base;
      dmg *= enemyExposeMul(target);
      dmg *= enemyVulnMul(target);
      // ê³¼ë¶€í•˜ í‘œì‹: ë°›ëŠ” í”¼í•´ ì¦ê°€
      if (state.core.passiveId === "overload") dmg *= (1 + overloadMarkBonus(target));
      
      // í¬íƒ‘ ì§„í™”(ì§‘ì¤‘): ë³´ìŠ¤ í”¼í•´ ë³´ë„ˆìŠ¤
      if ((p.bossMul||1) !== 1 && (target.kind === "boss" || target.isFinalBoss)) dmg *= (p.bossMul||1);
// ìµœì¢…ë³´ìŠ¤: í¬íƒ‘ ë‚´ì„± (ë²„ìŠ¤íŠ¸ ì¤‘ 25% ë¶€ë¶„ ë¬´ì‹œ)
      if (p.kind === "turret" && target.isFinalBoss) {
        let mul = finalBossIncomingMul();
        if (state.core.passiveId === "overload" && p.ovBurst) {
          mul = mul + (1 - mul) * passiveScale(OVERLOAD_CFG.finalBossResistIgnore);
        }
        dmg *= mul;
      }
      return dmg;
    }

    // ë©”ì¸ íƒ€ê²©
    let dmg = calcDmg(hit, p.dmg);
    dealDamageEnemy(hit, dmg, p);

    // ë°©í˜¸ íŒŒê´´(ì·¨ì•½): ë©”ì¸ íƒ€ê²©ì—ì„œë§Œ ë¶€ì—¬
    if (p.kind === "turret" && (p.vulnBonus||0) > 0 && hit) {
      const t = gameSec();
      hit.vulnBonus = Math.max(hit.vulnBonus||0, p.vulnBonus||0);
      hit.vulnUntil = Math.max(hit.vulnUntil||0, t + (p.vulnDur||2.6));
      const last = hit._vulnFxAt||0;
      if (t - last > 0.8) {
        hit._vulnFxAt = t;
        fxText("ì·¨ì•½!", hit.x, hit.y - 20, "#fca5a5");
        fxRing(hit.x, hit.y, 8, 44, "#fca5a5");
      }
    }

    // ì²´ì¸(ê³µëª…/ê³¼ë¶€í•˜): ì¶”ê°€ë¡œ ê°€ê¹Œìš´ ì  1ëª…ì—ê²Œ ì „ì´
    if ((p.chain||0) > 0 && state.enemies.length > 1) {
      let best = null, bestD = 1e9;
      const R = p.chainRange || 0;
      if (R > 1) {
        for (const e of state.enemies) {
          if (e === hit) continue;
          const d = dist(hit.x, hit.y, e.x, e.y);
          if (d <= R && d < bestD) { bestD = d; best = e; }
        }
        if (best) {
          const mul = clamp(p.chainMul||0.5, 0.1, 0.9);
          const cdmg = calcDmg(best, p.dmg * mul);
          dealDamageEnemy(best, cdmg, p);
          fxRing(best.x, best.y, 6, 30, "#fdba74");
          fxRing(hit.x, hit.y, 6, 30, "#fdba74");
        }
      }
    }

    // ìŠ¬ë¡œìš°
    if (p.slow > 0 && hit) {
      const t = nowSec();
      hit.slowMul = Math.min(hit.slowMul || 1.0, 1 - p.slow);
      const slowDur = 1.2 + 0.25*state.upg.slowDuration;
      hit.slowUntil = Math.max(hit.slowUntil || 0, t + slowDur);
    }

    // íˆíŠ¸ FX (ì¹˜ëª…íƒ€: í° ë§ í­ë°œ + íŒŒí¸ë§Œ)
    const isTurretCrit = (p.kind === "turret" && !!p.crit);
    if (isTurretCrit) {
      const gt = gameSec();
      if (gt - (state._turretCritFxAt||0) > 0.10) {
        state._turretCritFxAt = gt;
        // ëˆˆë¶€ì‹¬ ì™„í™”(ì•½ 50%): ë§/íŒŒí¸/ìŠ¤íŒŒí¬ ìˆ˜Â·ë²”ìœ„Â·íˆ¬ëª…ë„ ê°ì†Œ
        fxRing(p.x,p.y, 14, 150, "#fbbf24", 0.45, 2);
        fxRing(p.x,p.y, 22, 220, "rgba(253,230,138,0.75)", 0.25, 2);
        fxShardsBurst(p.x,p.y, "#fde68a", 4, 95, 0.50, 8);
        fxSparksBurst(p.x,p.y, "#fbbf24", 5, 110, 0.22, 2.0, 18);
      }
    } else if (p.splash > 0) {
      for (const e of state.enemies) {
        if (p.hitSet && p.hitSet.has(e)) continue;
        const d = dist(p.x,p.y, e.x,e.y);
        if (d <= p.splash) {
          const fall = 1 - (d / p.splash);
          const coreLow = (state.core.hp / state.core.hpMax) <= 0.5;
          const splashMul = coreLow ? 0.50 : 0.65;
          const sdmg = calcDmg(e, p.dmg * splashMul * fall);
          dealDamageEnemy(e, sdmg, p);
        }
      }
      fxRing(p.x,p.y, 8, p.splash, "#93c5fd");
    } else {
      fxRing(p.x,p.y, 6, 36, "#93c5fd");
    }

    // ì„ê³„ ê³¼ë¶€í•˜: ë²„ìŠ¤íŠ¸ ì¤‘(ìŠ¤í”Œë˜ì‹œ ì—†ëŠ” í¬íƒ‘) ì†Œí˜• í­ë°œ
    if (p.ovMiniSplash) {
      const R2 = OVERLOAD_CFG.miniSplashR * passiveHardMul();
      for (const e2 of state.enemies) {
        if (!e2 || e2===hit) continue;
        if (p.hitSet && p.hitSet.has(e2)) continue;
        const d2 = dist(p.x,p.y, e2.x,e2.y);
        if (d2 > R2) continue;
        const mdmg = calcDmg(e2, p.dmg * passiveScale(OVERLOAD_CFG.miniSplashMul));
        dealDamageEnemy(e2, mdmg, p);
      }
      fxRing(p.x,p.y, 10, R2, "#fb7185");
    }
  }

// ---------- FX ----------
  function fxRing(x,y, r0, r1, color, a=0.8, w=3){ state.fx.push({ kind:"ring", x,y, t:0, dur:0.35, r0, r1, color, a, w }); }

  function fxFlash(x,y, r=520, color="rgba(255,255,255,1)") {
    // Radial flash (used for Overload/impact moments)
    state.fx.push({ kind:"flash", x, y, t:0, dur:0.22, r, color });
  }
function fxLine(x1,y1,x2,y2, color, dur=0.9, width=4){
    state.fx.push({ kind:"line", x1,y1,x2,y2, t:0, dur, color, width });
  }
  function fxWarnCircle(x,y, r0, r1, color, dur=0.9){
    state.fx.push({ kind:"warn", x,y, t:0, dur, r0, r1, color });
  }

  function fxText(text,x,y,color){ state.fx.push({ kind:"text", x,y, t:0, dur:0.9, text, color }); }
  function fxShieldWave(x,y, radius){ state.fx.push({ kind:"shieldWave", x,y, t:0, dur:0.42, r0:radius, r1:radius+68, color:"#60a5fa" }); }

  // ---------- Enemy Hit/Death FX (visual-only) ----------
  // NOTE: HP low "blue flame" effect is handled elsewhere and remains unchanged.
  function fxSpark(x,y, dx,dy, color, dur=0.22, width=2, tail=14){
    state.fx.push({ kind:"spark", x,y, t:0, dur, dx,dy, color, width, tail });
  }

  function fxShard(x,y, dx,dy, color, dur=0.55, size=8){
    state.fx.push({ kind:"shard", x,y, t:0, dur, dx,dy, color, size,
      rot: Math.random() * Math.PI * 2,
      spin: rand(-9, 9)
    });
  }

  function fxSparksBurst(x,y, color, n=6, dist=44, dur=0.22, width=2, tail=14){
    if (state.fx.length > 520) return;
    for (let i=0;i<n;i++){
      const a = Math.random() * Math.PI * 2;
      const d = dist * (0.55 + Math.random() * 0.90);
      const dd = dur  * (0.75 + Math.random() * 0.55);
      const w  = width * (0.70 + Math.random() * 0.80);
      const tl = tail  * (0.55 + Math.random() * 0.90);
      fxSpark(x, y, Math.cos(a)*d, Math.sin(a)*d, color, dd, w, tl);
    }
  }

  function fxShardsBurst(x,y, color, n=6, dist=64, dur=0.55, size=8){
    if (state.fx.length > 520) return;
    for (let i=0;i<n;i++){
      const a = Math.random() * Math.PI * 2;
      const d = dist * (0.35 + Math.random() * 0.95);
      const dd = dur * (0.75 + Math.random() * 0.55);
      const s = size * (0.65 + Math.random() * 1.05);
      fxShard(x, y, Math.cos(a)*d, Math.sin(a)*d, color, dd, s);
    }
  }

  function enemyFxPalette(e){
    const kind = (e && e.kind) ? String(e.kind) : "";
    let shield = "#93c5fd";
    let hp     = "#fb7185";
    let death  = "#cbe6ff";
    let accent = "#93c5fd";
    if (kind === "disruptor") { death = "#86efac"; accent = "#22c55e"; }
    if (kind === "boss")      { death = "#fda4af"; accent = "#f472b6"; }
    if (e && e.isFinalBoss)    { death = "#f5d0fe"; accent = "#f472b6"; }
    return { shield, hp, death, accent };
  }

  function fxEnemyShieldHit(x,y, inten=0.6, e){
    const pal = enemyFxPalette(e);
    const n = Math.round(3 + 4*inten);
    const dist = 26 + 32*inten;
    const dur  = 0.16 + 0.14*inten;

    fxRing(x, y, 5, 28 + 28*inten, pal.shield);
    fxSparksBurst(x, y, pal.shield, n, dist, dur, 2.2, 12 + 12*inten);

    // small crack lines
    const a0 = Math.random() * Math.PI * 2;
    const len = 8 + 18*inten;
    const dx = Math.cos(a0) * len;
    const dy = Math.sin(a0) * len;
    fxLine(x-dx, y-dy, x+dx, y+dy, "rgba(191,219,254,0.95)", 0.10 + 0.08*inten, 2.2);
    if (Math.random() < 0.55) {
      const a1 = a0 + Math.PI/2 + rand(-0.35, 0.35);
      const len2 = len * (0.75 + Math.random()*0.45);
      const dx2 = Math.cos(a1) * len2;
      const dy2 = Math.sin(a1) * len2;
      fxLine(x-dx2, y-dy2, x+dx2, y+dy2, "rgba(224,242,254,0.85)", 0.09 + 0.08*inten, 1.9);
    }
  }

  function fxEnemyHpHit(x,y, inten=0.6, e){
    const pal = enemyFxPalette(e);
    const n = Math.round(4 + 5*inten);
    const dist = 22 + 42*inten;
    const dur  = 0.14 + 0.16*inten;

    fxRing(x, y, 4, 18 + 22*inten, pal.hp);
    fxSparksBurst(x, y, pal.hp, n, dist, dur, 2.4, 14 + 16*inten);
  }

  function fxEnemyDeathBurst(e){
    if (!e) return;
    const pal = enemyFxPalette(e);
    const x = e.x, y = e.y;
    const m = (e.kind === "boss") ? 1.85 : (e.elite ? 1.25 : 1.0);

    fxRing(x, y, 10, 62*m, pal.accent);
    fxSparksBurst(x, y, pal.accent, Math.round(10*m), 66*m, 0.26, 2.8, 18*m);
    fxShardsBurst(x, y, pal.death,  Math.round(7*m),  74*m, 0.56, 10*m);
  }

  // ---------- Cinematic UI (ì›¨ì´ë¸Œ/ë³´ìŠ¤/íŒ¨ì‹œë¸Œ ì¹´ë“œ) ----------
  function cineEnsure(){
    if (!state.cine) state.cine = { cards: [] };
    if (!Array.isArray(state.cine.cards)) state.cine.cards = [];
  }
  function cineCard(title, sub="", color="#93c5fd", dur=1.35){
    cineEnsure();
    const t0 = gameSec();
    state.cine.cards.push({ title: String(title||""), sub: String(sub||""), color, t0, dur });
    // ë„ˆë¬´ ë§ì´ ìŒ“ì´ì§€ ì•Šê²Œ
    if (state.cine.cards.length > 4) state.cine.cards.splice(0, state.cine.cards.length - 4);
  }


  // ì¤‘ì•™ ì¹´ë“œê°€ í™”ë©´ì„ ê°€ë¦¬ëŠ” ê²½ìš°(ìŠ¤í‚¬/ë²„ìŠ¤íŠ¸/ê³µëª… ë“±) â€” ìƒë‹¨ í† ìŠ¤íŠ¸ë¡œ í‘œì‹œ
  function cineToast(title, sub="", color="#93c5fd", dur=1.05){
    cineEnsure();
    const t0 = gameSec();
    state.cine.cards.push({ title: String(title||""), sub: String(sub||""), color, t0, dur, kind:"toast" });
    if (state.cine.cards.length > 6) state.cine.cards.splice(0, state.cine.cards.length - 6);
  }

  function passiveAccent(id){
    switch(String(id||"")){
      case "rebuild":   return "#60a5fa";
      case "resonance": return "#fb923c";
      case "overload":  return "#fb7185";
      case "overdrive": return "#c4b5fd";
      default: return "#93c5fd";
    }
  }

  // ---------- Blue Flames ----------
  function spawnBlueFlame(intensity){
    const baseX = CORE_POS.x + rand(-16, 16);
    const baseY = CORE_POS.y + CORE_RADIUS*0.60 + rand(-3, 7);

    const size = lerp(6, 20, intensity) * (0.85 + Math.random()*0.35);
    const ttl  = lerp(0.35, 0.95, intensity) * (0.85 + Math.random()*0.3);

    state.flames.push({
      x: baseX, y: baseY,
      vx: rand(-18, 18) * (0.4 + intensity),
      vy: rand(-55, -145) * (0.6 + intensity),
      life: 0, ttl,
      size,
      wobble: rand(0.8, 1.6),
      phase: rand(0, Math.PI*2)
    });
  }

  function updateBlueFlames(dt){
    // âœ… ë¶•ê´´ ì¤‘ì—” ì¦‰ì‹œ ì œê±°
    if (state.phase === "fail") {
      state.flames.length = 0;
      state.flameSpawnAcc = 0;
      return;
    }

    const hpRatio = state.core.hp / state.core.hpMax;
    const THRESH = 0.70;

    if (hpRatio > THRESH) {
      state.flames.length = 0;
      state.flameSpawnAcc = 0;
      return;
    }

    const intensity = clamp((THRESH - hpRatio) / THRESH, 0, 1);
    const spawnPerSec = intensity * 28;
    state.flameSpawnAcc += spawnPerSec * dt;

    while (state.flameSpawnAcc >= 1) {
      spawnBlueFlame(intensity);
      state.flameSpawnAcc -= 1;
    }

    for (let i = state.flames.length - 1; i >= 0; i--) {
      const f = state.flames[i];
      f.life += dt;
      f.phase += dt * f.wobble;
      f.x += (f.vx + Math.sin(f.phase)*18) * dt;
      f.y += f.vy * dt;
      f.vx *= (1 - dt*0.9);
      f.vy *= (1 - dt*0.15);
      if (f.life >= f.ttl) state.flames.splice(i, 1);
    }
  }

  function drawBlueFlames(){
    for (const f of state.flames) {
      const t = clamp(f.life / f.ttl, 0, 1);
      const a = (1 - t) * 0.85;
      const r = f.size * (1 - t*0.45);

      ctx.save();
      ctx.globalAlpha = a;

      const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, r*1.5);
      g.addColorStop(0.00, `rgba(219,234,254,${a})`);
      g.addColorStop(0.35, `rgba(147,197,253,${a*0.9})`);
      g.addColorStop(1.00, `rgba(96,165,250,0)`);
      ctx.fillStyle = g;

      ctx.beginPath();
      ctx.arc(f.x, f.y, r*1.25, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = a*0.95;
      ctx.fillStyle = `rgba(96,165,250,${a})`;
      ctx.beginPath();
      ctx.ellipse(f.x, f.y, r*0.55, r*0.95, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
  }

  // ---------- Collapse / Debris ----------
      function spawnDebrisBurst(){
    // âœ… ìˆ˜ì • íŒŒí¸(íŒŒë‘) + ê¸ˆì† íŒŒí¸(ê¸ˆìƒ‰) + ë¯¸ì„¸ ë”ìŠ¤íŠ¸(ì—°íŒŒë‘)
    const push = (kind, blue, big=false)=>{
      const ang = rand(0, Math.PI*2);
      const spd = (kind === 'dust') ? rand(140, 760) : rand(110, 520);
      const r0  = big ? rand(10, 18) : rand(3.0, 8.0);
      const r   = (kind === 'dust') ? rand(1.2, 3.0) : r0;

      let w = r*0.9, h = r*1.8;
      if (kind === 'plate') { w = r*1.8; h = r*1.0; }
      if (kind === 'dust')  { w = r; h = r; }

      state.debris.push({
        kind,
        x: CORE_POS.x + rand(-10,10),
        y: CORE_POS.y + rand(-10,10),
        vx: Math.cos(ang)*spd,
        vy: Math.sin(ang)*spd - rand(80,260),
        r,
        w,
        h,
        rot: rand(0, Math.PI*2),
        vr: rand(-10, 10),
        life: 0,
        ttl: (kind === 'dust') ? rand(0.55, 1.15) : rand(1.0, 2.6),
        color: blue ? 'rgba(147,197,253,1)' : 'rgba(230,208,122,1)',
        stroke: blue ? 'rgba(15,23,42,0.65)' : 'rgba(15,23,42,0.55)'
      });
    };

    // í° ìˆ˜ì • íŒŒí¸(ì‹¤ë£¨ì—£ ëŠë‚Œ)
    for (let i=0;i<14;i++) push('shard', true, true);

    // ì¤‘ê°„ ìˆ˜ì • íŒŒí¸
    for (let i=0;i<38;i++) push('shard', Math.random()<0.85, false);

    // ê¸ˆì† í”Œë ˆì´íŠ¸ íŒŒí¸
    for (let i=0;i<26;i++) push('plate', false, (Math.random()<0.25));

    // ë¯¸ì„¸ ë”ìŠ¤íŠ¸
    for (let i=0;i<18;i++) push('dust', true, false);
  }

  function updateDebris(dt){
    for (let i=state.debris.length-1;i>=0;i--){
      const d = state.debris[i];
      d.life += dt;

      d.vy += 560 * dt;
      d.vx *= (1 - dt*0.25);
      d.vy *= (1 - dt*0.05);

      d.x += d.vx * dt;
      d.y += d.vy * dt;
      d.rot += d.vr * dt;

      const ground = CORE_POS.y + 150;
      if (d.y > ground) {
        d.y = ground;
        d.vy *= -0.25;
        d.vx *= 0.65;
      }

      if (d.life >= d.ttl) state.debris.splice(i,1);
    }
  }

      function drawDebris(){
    for (const d of state.debris){
      const t = clamp(d.life / d.ttl, 0, 1);
      const a = (1 - t) * 0.95;

      ctx.save();
      ctx.globalAlpha = a;
      ctx.translate(d.x, d.y);
      ctx.rotate(d.rot);

      if (d.kind === 'dust') {
        const rr = d.r * (1 + t*0.6);
        const g = ctx.createRadialGradient(0,0,0, 0,0, rr*2.2);
        g.addColorStop(0.0, 'rgba(219,234,254,'+(0.55*a)+')');
        g.addColorStop(0.35,'rgba(147,197,253,'+(0.35*a)+')');
        g.addColorStop(1.0, 'rgba(96,165,250,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0,0, rr*2.0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        continue;
      }

      // ê³µí†µ: íŒŒí¸ ë°”ë””
      ctx.fillStyle = d.color;
      ctx.beginPath();

      if (d.kind === 'plate') {
        // ì–‡ì€ ê¸ˆì† í”Œë ˆì´íŠ¸(ì±”í¼)
        const w = d.w, h = d.h;
        const c = Math.min(w,h) * 0.25;
        ctx.moveTo(-w*0.5 + c, -h*0.5);
        ctx.lineTo(w*0.5 - c, -h*0.5);
        ctx.lineTo(w*0.5, -h*0.5 + c);
        ctx.lineTo(w*0.5, h*0.5 - c);
        ctx.lineTo(w*0.5 - c, h*0.5);
        ctx.lineTo(-w*0.5 + c, h*0.5);
        ctx.lineTo(-w*0.5, h*0.5 - c);
        ctx.lineTo(-w*0.5, -h*0.5 + c);
      } else {
        // ìˆ˜ì • ìƒ¤ë“œ(ê¸¸ì­‰í•œ ë‹¤ì´ì•„)
        const w = d.w, h = d.h;
        ctx.moveTo(0, -h*0.5);
        ctx.lineTo(w*0.5, 0);
        ctx.lineTo(0, h*0.5);
        ctx.lineTo(-w*0.5, 0);
      }

      ctx.closePath();
      ctx.fill();

      // ì™¸ê³½ì„ (ì‚´ì§)
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = d.stroke;
      ctx.stroke();

      ctx.restore();
    }
  }

  function drawBlueExplosionFlash(){
    if (!(state.phase === "fail" && state.collapse)) return;
    const t = state.collapse.boomT;

    const flashDur = 0.28;
    if (t < flashDur) {
      const k = 1 - (t / flashDur);
      const a = 0.75 * k;
      const r = lerp(120, 520, 1 - k);

      ctx.save();
      ctx.globalAlpha = a;
      ctx.globalCompositeOperation = "lighter";

      const g = ctx.createRadialGradient(CORE_POS.x, CORE_POS.y, 0, CORE_POS.x, CORE_POS.y, r);
      g.addColorStop(0.00, "rgba(219,234,254,1)");
      g.addColorStop(0.35, "rgba(147,197,253,0.85)");
      g.addColorStop(1.00, "rgba(96,165,250,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      ctx.restore();
    }

    const glowDur = 0.55;
    if (t < glowDur) {
      const k = 1 - (t / glowDur);
      const a = 0.18 * k;
      const r = lerp(240, 760, 1 - k);

      ctx.save();
      ctx.globalAlpha = a;

      const g2 = ctx.createRadialGradient(CORE_POS.x, CORE_POS.y, 0, CORE_POS.x, CORE_POS.y, r);
      g2.addColorStop(0.00, "rgba(96,165,250,1)");
      g2.addColorStop(1.00, "rgba(96,165,250,0)");
      ctx.fillStyle = g2;
      ctx.fillRect(0, 0, W, H);
      ctx.restore();
    }
  }

  // ---------- Core Damage ----------
  function triggerCollapse(){
    if (state.phase === "fail") return;

    // âœ… ë¶•ê´´ ìˆœê°„: ë³´í˜¸ë§‰/ë¶ˆê½ƒ ì¦‰ì‹œ ì œê±°
    state.core.shield = 0;
    state.core.aegisActiveUntil = 0;
    state.flames.length = 0;
    state.flameSpawnAcc = 0;

    state.phase = "fail";

    // BGM: ì‹¤íŒ¨ ëª¨ë“œ(ì–´ë‘¡ê²Œ/ëŠë¦¬ê²Œ)
    try { SFX.setBgmMode("fail"); } catch {}
    state.spawn = null;
    state.autoStartAt = 0;

    // ì›”ë“œ ì •ë¦¬(ë©ˆì¶¤/ë²„ê·¸ ë°©ì§€)
    state.enemies.length = 0;
    state.projectiles.length = 0;

    state.collapse = { t:0, boomT:0, shake:1.25, fade:0 };

    SFX.play("core_break");
    SFX.play("boom");

    fxText("ìˆ˜ì •íƒ‘ ë¶•ê´´!", CORE_POS.x, CORE_POS.y - 12, "#93c5fd");
    fxShieldWave(CORE_POS.x, CORE_POS.y, CORE_RADIUS + 18);
    fxShieldWave(CORE_POS.x, CORE_POS.y, CORE_RADIUS + 22);
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS + 16, 360, "#93c5fd");
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS + 26, 520, "#60a5fa");
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS + 36, 680, "#dbeafe");

    spawnDebrisBurst();

    // ì™€ì´ì–´ëŠ” ì¦‰ì‹œ ì˜¬ë ˆë“œ(HP=0)
    wireTick(0);

    // ê¸°ë¡ ì €ì¥(ì‹¤íŒ¨)
    try {
      if (state.stats) {
        state.stats.runEnd = nowSec();
        state.stats.finalWave = state.wave|0;
      }
      updateRecordsWithRun(buildRunSummary(false));
      renderRecords(true);
    } catch(e) {}
  }

  function damageCore(amount, opts){
    if (state.phase === "fail") return;
    if (state.god) { return; }

    // (11) ë°©ì–´ì„ : ë°©ë²½(1ì´ˆ) â€” ì½”ì–´ í”¼í•´ ë¬´íš¨
    if (state.core.barrierActive && !(opts && opts.bypassBarrier)) {
      const tNow = gameSec();
      if (tNow < (state.core.barrierUntil||0)) {
        // í”¼í•´ëŠ” 0, í”¼ê²© FXëŠ” ì¶œë ¥(ìŠ¤íŒ¸ ë°©ì§€)
        const lastFx = state.core._barrierHitFxAt || 0;
        if ((tNow - lastFx) > 0.06) {
          state.core._barrierHitFxAt = tNow;
          try { fxShieldWave(CORE_POS.x, CORE_POS.y, CORE_RADIUS + 18); } catch(e) {}
          try { fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+90, "#93c5fd"); } catch(e) {}
          try { sfxShieldHit(); } catch(e) {}
        }
        return;
      }
      // ë§Œë£Œ ì •ë¦¬
      state.core.barrierActive = false;
    }

    const prevShield = state.core.shield;
    const prevHP     = state.core.hp;

    opts = opts || null;

    // ì½”ì–´ íŒ¨ì‹œë¸Œ: ë°©ì–´/í”¼í•´ê°ì†Œ ê³„ì‚°
    const hpFrac0 = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;


    // íŒ¨ì‹œë¸Œ ë³´ì •: ë°©ì–´/ë³´í˜¸ë§‰ë°©ì–´ ì¶”ê°€ì¹˜
    let bonusHpArmor = 0;
    let bonusShieldArmor = 0;
    // ì„ê³„ ê³¼ë¶€í•˜: ì €ì²´ë ¥ í”¼í•´ ê°ì†Œ (HP 35%â†“ë¶€í„°, 10%ì—ì„œ ìµœëŒ€ 25%)
    if (state.core.passiveId === "overload") {
      const tO = clamp((0.35 - hpFrac0) / 0.25, 0, 1);
      amount *= (1 - passiveScale(0.25)*tO);
    }

    // ì½”ì–´ ì˜¤ë²„ë“œë¼ì´ë¸Œ: ì €ì²´ë ¥ í”¼í•´ ê°ì†Œ (HP 40%â†“ë¶€í„°, 10%ì—ì„œ ìµœëŒ€ 18%)
    if (state.core.passiveId === "overdrive") {
      const tO = clamp((0.40 - hpFrac0) / 0.30, 0, 1);
      amount *= (1 - passiveScale(0.18)*tO);
    }

    // ì¬ê±´ ì½”ì–´: ì €ì²´ë ¥ í”¼í•´ê°ì†Œ (HP 50%â†“ë¶€í„°, 10%ì—ì„œ ìµœëŒ€ -12%)
    if (state.core.passiveId === "rebuild") {
      // HP 70%â†“ë¶€í„° ë°©ì–´/DRì´ ì‹œì‘, HP 10%ì—ì„œ ìµœëŒ€ì¹˜
      // (ì£¼ì˜) ì˜ˆì „ hpPct/clamp01 ì°¸ì¡°ë¡œ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë‚˜ì„œ ì /í¬íƒ‘ ê³µê²©ì´ ë©ˆì¶”ëŠ” ë²„ê·¸ê°€ ìˆì—ˆìŒ
      const tB = clamp((0.70 - hpFrac0) / 0.60, 0, 1);       // 70%->0, 10%->1
      // ì €ì²´ë ¥ì¼ìˆ˜ë¡ ë°©ì–´/ë³´í˜¸ë§‰ë°©ì–´ ë³´ì • (ìµœëŒ€ ë°©ì–´ +15 / ë³´í˜¸ë§‰ë°©ì–´ +7.5)
      bonusHpArmor = passiveScale(15) * tB;
      bonusShieldArmor = passiveScale(7.5) * tB;
      amount *= (1 - passiveScale(0.12)*tB);

      // ì‹¤ë“œ íŒŒê´´ ì§í›„ ê¸´ê¸‰ ë³´ê°•(í”¼í•´ -38%)
      const tNow = gameSec();
      if (tNow < (state.core.rebuildEmergencyUntil||0)) {
        amount *= (1 - passiveScale(0.38));
      }
    }
// ì˜µì…˜: íŠ¹ì • ê³µê²©ì´ ë°©ì–´ë ¥ì„ ì¼ë¶€ ë¬´ì‹œ/ê°•í™”
    const baseShieldArmor = state.core.shieldArmor + bonusShieldArmor;
    const baseHpArmor     = state.core.hpArmor + bonusHpArmor;

    const baseAbsorbMul   = state.mods.shieldAbsorbMul;

    const effShieldArmor = Math.max(0, (baseShieldArmor) * ((opts && opts.shieldArmorPierce) ? (1 - opts.shieldArmorPierce) : 1));
    const effHpArmor     = Math.max(0, (baseHpArmor) * ((opts && opts.hpArmorPierce) ? (1 - opts.hpArmorPierce) : 1));
    const effAbsorbMul   = (opts && opts.bypassShield) ? 0 : baseAbsorbMul;

    let remain = amount;
    if (opts && opts.shieldBonusMul && state.core.shield > 0.01) {
      remain *= opts.shieldBonusMul;
    }

    // 1) ë³´í˜¸ë§‰ í¡ìˆ˜ (+ ë³´í˜¸ë§‰ ë°©ì–´ë ¥)
    // - shieldAbsorbMul: (0~1) ë³´í˜¸ë§‰ì´ í¡ìˆ˜ì— ì°¸ì—¬í•˜ëŠ” ë¹„ìœ¨ (ì´ë²¤íŠ¸ë¡œ 0ì´ ë  ìˆ˜ ìˆìŒ)
    // - shieldArmor: ë³´í˜¸ë§‰ì— ë“¤ì–´ê°€ëŠ” í”¼í•´ë¥¼ ê³ ì • ê°ì‚° (í”¼í•´ë¥¼ HPë¡œ "ë„˜ê¸°ì§€" ì•Šê³ , ì´ í”¼í•´ë¥¼ ì¤„ì„)
    if (state.core.shield > 0 && effAbsorbMul > 0) {
      const mul = clamp(effAbsorbMul, 0, 1);

      const shieldPortion = remain * mul;   // ë³´í˜¸ë§‰ ìª½ìœ¼ë¡œ ë“¤ì–´ê°€ëŠ” ëª«
      const bypassPortion = remain - shieldPortion; // ë³´í˜¸ë§‰ì„ ìš°íšŒí•´ì„œ HPë¡œ ë°”ë¡œ ê°€ëŠ” ëª«

      const shieldDmgWanted = Math.max((shieldPortion > 0.01 ? 1.0 : 0), shieldPortion - effShieldArmor); // ìµœì†Œ 1 í”¼í•´
      const absorbed = Math.min(state.core.shield, shieldDmgWanted);

      state.core.shield -= absorbed;

      const spill = shieldDmgWanted - absorbed; // ë³´í˜¸ë§‰ì´ ë¶€ì¡±í•´ì„œ ìƒˆëŠ” í”¼í•´
      remain = bypassPortion + spill;

      if (absorbed > 0.01) {
        fxShieldWave(CORE_POS.x, CORE_POS.y, CORE_RADIUS + 18);
        sfxShieldHit();
        // ê³µëª… ë°˜ê²©: ë³´í˜¸ë§‰ì´ ì‹¤ì œë¡œ í¡ìˆ˜í•œ ì–‘ìœ¼ë¡œ ê²Œì´ì§€ ì¶©ì „
        resonanceOnAbsorb(absorbed);
      }

      // ë³´í˜¸ë§‰ì´ 0ìœ¼ë¡œ ë–¨ì–´ì§€ëŠ” ìˆœê°„
      if (prevShield > 0 && state.core.shield <= 0.0001) {
        state.core.shield = 0;
        SFX.play("shield_break");

        // ì¬ê±´ ì½”ì–´: ì‹¤ë“œ íŒŒê´´ ì§í›„ ê¸´ê¸‰ ë³´ê°• ë°œë™(ì¿¨ 7ì´ˆ)
        if (state.core.passiveId === "rebuild") {
          const tNow = gameSec();
          const readyAt = (state.core.rebuildEmergencyReadyAt||0);
          if (tNow >= readyAt) {
            const dur = (state.wave === FINAL_WAVE) ? 1.9 : 1.5;
            state.core.rebuildEmergencyUntil = tNow + dur;
            state.core.rebuildEmergencyReadyAt = tNow + 7.0;
            fxText("ê¸´ê¸‰ ë³´ê°•!", CORE_POS.x, CORE_POS.y - 128, "#93c5fd");
            fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+150, "#93c5fd");
            try { cineToast("ì¬ê±´ ì½”ì–´", `ê¸´ê¸‰ ë³´ê°• ${dur.toFixed(1)}s`, "#60a5fa", 1.05); } catch {}
          }
        }

        // ê³µëª… ë°˜ê²©: íŒ¨ë„í‹° ì œê±°ë¨
      }
    }

    // 2) HP í”¼í•´ (+ ë°©ì–´ë ¥)
    if (remain > 0.01) {
      const hpDmg = Math.max(1.0, remain - effHpArmor); // ìµœì†Œ 1 í”¼í•´ëŠ” ë“¤ì–´ê°€ê²Œ
      state.core.hp -= hpDmg;

      fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+8, CORE_RADIUS+70, "#60a5fa");

      if (state.core.hp < prevHP) {
        state.core.lastHpDamageAt = gameSec();
        sfxHpHit();
      }
    }

    // í†µê³„: ì‹¤ì œë¡œ ê¹ì¸ ì´ëŸ‰(ë³´í˜¸ë§‰+HP)
    const shLost = Math.max(0, prevShield - state.core.shield);
    const hpLost = Math.max(0, prevHP - state.core.hp);
    if (hpLost > 0.001) state.core.hpDirectDamaged = true;
    // ê³µëª… ë°˜ê²©: HP í”¼í•´ë„ ê³µëª… ê²Œì´ì§€ë¡œ í™˜ì‚°(ì „íˆ¬/ìƒí™© ë¬´ê´€)
    if (hpLost > 0.001 && state.core.passiveId === "resonance") {
      resonanceOnAbsorb(hpLost * RESONANCE_CFG.hpMul);
    }
    // ê³µëª… ë°˜ê²©: íŒ¨ë„í‹° ì—†ìŒ(ì¿¨/ìƒí•œìœ¼ë¡œë§Œ ì œì–´)
    state.stats.damageTaken = (state.stats.damageTaken||0) + shLost + hpLost;

    // 2.5) EMP/ì°¨ë‹¨ ë””ë²„í”„(ì /ë³´ìŠ¤ ê³µê²© ì˜µì…˜)
    if (opts) {
      const tNow = gameSec();
      if (opts.shieldRegenBlockDur) {
        state.core.shieldRegenBlockedUntil = Math.max(state.core.shieldRegenBlockedUntil||0, tNow + opts.shieldRegenBlockDur);
      }
      if (opts.repairBlockDur) {
        state.core.repairBlockedUntil = Math.max(state.core.repairBlockedUntil||0, tNow + opts.repairBlockDur);
      }
      if (opts.empDur) {
        state.core.empUntil = Math.max(state.core.empUntil||0, tNow + opts.empDur);
        if (opts.empMul !== undefined) state.core.empMul = opts.empMul;
      }

      // FX(ìŠ¤íŒ¸ ë°©ì§€)
      const showEmp = (opts.empDur || opts.shieldRegenBlockDur || opts.repairBlockDur);
      if (showEmp) {
        const last = state.core._empFxAt || 0;
        if (tNow - last > 0.9) {
          state.core._empFxAt = tNow;
          fxText("EMP êµë€!", CORE_POS.x, CORE_POS.y - 120, "#fbbf24");
          fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+14, CORE_RADIUS+110, "#fbbf24");
        }
      }
    }

    // ë¯¸ì…˜: ì½”ì–´ HP í”¼í•´ ê°ì§€
    try {
      const hpLoss = Math.max(0, prevHP - state.core.hp);
      if (hpLoss > 0.001) onMissionCoreHpDamage(hpLoss);
    } catch(e) {}



    // 3) ë¶•ê´´
    if (state.core.hp <= 0) {
      state.core.hp = 0;
      // ë¶•ê´´ ì‹œ ë³´í˜¸ë§‰ì€ ì¦‰ì‹œ 0
      state.core.shield = 0;
      triggerCollapse();
    }
  }

  // ---------- Flow ----------
  function startWave(){
  if (state.phase === "fail") return;

  if (!state.core.passiveId) {
    if (!state.core.passivePreviewId) { setMsg("ì½”ì–´ íŒ¨ì‹œë¸Œë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.", 2.2); return; }
    // ë¯¸ë¦¬ë³´ê¸°ë¡œ ê³ ë¥¸ íŒ¨ì‹œë¸Œë¥¼ ì›¨ì´ë¸Œ ì‹œì‘ ìˆœê°„ í™•ì •
    selectCorePassive(state.core.passivePreviewId);
  }

  // âœ… ì²« ì›¨ì´ë¸Œ(1) ì‹œì‘ ìˆœê°„ íŒ¨ì‹œë¸Œë¥¼ ì ê¸ˆ: ì¬ì‹œì‘ ì „ê¹Œì§€ ë³€ê²½ ë¶ˆê°€
  if (!state.core.passiveLocked && state.wave === 1) {
    state.core.passiveLocked = true;
    try { refreshCorePassiveUI(); } catch {}
  }

  // âœ… ì²« ì›¨ì´ë¸Œ(1) ì‹œì‘ ìˆœê°„ ë‚œì´ë„ ì ê¸ˆ: ì¬ì‹œì‘ ì „ê¹Œì§€ ë³€ê²½ ë¶ˆê°€
  if (!state.diffLocked && state.wave === 1) {
    state.diffLocked = true;
    try { refreshDiffUI(); } catch {}
  }

  SFX.play("wave");
  if (state.wave === FINAL_WAVE) {
    SFX.play("warning");
    // ìµœì¢…ì „: ìˆ˜ì •íƒ‘ ì—ë„ˆì§€ ì§‘ì† ì‹œì‘ ì—°ì¶œ
    fxShieldWave(CORE_POS.x, CORE_POS.y, 140, 0.75);
  }


  resetMods();
  applyContractForWave();
  applyMapModsForWave();
  try { refreshMapUI(); } catch {}
  try { document.body.classList.toggle('bg-final', (state.wave === FINAL_WAVE)); } catch {}
  // íšŒìˆ˜ í”„ë¡œí† ì½œ: ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ ì¹´ìš´í„° ë¦¬ì…‹
  state.core.passiveSalvageThisWave = 0;
  state.core.shieldRegenBlockedUntil = 0;

  // ì—…ê·¸ë ˆì´ë“œ: ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ ë³´í˜¸ë§‰ ë³´ë„ˆìŠ¤
  const waveShieldBonus = 20*state.upg.waveShield;
  if (waveShieldBonus > 0) {
    state.core.shield = clamp(state.core.shield + waveShieldBonus, 0, state.core.shieldMax);
  }

  // ìµœì¢… ì›¨ì´ë¸Œ(30): ì¼ë°˜ ì´ë²¤íŠ¸ëŠ” ë°œìƒí•˜ì§€ ì•ŠìŒ. (ëŒ€ì‹  ìµœì¢… ì§€ì› ì„ íƒ)
  if (state.wave !== FINAL_WAVE) {
    state.event = chooseEvent();
    if (state.event) {
      state.event.apply(state);
      state.eventTextTimer = 3.2;
      fxText(`ì´ë²¤íŠ¸: ${state.event.name}`, CORE_POS.x, CORE_POS.y - 92, "#fbbf24");
    }
  } else {
    state.event = null;
    state.eventTextTimer = 0;

    // ìµœì¢… ì§€ì›(ì„ íƒ ì—†ìœ¼ë©´ ë°©í˜¸ ê°•í™”)
    const choice = state.finalChoice || "defense";
    state.finalChoice = choice;
    if (choice === "offense") {
      state.mods.turretDmgMul *= 1.15;
    } else {
      state.mods.shieldRegenMul *= 1.25;
    }
    fxText(`ìµœì¢… ì§€ì›: ${choice==="offense" ? "í™”ë ¥ ì§€ì›" : "ë°©í˜¸ ê°•í™”"}`, CORE_POS.x, CORE_POS.y - 112, "#93c5fd");

    // ìµœì¢… ë³´ìŠ¤ íŒ¨í„´ ìƒíƒœ ì´ˆê¸°í™”
    state.final = {
      phase: 1,
      nextSummonAt: gameSec() + 4.5,
      nextShieldJamAt: gameSec() + 7.0,
      nextLaserAt: gameSec() + 6.0,
      nextEmpAt: gameSec() + 9.0,
      nextOrbsAt: gameSec() + 8.0,
      empUntil: 0,
      empMul: 0.55,
    };
  }

  // ì›¨ì´ë¸Œ ëª©í‘œ(ë¯¸ì…˜)
  startMissionForWave(state.wave);

  state.phase = "wave";
  if (state.wave === FINAL_WAVE) {
    fxText("ìµœì¢… ì›¨ì´ë¸Œ!", CORE_POS.x, CORE_POS.y - 92, "#93c5fd");
  }
  const spec = waveSpec(state.wave);

  // ì—°ì¶œ: ì›¨ì´ë¸Œ ì‹œì‘ ì¹´ë“œ(ì™„ì„±ê°)
  try {
    const sub = (state.wave===FINAL_WAVE) ? "ìµœì¢… ë³´ìŠ¤" : (spec && spec.name ? spec.name : "");
    cineCard(`WAVE ${state.wave}`, sub, "#93c5fd", 1.25);
    fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+12, CORE_RADIUS+160, "#93c5fd");
  } catch {}

  state.spawn = { spec, spawned: 0, nextSpawnIn: 0 };
  // BGM: ë³´ìŠ¤ ì›¨ì´ë¸Œì—ì„œëŠ” ë” ê°•í•˜ê²Œ
  try { SFX.setBgmMode((state.wave === FINAL_WAVE) ? "final1" : (spec.isBoss ? "boss" : "wave")); } catch {}
  state.crystals += Math.floor(10 + state.wave*2);
}

  function drawResonanceScreenFlash(){
    const tt = gameSec();
    const until = state.resFlashUntil || 0;
    const rem = Math.max(0, until - tt);
    if (rem <= 0) return;
    const dur = state.resFlashDur || 0.16;
    const k = clamp(rem / dur, 0, 1);
    const a = 0.32 * k;
    const x = (typeof state.resFlashX === 'number') ? state.resFlashX : CORE_POS.x;
    const y = (typeof state.resFlashY === 'number') ? state.resFlashY : CORE_POS.y;

    ctx.save();
    ctx.globalAlpha = a;
    ctx.globalCompositeOperation = 'lighter';
    const r = lerp(180, 520, 1-k);
    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
    g.addColorStop(0.0, 'rgba(255,237,213,1)');
    g.addColorStop(0.35, 'rgba(253,186,116,0.85)');
    g.addColorStop(1.0, 'rgba(253,186,116,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // very light full-screen blink
    ctx.globalAlpha = a * 0.22;
    ctx.fillStyle = 'rgba(253,186,116,1)';
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }




  function drawPassiveScreenVignette(){
    const id = state.core && state.core.passiveId;
    if (!id) return;
    if (state.phase === "fail" || state.phase === "win") return;

    const t = state.time || 0;
    let a = 0.0;
    let rgb = null;

    if (id === "rebuild") {
      const sh = clamp(state.core.shield / state.core.shieldMax, 0, 1);
      const hp = clamp(state.core.hp / state.core.hpMax, 0, 1);
      const need = 1 - Math.min(sh, hp);
      a = 0.08 + 0.22*need;
      rgb = [96,165,250];
    } else if (id === "resonance") {
      const g01 = (typeof resonanceGauge01 === 'function') ? resonanceGauge01() : 0;
      const pulse = 0.60 + 0.40*Math.sin(t*2.6 + g01*1.4);
      a = (0.06 + 0.22*g01) * pulse;
      rgb = [253,186,116];
    } else if (id === "overload") {
      const hpFrac = (state.core.hpMax>0) ? (state.core.hp/state.core.hpMax) : 1;
      const trig = (typeof OVERLOAD_CFG === 'object' && OVERLOAD_CFG) ? OVERLOAD_CFG.triggerHp : 0.30;
      const danger = clamp((trig + 0.20 - hpFrac)/0.20, 0, 1);
      const burst = (typeof overloadBurstActive === 'function' && overloadBurstActive()) ? 1 : 0;
      const pulse = 0.55 + 0.45*Math.sin(t*(5.0 + 5.0*burst));
      a = (0.08 + 0.24*danger + 0.16*burst) * pulse;
      rgb = [251,113,133];
    } else if (id === "overdrive") {
      const hpFrac = (state.core.hpMax>0) ? (state.core.hp/state.core.hpMax) : 1;
      const m = clamp(1 - hpFrac, 0, 1);
      const pulse = 0.60 + 0.40*Math.sin(t*2.2 + m*2.0);
      a = (0.07 + 0.22*m) * pulse;
      rgb = [216,180,254];
    }

    if (!rgb || a <= 0.001) return;

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const cx = W*0.5, cy = H*0.5;
    const r0 = 120;
    const r1 = Math.max(W,H)*0.85;

    const edgeA = Math.min(0.24, 0.18*a);
    const edgeB = Math.min(0.18, 0.12*a);

    const g = ctx.createRadialGradient(cx, cy, r0, cx, cy, r1);
    g.addColorStop(0.0, 'rgba(0,0,0,0)');
    g.addColorStop(0.60, 'rgba(0,0,0,0)');
    g.addColorStop(0.90, `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${edgeA})`);
    g.addColorStop(1.0,  `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0)`);

    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // overdrive: subtle speed streaks at the edges
    if (id === 'overdrive') {
      ctx.globalAlpha = Math.min(0.35, 0.22*a);
      ctx.strokeStyle = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${edgeB})`;
      ctx.lineWidth = 2;
      const n = 10;
      for (let i=0;i<n;i++){
        const yy = (i+0.5) * (H/n) + 10*Math.sin(t*1.7 + i);
        const x0 = -40;
        const x1 = 120 + 80*Math.sin(t*1.3 + i*0.9);
        ctx.beginPath();
        ctx.moveTo(x0, yy);
        ctx.lineTo(x1, yy - 20);
        ctx.stroke();

        const x2 = W + 40;
        const x3 = W - 120 - 80*Math.sin(t*1.5 + i*0.8);
        ctx.beginPath();
        ctx.moveTo(x2, yy);
        ctx.lineTo(x3, yy + 20);
        ctx.stroke();
      }
    }

    ctx.restore();
  }


  function clearWave(){
  if (state.phase === "fail") return;

  const clearedWave = state.wave;


  // FINAL WAVE clear -> Victory ending
  if (state.wave >= FINAL_WAVE) { triggerWin(); return; }

  // ì›¨ì´ë¸Œ ëª©í‘œ ë³´ìƒ ì²˜ë¦¬
  try { finalizeMissionOnWaveClear(clearedWave); } catch(e) {}

  SFX.play("clear");
  state.phase = "clear";
  // BGM: ì „íˆ¬ ì¢…ë£Œ -> ê¸°ë³¸ ëª¨ë“œ
  try { SFX.setBgmMode("build"); } catch {}
  if (state.ui.autoStartEnabled) state.autoStartAt = gameSec() + state.autoStartDelay;
  else state.autoStartAt = 0;
  state.wave += 1;
  try { prepareNextMissionForWave(state.wave|0); } catch(e) {}
  state.crystals += Math.floor(25 + state.wave*3);
  fxText("ì›¨ì´ë¸Œ í´ë¦¬ì–´!", CORE_POS.x, CORE_POS.y - 72, "#a7f3d0");

  // ì—°ì¶œ: ì›¨ì´ë¸Œ ì¢…ë£Œ ì¹´ë“œ
  try {
    const next = state.wave;
    const gain = Math.floor(25 + next*3);
    cineCard("WAVE CLEAR", `ë‹¤ìŒ: WAVE ${next} Â· +${gain} í¬ë¦¬ìŠ¤íƒˆ`, "#a7f3d0", 1.25);
  } catch {}

  // ì›¨ì´ë¸Œ 29 í´ë¦¬ì–´ í›„ -> ìµœì¢…ì „ ì¤€ë¹„(ì›¨ì´ë¸Œ 30 ì „ìš©)
  if (state.wave === FINAL_WAVE) {
    state.phase = "finalprep";
    resetFinalCharge();
    fxShieldWave(CORE_POS.x, CORE_POS.y, 110, 0.55);

    state.autoStartAt = 0;

    // ì¤€ë¹„ ì‹œê°„/ë³´ìƒ/ì •ë¹„
    const PREP_SEC = 15.0;
    state.finalPrepEndsAt = gameSec() + PREP_SEC;
    state.finalChoice = null;
    state.final = null;
    state._finalBossJustDied = false;
    state.win = null;
    resetFinalCharge();


    // ë³´ë„ˆìŠ¤ ìì› + ì •ë¹„
    state.crystals += 90;
    state.core.hp = clamp(state.core.hp + state.core.hpMax*0.18, 0, state.core.hpMax);
    state.core.shield = clamp(state.core.shield + state.core.shieldMax*0.22, 0, state.core.shieldMax);
    state.core.repairCd = 0; // ìˆ˜ë¦¬ ì¿¨ ì´ˆê¸°í™”
    fxText("ìµœì¢…ì „ ì¤€ë¹„!", CORE_POS.x, CORE_POS.y - 92, "#93c5fd");
  }
}


  function triggerWin(){
  if (state.phase === "fail") return;
  state.phase = "win";

  // BGM: ìŠ¹ë¦¬ ëª¨ë“œ(ì¡°ê¸ˆ ë°ê²Œ)
  try { SFX.setBgmMode("win"); } catch {}
  state.win = {
    t: 0,
    stage: 0,
    beam: 0,
    rings: [
      {t:0, delay:0.0},
      {t:0, delay:0.45},
      {t:0, delay:0.90},
    ],
    flash: 0,
  };

  // freeze spawns / enemies: keep them for dissolve
  if (state.spawn) state.spawn = null;
  for (const e of state.enemies) {
    e.vx = 0; e.vy = 0;
    e.dissolve = 0;
    e.hitByCleanse = false;
  }

  // stats snapshot
  state.stats.finalWave = FINAL_WAVE;
  state.stats.runEnd = nowSec();
  try { updateRecordsWithRun(buildRunSummary(true)); renderRecords(true); } catch(e) {}

  // SFX: ìŠ¹ë¦¬ ì „ìš© ì§•ê¸€(ìˆ˜ì •íƒ‘ ë¶•ê´´ ì‚¬ìš´ë“œì™€ ë¶„ë¦¬)
  try { ensureAudio(); } catch {}
  SFX.play("victory");
  setTimeout(()=>{ try { ensureAudio(); SFX.play("clear"); } catch {} }, 720);

  // UI message
  state.uiMsg = "ì •í™” ì™„ë£Œ ì‹œí€€ìŠ¤ ì‹œì‘...";
  state.uiMsgUntil = nowSec() + 3.0;
}



function updateWin(dt){
  if (!state.win) return;
  const w = state.win;
  w.t += dt;

  // stage timings
  // 0: pre-pulse (0~1.2), 1: beam (1.2~2.7), 2: rings+dissolve (2.7~5.2), 3: end screen (5.2+)
  if (w.t < 1.2) w.stage = 0;
  else if (w.t < 2.7) w.stage = 1;
  else if (w.t < 5.2) w.stage = 2;
  else w.stage = 3;

  // flash for first second
  w.flash = Math.max(0, 1 - w.t*1.6);

  // beam grow
  if (w.stage >= 1) {
    const t = clamp((w.t - 1.2) / 1.3, 0, 1);
    w.beam = t;
  }

  // rings
  if (w.stage >= 2) {
    for (const r of w.rings) {
      r.t += dt;
    }
    // dissolve enemies as rings pass
    const maxR = Math.max(...w.rings.map(r=> ringRadius(r)));
    for (const e of state.enemies) {
      if (!e.hitByCleanse) {
        const d = dist(e.x,e.y, CORE_POS.x, CORE_POS.y);
        if (d <= maxR + 4) {
          e.hitByCleanse = true;
        }
      }
      if (e.hitByCleanse) {
        e.dissolve = clamp((e.dissolve || 0) + dt*1.25, 0, 1);
      }
    }
    // remove fully dissolved
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      if ((e.dissolve||0) >= 0.999) state.enemies.splice(i,1);
    }
  }

  // keep shield stable and full-ish during ending (looks "resolved")
  state.core.shield = clamp(state.core.shield + state.core.shieldRegen*0.6*dt, 0, state.core.shieldMax);

  // fx update so particles keep running
  for (let i = state.fx.length - 1; i >= 0; i--) {
    const f = state.fx[i];
    f.t += dt;
    if (f.t >= f.dur) state.fx.splice(i,1);
  }
  state.eventTextTimer = Math.max(0, state.eventTextTimer - dt);
}

function ringRadius(r){
  const t = Math.max(0, r.t - r.delay);
  // fast expansion with fade later
  return 30 + t*240;
}

function drawWinOverlay(){
  if (!state.win) return;
  const w = state.win;

  // vignette
  ctx.save();
  ctx.globalAlpha = 0.28 + 0.22*Math.sin(w.t*2.1);
  const g = ctx.createRadialGradient(CORE_POS.x, CORE_POS.y, 60, CORE_POS.x, CORE_POS.y, 360);
  g.addColorStop(0, "rgba(96,165,250,0.0)");
  g.addColorStop(1, "rgba(96,165,250,0.85)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
  ctx.restore();

  // beam
  if (w.stage >= 1) {
    const a = 0.25 + 0.55*w.beam;
    ctx.save();
    ctx.globalAlpha = a;
    const beamW = 34 + 40*w.beam;
    const bx = CORE_POS.x - beamW/2;
    const by = 0;
    const bh = CORE_POS.y;
    const bg = ctx.createLinearGradient(0, by, 0, bh);
    bg.addColorStop(0, "rgba(96,165,250,0.0)");
    bg.addColorStop(0.55, "rgba(96,165,250,0.65)");
    bg.addColorStop(1, "rgba(96,165,250,0.95)");
    ctx.fillStyle = bg;
    ctx.fillRect(bx, by, beamW, bh);
    // core glow
    ctx.globalAlpha = a*0.8;
    ctx.beginPath();
    ctx.arc(CORE_POS.x, CORE_POS.y, CORE_RADIUS+26, 0, Math.PI*2);
    ctx.fillStyle = "rgba(96,165,250,0.22)";
    ctx.fill();
    ctx.restore();
  }

  // cleanse rings
  if (w.stage >= 2) {
    ctx.save();
    for (const rr of w.rings) {
      const rad = ringRadius(rr);
      const t = Math.max(0, rr.t - rr.delay);
      const alpha = clamp(0.55 - t*0.18, 0, 0.55);
      if (alpha <= 0) continue;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = "#60a5fa";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(CORE_POS.x, CORE_POS.y, rad, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  // flash (impact)
  if (w.flash > 0.01) {
    ctx.save();
    ctx.globalAlpha = w.flash*0.35;
    ctx.fillStyle = "#93c5fd";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  // end screen text
  if (w.stage >= 3) {
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(15,23,42,0.72)";
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = "#e5e7eb";
    ctx.font = "700 44px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("ì •í™” ì™„ë£Œ", W/2, 150);

    ctx.font = "500 16px system-ui, sans-serif";
    ctx.fillStyle = "#cbd5e1";
    ctx.fillText("ì¹¨ì‹ ì£¼íŒŒìˆ˜ê°€ ë’¤ì§‘í˜”ìŠµë‹ˆë‹¤. ì§€ì—­ì€ ì•ˆì „í•´ì¡ŒìŠµë‹ˆë‹¤.", W/2, 182);

    const tPlay = Math.max(0, (state.stats.runEnd || nowSec()) - (state.stats.runStart || nowSec()));
    const lines = [
      `ë„ë‹¬ ì›¨ì´ë¸Œ: ${FINAL_WAVE}`,
      `ì´ ì²˜ì¹˜: ${state.stats.kills|0}`,
      `ë°›ì€ í”¼í•´: ${Math.round(state.stats.damageTaken)|0}`,
      `ìˆ˜ë¦¬ íšŸìˆ˜: ${state.stats.repairs|0}`,
      `í”Œë ˆì´ ì‹œê°„: ${formatTime(tPlay)}`
    ];

    ctx.font = "600 18px system-ui, sans-serif";
    ctx.fillStyle = "#e2e8f0";
    let y = 240;
    for (const ln of lines){
      ctx.fillText(ln, W/2, y);
      y += 26;
    }

    ctx.font = "600 16px system-ui, sans-serif";
    ctx.fillStyle = "#93c5fd";
    ctx.fillText("R: ì¬ì‹œì‘", W/2, H - 90);

    ctx.restore();
  }
}

function formatTime(sec){
  const s = Math.floor(sec % 60);
  const m = Math.floor((sec/60) % 60);
  const h = Math.floor(sec/3600);
  if (h > 0) return `${h}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  return `${m}:${String(s).padStart(2,"0")}`;
}

function restart(){
    state.gtime = 0;
    state.lastTime = nowSec();
    state.wave = 1;
    state.phase = "build";
    state.diffLocked = false;
    state.crystals = 80;
    state.selected = "basic";

    // ëŸ° ìŠ¤íƒ¯ ë¦¬ì…‹(ê¸°ë¡ ì €ì¥ìš©)
    state.stats = { runStart: nowSec(), runEnd: 0, finalWave: 0, kills: 0, damageTaken: 0, repairs: 0, turretBuilt: { basic:0, slow:0, splash:0, shred:0, breaker:0 } };

    state.enemies.length = 0;
    state.turrets.length = 0;
    state.projectiles.length = 0;
    state.fx.length = 0;

    state.flames.length = 0;
    state.flameSpawnAcc = 0;

    state.debris.length = 0;
    state.collapse = null;

    // ì¹´ë©”ë¼ í”ë“¤ë¦¼(ìŠ¤í‚¬/ë¶•ê´´) ë¦¬ì…‹
    state.camShakeUntil = 0;
    state.camShakeDur = 0;
    state.camShakeMag = 0;

    state.event = null;
    state.eventTextTimer = 0;
    resetMods();

    // ì›¨ì´ë¸Œ ëª©í‘œ(ë¯¸ì…˜) ë¦¬ì…‹
    state.mission = null;
    state.nextMission = null;
    try { prepareNextMissionForWave(state.wave|0); } catch(e) {}

    // ë§µ ê¸°ë¯¹: ì¬ì‹œì‘ë§ˆë‹¤ ëœë¤ ì„ íƒ
    rollMapForRun();
    applyMapVisual();
    try { document.body.classList.remove('bg-final'); } catch(e) {}
    try { refreshMapUI(true); } catch(e) {}

    // core base values -> upgrades ë°˜ì˜
    state.core.hpMax = CORE_BASE.hpMax; state.core.hp = CORE_BASE.hpMax;
    state.core.shieldMax = CORE_BASE.shieldMax; state.core.shield = CORE_BASE.shieldMax;
    state.core.shieldRegen = CORE_BASE.shieldRegen;
    state.core.hpArmor = CORE_BASE.hpArmor;
    state.core.shieldArmor = CORE_BASE.shieldArmor;
    state.core.repairCost = CORE_BASE.repairCost;
    state.core.repairAmount = CORE_BASE.repairAmount;
    state.core.repairCd = CORE_BASE.repairCd;
    state.core.repairReadyAt = 0; // ì¬ì‹œì‘ ì‹œ ìˆ˜ë¦¬ ì¿¨íƒ€ì„ ë¦¬ì…‹
    state.core.energyReadyAt = 0; // ì¬ì‹œì‘ ì‹œ ì—ë„ˆì§€í¬ ì¿¨ ë¦¬ì…‹
    state.core.energyCharging = false;
    state.core.energyLock = null;
    state.core.energyChargeStartAt = 0;
    state.core.energyChargeUntil = 0;
    state.core.energyChargeFxAt = 0;
    // âœ… ì—ë„ˆì§€í¬ ì”ìƒ/ì¶©ì „ ì”ë¥˜ ë°ì´í„° ë¦¬ì…‹(ì¬ì‹œì‘ í›„ í”Œë˜ì‹œ/ì”ìƒ ë‚¨ëŠ” ë²„ê·¸ ë°©ì§€)
    state.core.energyFlashUntil = 0;
    state.core.energyChargeOrbs = [];
    state.core.energyChargeLastT = 0;
    state.core.energyChargeOrbAt = 0;
    state.core.energyChargeReadySfx = false;

    // âœ… ê³µëª… ë°˜ê²© í™”ë©´ í”Œë˜ì‹œ ì”ìƒ ë¦¬ì…‹(ì¬ì‹œì‘ í›„ ì˜¤ë˜ ë‚¨ëŠ” ë²„ê·¸ ë°©ì§€)
    state.resFlashUntil = 0;
    state.resFlashDur = 0;
    state.resFlashX = 0;
    state.resFlashY = 0;
    state.upg = { coreHp:0, coreShield:0, hpArmor:0, shieldArmor:0, shieldRegen:0, energyCannon:0, repair:0, turretDmg:0, turretFire:0, turretRange:0, slowPower:0, splashRadius:0, projSpeed:0, turretCrit:0, slowDuration:0, aegisTune:0, waveShield:0, shredFocus:0, breakerMark:0 };
    applyUpgrades();
    state.core.aegisReadyAt = 0;
    state.core.aegisActiveUntil = 0;

    // ë°©ë²½(Barrier) ë¦¬ì…‹
    state.core.barrierActive = false;
    state.core.barrierReadyAt = 0;
    state.core.barrierUntil = 0;
    state.core._barrierHitFxAt = -999;

    // ìƒì  ì†Œë¹„ ì•„ì´í…œ ë¦¬ì…‹(ì¬ì‹œì‘ ì‹œ ì¿¨/ë²„í”„ ì”ë¥˜ ë°©ì§€)
    if (!state.shop) {
      state.shop = { repairReadyAt: 0, fireReadyAt: 0, slowReadyAt: 0, fireUntil: 0, slowWave: 0 };
    } else {
      state.shop.repairReadyAt = 0;
      state.shop.fireReadyAt = 0;
      state.shop.slowReadyAt = 0;
      state.shop.fireUntil = 0;
      state.shop.slowWave = 0;
    }

    state.spawn = null;
    state.autoStartAt = 0;
    state.finalPrepEndsAt = 0;
    state.finalChoice = null;
    state.final = null;
    state.core.shieldRegenBlockedUntil = 0;

    state.core.repairBlockedUntil = 0;
    state.core.empUntil = 0;
    state.core._empFxAt = -999;
        // ì½”ì–´ íŒ¨ì‹œë¸Œ: ì¬ì‹œì‘ ì‹œ ë‹¤ì‹œ ì„ íƒ
    state.core.passiveId = null;
    state.core.passiveLocked = false;
    state.core.passivePreviewId = null;
    state.core.passiveStacks = 0;
    state.core.passiveLastHitAt = gameSec();
    state.core.passiveStackDecayAcc = 0;
    state.core.overdriveShotAcc = 0;
    state.core.passiveSalvageThisWave = 0;

    resonanceReset();
    state.core.rebuildEmergencyUntil = 0;
    state.core.rebuildEmergencyReadyAt = 0;

    // ì„ê³„ ê³¼ë¶€í•˜ ëˆ„ì  ìƒíƒœ ë¦¬ì…‹
    state.core.overloadBurstUntil = 0;
    state.core.overloadBurstReadyAt = 0;
    state.core.overloadWasAbove30 = true;
    state.core.overloadExtendReadyAt = 0;
    state.core.overloadKickReadyAt = 0;
    refreshCorePassiveUI();

    // BGM: ê¸°ë³¸(build) ëª¨ë“œë¡œ
    try { SFX.setBgmMode("build"); } catch {}

// âœ… ì™€ì´ì–´ ë¦¬ì…‹: ì„¸ê·¸ë¨¼íŠ¸ê¹Œì§€ ë¦¬ì…‹(ì¬ì‹œì‘ ê²€ì •ì„  ë²„ê·¸ ë°©ì§€)
    wireReset();
    wireTick(1); // full green
  }

  // ---------- Update ----------
  // ---------- Final Charge (Wave 30 core energy) ----------
  function isFinalChargeActive(){
    return (state.phase === "finalprep" || (state.phase === "wave" && state.wave === FINAL_WAVE));
  }

  function resetFinalCharge(){
    state.core.finalCharge = 0;
    state.core.finalChargeAcc = 0;
    if (state.core.finalChargeOrbs) state.core.finalChargeOrbs.length = 0;
  }

  function updateFinalCharge(dt){
    const active = isFinalChargeActive();
    if (!active) {
      // ìì—°ìŠ¤ëŸ½ê²Œ êº¼ì§€ë„ë¡ ì•½í•˜ê²Œ ê°ì‡ 
      state.core.finalCharge = Math.max(0, (state.core.finalCharge || 0) - dt*0.35);
      state.core.finalChargeAcc = 0;
      if (state.core.finalChargeOrbs) state.core.finalChargeOrbs.length = 0;
      return;
    }

    // ì¤€ë¹„ ë‹¨ê³„(finalprep): 55%ê¹Œì§€ë§Œ ì²œì²œíˆ ì±„ì›€(â€œì´ì œë¶€í„° ëª¨ì¸ë‹¤â€ ëŠë‚Œ)
    if (state.phase === "finalprep") {
      const cap = 0.55;
      const rate = 0.14;
      state.core.finalCharge = clamp((state.core.finalCharge || 0) + dt*rate, 0, cap);
    } else {
      // ì›¨ì´ë¸Œ30: 'ìµœì¢… ë³´ìŠ¤ ì²´ë ¥'ì´ ì¤„ìˆ˜ë¡ ì§‘ì†ì´ ê°•í•´ì§
      let boss = null;
      for (let i=0;i<state.enemies.length;i++){
        const e = state.enemies[i];
        if (e && e.kind === "boss" && e.hp > 0) { boss = e; break; }
      }
      const hpRatio = boss ? clamp(boss.hp / (boss.hpMax || 1), 0, 1) : 1;
      const severity = clamp(1 - hpRatio, 0, 1);
      // 55%ë¥¼ ë°”ë‹¥ìœ¼ë¡œ ê¹”ê³ , ë³´ìŠ¤ ì²´ë ¥ì´ ê¹ì¼ìˆ˜ë¡ 100%ê¹Œì§€ ìƒìŠ¹ (ì‚´ì§ ê³¡ì„ )
      const target = 0.55 + Math.pow(severity, 0.85) * 0.45;
      state.core.finalCharge = clamp(Math.max(state.core.finalCharge || 0, target), 0, 1.0);
    }

    const c = clamp(state.core.finalCharge || 0, 0, 1);

    // ì…ì ìƒì„±(ì§‘ì† ê°•ë„ì— ë”°ë¼ ë” ì´˜ì´˜/ë¹ ë¥´ê²Œ)
    const baseSpawn = (state.phase === "finalprep") ? 0.06 : 0.095;
    const spawnInt = (state.phase === "finalprep") ? baseSpawn : lerp(baseSpawn, 0.040, c);
    state.core.finalChargeAcc = (state.core.finalChargeAcc || 0) + dt;
    if (!state.core.finalChargeOrbs) state.core.finalChargeOrbs = [];

    while (state.core.finalChargeAcc >= spawnInt) {
      state.core.finalChargeAcc -= spawnInt;
      const a = rand(0, Math.PI*2);
      const r = rand(240, 330);
      const v = rand(190, 280) * (state.phase === "finalprep" ? 1.0 : lerp(1.0, 1.55, c));
      const spin = rand(-2.6, 2.6) * (state.phase === "finalprep" ? 1.0 : lerp(1.0, 1.25, c));
      const life = rand(0.7, 1.15);
      state.core.finalChargeOrbs.push({ a, r, v, spin, t:0, life });
    }

    // ì…ì ì´ë™/ì†Œë©¸
    for (let i = state.core.finalChargeOrbs.length - 1; i >= 0; i--) {
      const o = state.core.finalChargeOrbs[i];
      o.t += dt;
      o.a += o.spin * dt;
      o.r -= o.v * dt;
      if (o.r < 34 || o.t > o.life) {
        // ì•„ì£¼ ì•½í•œ ë§(ê³¼ë„í•œ ë²ˆì©ì„ ë°©ì§€) - ì§‘ì†ì´ ê°•í•´ì§ˆìˆ˜ë¡ ì¡°ê¸ˆ ë” ì„ ëª…
        fxRing(CORE_POS.x, CORE_POS.y, 52, 78, `rgba(96,165,250,${(0.22 + 0.22*c).toFixed(3)})`);
        state.core.finalChargeOrbs.splice(i,1);
      }
    }
  }


  function update(dt){
    state.time += dt;

    // ë°©ë²½ ë§Œë£Œ ì²˜ë¦¬(1ì´ˆ)
    try {
      if (state.core.barrierActive) {
        const tNow = gameSec();
        if (tNow >= (state.core.barrierUntil||0)) state.core.barrierActive = false;
      }
    } catch(e) {}


    // ì—ë„ˆì§€í¬ ì¶©ì „/ìë™ë°œì‚¬ ì²˜ë¦¬
    updateEnergyCharge();

    // ë¶•ê´´ ìƒíƒœ
    if (state.phase === "fail" && state.collapse) {
      state.collapse.t += dt;
      state.collapse.boomT += dt;
      state.collapse.shake = Math.max(0, 1 - state.collapse.t*0.9);
      state.collapse.fade  = clamp((state.collapse.t - 0.65) / 1.2, 0, 1);

      // âœ… ë¶•ê´´ ì¤‘: ë³´í˜¸ë§‰/ë¶ˆê½ƒ ì™„ì „ ì œê±° ê³ ì •
      state.core.shield = 0;
      state.flames.length = 0;
      state.flameSpawnAcc = 0;

      updateDebris(dt);

      for (let i = state.fx.length - 1; i >= 0; i--) {
        const f = state.fx[i];
        f.t += dt;
        if (f.t >= f.dur) state.fx.splice(i,1);
      }
      state.eventTextTimer = Math.max(0, state.eventTextTimer - dt);

      wireTick(0);
      return;
    }

    // ì •ìƒ ìƒíƒœ
    // ìŠ¹ë¦¬ ì—”ë”© ìƒíƒœ
    if (state.phase === "win" && state.win) {
      updateWin(dt);
      // ì›¨ì´ë¸Œ ëª©í‘œ(ë¯¸ì…˜) ì§„í–‰ ì²´í¬
    try { missionTick(dt); } catch(e) {}

    wireTick(state.core.hp / state.core.hpMax);
      return;
    }

    updateBlueFlames(dt);
    // shield regen
    // ê¸°ë³¸: ì›¨ì´ë¸Œ ì¤‘ì—ë§Œ ë³´í˜¸ë§‰ì´ ìë™ ì¬ìƒë©ë‹ˆë‹¤.
    // (ì›í•˜ì‹œë©´ state.core.shieldRegenOutOfWave ë¥¼ trueë¡œ ë°”ê¾¸ë©´, ì›¨ì´ë¸Œ ë°–ì—ì„œë„ ì¬ìƒë©ë‹ˆë‹¤.)
    if (state.phase === "wave" || state.core.shieldRegenOutOfWave) {
      const t = nowSec();
      const regenBoost = (t < state.core.aegisActiveUntil) ? 3.2 : 1.0;
      let passiveShieldRegenMul = 1.0;
      // ì¬ê±´ ì½”ì–´: ë³´í˜¸ë§‰ ì¬ìƒ +15% (ìµœì¢…ì „ ì¶”ê°€ +10%)
      if (state.core.passiveId === "rebuild") {
        passiveShieldRegenMul *= passiveScaleMul(1.15);
        if (state.wave === FINAL_WAVE) passiveShieldRegenMul *= passiveScaleMul(1.10);
      }
      // ì„ê³„ ê³¼ë¶€í•˜: ìµœëŒ€ +110%
      if (state.core.passiveId === "overload") {
        const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
        const tO = clamp((0.40 - hpFrac) / 0.30, 0, 1);
        passiveShieldRegenMul *= (1 + passiveScale(1.10)*tO);
      }
      // ì½”ì–´ ì˜¤ë²„ë“œë¼ì´ë¸Œ: ìµœëŒ€ +60%
      if (state.core.passiveId === "overdrive") {
        const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
        const tO = clamp((0.40 - hpFrac) / 0.30, 0, 1);
        passiveShieldRegenMul *= (1 + passiveScale(0.60)*tO);
      }
if (gameSec() >= state.core.shieldRegenBlockedUntil) {
        const regen = state.core.shieldRegen * state.mods.shieldRegenMul * regenBoost * passiveShieldRegenMul;
        state.core.shield = clamp(state.core.shield + regen*dt, 0, state.core.shieldMax);
      }
    }
    // ì›¨ì´ë¸Œ 30: ìˆ˜ì •íƒ‘ ì—ë„ˆì§€ ì§‘ì† ì—…ë°ì´íŠ¸
    updateFinalCharge(dt);

    // HP ìë™ ìˆ˜ë¦¬(ì˜µì…˜)
    // - ê¸°ë³¸ì€ OFF ì…ë‹ˆë‹¤. (ì›¨ì´ë¸Œ ëë‚˜ê³  ê°€ë§Œíˆ ìˆì–´ë„ HPê°€ ì°¨ëŠ” ê±¸ ë§‰ê¸° ìœ„í•´)
    // - ì¼œê³  ì‹¶ìœ¼ë©´ state.core.passiveHpRegenEnabled = true ë¡œ ë°”ê¾¸ì„¸ìš”.
    // ì½”ì–´ íŒ¨ì‹œë¸Œ ê¸°ë°˜ HP ìë™ ìˆ˜ë¦¬
    // âœ… ì¬ê±´ ì½”ì–´: ì €ì²´ë ¥ì¼ìˆ˜ë¡ íšŒë³µëŸ‰â†‘, ìµœì¢…ì „ì—ì„œëŠ” ë”œë ˆì´â†“
    const hpRegenWanted = (state.core.passiveId === "rebuild");
    const hpRegenAllowPhase = (state.phase === "wave");

    if (hpRegenWanted && hpRegenAllowPhase && state.core.hp < state.core.hpMax) {
      const since = gameSec() - state.core.lastHpDamageAt;
      const isFinal = (state.wave === FINAL_WAVE);
      const delayMul = isFinal ? passiveScaleReduction(0.35) : 1.0;

      const delay = state.core.hpRegenDelay * delayMul;
if (since >= delay) {
        const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
        const missing = clamp(1 - hpFrac, 0, 1);
        const regen = state.core.hpRegenPerSec * (1 + passiveScale(0.90)*missing);
        state.core.hp = clamp(state.core.hp + regen*dt, 0, state.core.hpMax);
        if (state.core.hp >= state.core.hpMax - 0.001) state.core.hpDirectDamaged = false;
      }
    }

    // ê³µëª… ë°˜ê²©: ê²Œì´ì§€ ê°ì‡ /ë°©ì¶œ ì²˜ë¦¬
    updateResonance(dt);

    // ì„ê³„ ê³¼ë¶€í•˜: HP 30%â†“ ì§„ì… íŠ¸ë¦¬ê±°/ë²„ìŠ¤íŠ¸ ê´€ë¦¬
    updateOverload(dt);

    
    // auto-start next wave (clear phase)
    if (state.phase === "clear" && state.autoStartAt > 0) {
      if (gameSec() >= state.autoStartAt) {
        state.autoStartAt = 0;
        startWave();
      }
    }
// final prep (wave 30 before)
if (state.phase === "finalprep") {
  const left = state.finalPrepEndsAt - gameSec();
  if (left <= 0) {
    state.finalPrepEndsAt = 0;
    // ìµœì¢…ì „ ìë™ ì‹œì‘ ì œê±°: ì¤€ë¹„ë§Œ ëë‚´ê³  ëŒ€ê¸°(Build)ë¡œ ì „í™˜
    state.phase = "build";
    setMsg("ì¤€ë¹„ ì™„ë£Œ! [ì›¨ì´ë¸Œ ì‹œì‘]ìœ¼ë¡œ ì§„í–‰í•˜ì„¸ìš”.", 2.2);
  }
}

// wave spawn

    if (state.phase === "wave" && state.spawn) {
      const sp = state.spawn;
      const spec = sp.spec;
      sp.nextSpawnIn -= dt;

      const diff = state.diff || DIFF_PRESETS.normal;
      const rate = spec.spawnRate * (diff.spawnMul||1);
      while (sp.spawned < spec.count && sp.nextSpawnIn <= 0) {
        spawnEnemy(spec, sp.spawned);
        sp.spawned++;
        sp.nextSpawnIn += 1 / rate;
      }
      if (sp.spawned >= spec.count && state.enemies.length === 0) clearWave();
    }
// final boss patterns
if (state.phase === "wave" && state.wave === FINAL_WAVE) {
  updateFinalBoss(dt);
}



    // turrets
    for (const tr of state.turrets) {
      const s = turretBase(tr);
      const empMulFinal = (state.final && (gameSec() < state.final.empUntil)) ? state.final.empMul : 1.0;
      const empMulCore  = (gameSec() < (state.core.empUntil||0)) ? (state.core.empMul||0.75) : 1.0;
      const empMul = empMulFinal * empMulCore;
      const fireBuffMul = (state.shop && (gameSec() < (state.shop.fireUntil||0))) ? SHOP_ITEM_FIRE_MUL : 1.0;
      const fireRate = s.fireRate * state.mods.turretFireMul * empMul * fireBuffMul;
      tr.cd -= dt;

      let best = null, bestScore = Infinity;
      for (const e of state.enemies) {
        const d = dist(tr.x,tr.y, e.x,e.y);
        if (d > s.range) continue;
        const dCore = dist(e.x,e.y, CORE_POS.x, CORE_POS.y);
        const score = dCore*0.9 + d*0.25;
        if (score < bestScore) { bestScore = score; best = e; }
      }
      if (best && tr.cd <= 0) {
        fireTurret(tr, best);
        tr.cd = 1 / fireRate;
      }
    }

    // ì½”ì–´ íŒ¨ì‹œë¸Œ: ì½”ì–´ ì˜¤ë²„ë“œë¼ì´ë¸Œ(ìˆ˜ì •íƒ‘ ì§ì ‘ ê³µê²©)
    if (state.phase === "wave" && state.core.passiveId === "overdrive") {
      const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
      let m = clamp(1 - hpFrac, 0, 1); // missing HP (0~1)
      // ì¹˜íŠ¸: ì¼ì • ì‹œê°„ ë™ì•ˆ HPì™€ ë¬´ê´€í•˜ê²Œ ìµœëŒ€ ì¶œë ¥
      if (gameSec() < (state.core.overdriveCheatUntil||0)) m = 1;
      // ì²´ê° ê°•í™”: í‰ìƒì‹œì—ë„ ê°•í•˜ê³ , ì €ì²´ë ¥ì¼ìˆ˜ë¡ ë” ê°•í•´ì§
      const dmgMul0 = clamp(1.25 + 1.85*Math.pow(m, 1.35), 1.25, 3.10);
      const asMul0  = clamp(1.35 + 2.85*Math.pow(m, 1.10), 1.35, 4.20);
      const dmgMul = passiveScaleMul(dmgMul0);
      const asMul  = passiveScaleMul(asMul0);

      const baseInterval = 0.55;
      state.core.overdriveShotAcc = (state.core.overdriveShotAcc||0) + dt;
      const interval = clamp(baseInterval / asMul, 0.12, 0.75);

      // ì›¨ì´ë¸Œê°€ ì˜¤ë¥¼ìˆ˜ë¡ ê¸°ë³¸ í”¼í•´ê°€ ì™„ë§Œíˆ ì¦ê°€
      const baseDmg = 10 + state.wave * 0.65;
      let shotDmg = baseDmg * dmgMul * passiveHardMul();

      // ì ì´ ì—†ìœ¼ë©´ ëˆ„ì ë§Œ ë§‰ê³  ì¢…ë£Œ
      if (state.enemies.length === 0) {
        state.core.overdriveShotAcc = Math.min(state.core.overdriveShotAcc, interval);
      } else {
        // ìµœëŒ€ 3ì—°ì‚¬ê¹Œì§€ë§Œ(í”„ë ˆì„ ë“œë ì‹œ í­ì£¼ ë°©ì§€)
        let shots = 0;
        while (state.core.overdriveShotAcc >= interval && shots < 3) {
          shots++;
          state.core.overdriveShotAcc -= interval;

          
          // ì˜¤ë²„ë“œë¼ì´ë¸Œ ì‚¬ê²© SFX (ê³¼ë„í•œ ì¤‘ì²© ë°©ì§€)
          const sNow = nowSec();
          if (!state.core.overdriveSfxAt || (sNow - state.core.overdriveSfxAt) > 0.08) {
            state.core.overdriveSfxAt = sNow;
            try { SFX.play("core_shoot"); } catch {}
          }
// íƒ€ê²Ÿ: ìµœì¢…ë³´ìŠ¤/ë³´ìŠ¤ ìš°ì„ , ê·¸ ì™¸ì—ëŠ” ì½”ì–´ì— ê°€ê¹Œìš´ ì 
          let tgt = null, bestScore = 1e9;
          for (const e of state.enemies) {
            let score = dist(e.x, e.y, CORE_POS.x, CORE_POS.y);
            if (e.isFinalBoss) score -= 9999;
            else if (e.kind === "boss") score -= 4000;
            if (score < bestScore) { bestScore = score; tgt = e; }
          }
          if (!tgt) break;

          // ìµœì¢…ë³´ìŠ¤ëŠ” ê¸°ì¡´ ìˆœì‚­ë°©ì§€ ë‚´ì„±ê³¼ ë™ì¼í•œ ê³„ì—´ë¡œ ê°ì‡„
          let dmg = shotDmg;
          if (tgt.isFinalBoss) dmg *= finalBossIncomingMul();

          applyProjectileHit({ kind:"core", dmg, shieldMul:1.0 }, tgt);
          fxLine(CORE_POS.x, CORE_POS.y, tgt.x, tgt.y, "#93c5fd", 0.18, 3);
          fxRing(tgt.x, tgt.y, 6, 24, "#93c5fd");
        }
      }
    }


    // projectiles
    for (let i = state.projectiles.length - 1; i >= 0; i--) {
      const p = state.projectiles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;

      // enemy projectile -> hit core
      if (p.kind === "enemy") {
        const dCore = dist(p.x,p.y, CORE_POS.x, CORE_POS.y);
        if (dCore <= CORE_RADIUS + p.r) {
          damageCore(p.dmg, p.coreOpts || null);
          fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+8, CORE_RADIUS+68, "#fbbf24");
          state.projectiles.splice(i,1);
          continue;
        }
      }

      let hit = null;
      if (p.kind !== "enemy") {
        for (const e of state.enemies) {
        if (dist(p.x,p.y, e.x,e.y) <= e.r + p.r) { hit = e; break; }
        }
      }

      if (hit) {
        applyProjectileHit(p, hit);

        // ê´€í†µ(pierce): ë‚¨ì•„ìˆìœ¼ë©´ ì œê±°í•˜ì§€ ì•Šê³  ê³„ì† ì§„í–‰
        if ((p.pierce||0) > 0) {
          p.pierce--;
          if (!p.hitSet) p.hitSet = new Set();
          p.hitSet.add(hit);
          // ì‚´ì§ ì•ìœ¼ë¡œ ë°€ì–´ì„œ ê°™ì€ ì ì„ ë°”ë¡œ ì¬íƒ€ê²©í•˜ëŠ” í˜„ìƒ ì™„í™”
          p.x += p.vx * 0.01;
          p.y += p.vy * 0.01;
        } else {
          state.projectiles.splice(i,1);
        }
        continue;
      }

      if (p.life <= 0 || p.x < -50 || p.x > W+50 || p.y < -50 || p.y > H+50) {
        state.projectiles.splice(i,1);
      }
    }

    // enemies
    const diff = state.diff || DIFF_PRESETS.normal;
    for (let i = state.enemies.length - 1; i >= 0; i--) {
      const e = state.enemies[i];
      // ë°©ì–´ì : ë°°ì—´ì— ë¹ˆ ìš”ì†Œ/ê¹¨ì§„ ì—”íŠ¸ë¦¬ê°€ ì„ì´ë©´ slowUntil ì ‘ê·¼ì—ì„œ í¬ë˜ì‹œê°€ ë‚˜ë¯€ë¡œ ì œê±°í•©ë‹ˆë‹¤.
      if (!e || !Number.isFinite(e.x) || !Number.isFinite(e.y)) { state.enemies.splice(i,1); continue; }
      const tt = nowSec();
      if (tt > (e.slowUntil || 0)) e.slowMul = 1.0;
      else if (typeof e.slowMul !== 'number') e.slowMul = 1.0;
      if (typeof e.seedAng === 'number') e.seedAng += dt*0.35;

      // core vector
      let dx = CORE_POS.x - e.x;
      let dy = CORE_POS.y - e.y;
      let d = Math.hypot(dx,dy);
      if (d < 0.0001) d = 0.0001;

      // âœ… dx/dyê°€ 0ì— ê°€ê¹Œìš°ë©´(ì½”ì–´ ì¤‘ì‹¬ì— ê²¹ì¹¨) ë°©í–¥ì´ ì‚¬ë¼ì ¸ì„œ ë©ˆì¶œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
      // ì´ ê²½ìš°, ìŠ¤í° ë•Œ ì €ì¥í•´ë‘” ê°ë„(seedAng)ë¡œ ì„ì˜ ë°©í–¥ì„ ë¶€ì—¬í•©ë‹ˆë‹¤.
      if (Math.abs(dx) + Math.abs(dy) < 1e-6) {
        const ang = (typeof e.seedAng === 'number') ? e.seedAng : (Math.random()*Math.PI*2);
        dx = Math.cos(ang);
        dy = Math.sin(ang);
        d = 1.0;
      }

      const globalSlowMul = (state.shop && state.shop.slowWave === state.wave && state.phase === 'wave') ? SHOP_ITEM_SLOW_MUL : 1.0;
      const spd = e.spd * e.slowMul * globalSlowMul;

      // movement: melee -> rush, ranged -> hold distance + orbit
      let vx = dx/d, vy = dy/d;

      // âœ… ë²„ê·¸ ìˆ˜ì •: ì ì´ ì½”ì–´ ì¤‘ì‹¬ì— ê²¹ì³ì„œ 'ë©ˆì¶° ë³´ì´ëŠ”' í˜„ìƒ ë°©ì§€
      // ì½”ì–´ í‘œë©´ ê·¼ì²˜ì— ë„ë‹¬í•˜ë©´ ë°”ê¹¥ìœ¼ë¡œ ì‚´ì§ ë°€ì–´ë‚´ê³ , í‘œë©´ì„ ë”°ë¼ ë¯¸ë„ëŸ¬ì§€ë“¯ ì›€ì§ì…ë‹ˆë‹¤.
      const minDist = CORE_RADIUS + e.r + 6;
      if (d < minDist) {
        const nx = dx/d, ny = dy/d;
        e.x = CORE_POS.x - nx * minDist;
        e.y = CORE_POS.y - ny * minDist;

        // í‘œë©´ì„ ë”°ë¼ ì´ë™(íƒ±ì  íŠ¸)
        const tx = -ny, ty = nx;
        const dir = (typeof e.orbitDir === 'number') ? e.orbitDir : 1;
        vx = tx * dir;
        vy = ty * dir;

        // ì—…ë°ì´íŠ¸ëœ ê±°ë¦¬
        dx = CORE_POS.x - e.x;
        dy = CORE_POS.y - e.y;
        d = Math.hypot(dx,dy) || minDist;
      } else if (e.ranged && e.holdDist > 0 && d < e.holdDist) {
        const tx = -vy, ty = vx; // tangent
        const dir = (typeof e.orbitDir === 'number') ? e.orbitDir : 1;
        vx = tx * dir;
        vy = ty * dir;
      }

      e.x += vx * spd * dt;
      e.y += vy * spd * dt;

      // ranged shooting
      if (e.ranged && d < e.shootRange) {
        e.shotTimer -= dt;
        if (e.shotTimer <= 0) {
          enemyShoot(e);
          e.shotTimer = e.shotCd * (0.85 + 0.30*Math.random());
        }

      // shield supporter: pulse shield to nearby enemies
      if (e.kind === "supporter") {
        e.supportTimer = (e.supportTimer||0) - dt;
        if (e.supportFx) e.supportFx = Math.max(0, (e.supportFx||0) - dt);
        if (e.supportTimer <= 0) {
          e.supportTimer = (e.supportCd||1.80) * (0.85 + 0.35*Math.random());
          const R = e.supportR || 170;
          let did = false;
          for (const t of state.enemies) {
            if (!t || t === e) continue;
            const dd = dist(e.x, e.y, t.x, t.y);
            if (dd > R) continue;

            const mul = (t.kind === "boss") ? (e.supportMulBoss||0.10) : (e.supportMul||0.18);
            const grant = (t.hpMax || t.hp || 40) * mul;

            if ((t.shieldMax||0) <= 0.01) {
              t.shieldMax = grant;
              t.shield = Math.max(t.shield||0, grant);
            } else {
              t.shield = Math.min(t.shieldMax, (t.shield||0) + grant * 0.55);
            }

            did = true;
            const gt = gameSec();
            if (gt - (t._shFxAt||0) > 0.15) {
              t._shFxAt = gt;
              fxShieldWave(t.x, t.y, (t.r||12) + 6);
            }
          }
          if (did) {
            e.supportFx = 0.32;
            fxRing(e.x, e.y, 8, R, "rgba(56,189,248,0.25)");
            fxText("ì‹¤ë“œ!", e.x, e.y - 18, "#7dd3fc");
          }
        }
      }
      }

      const dCore = dist(e.x,e.y, CORE_POS.x, CORE_POS.y);

      // bomber: explode on contact
      if (e.bomber && dCore <= CORE_RADIUS + e.r + 6) {
        bombExplode(e);
        state.enemies.splice(i,1);
        continue;
      }

      // melee touch damage
      if (!e.ranged && dCore <= CORE_RADIUS + e.r + 8) {
        e.touchCd -= dt;
        if (e.touchCd <= 0) {
          const diff = state.diff || DIFF_PRESETS.normal;
          const base = (e.touchBase || 9) * (0.95 + 0.10*Math.random()) * (diff.dmgMul||1);
          damageCore(base, e.coreOpts || null);
          if (state.phase === "fail") break;
          e.touchCd = (e.touchInterval || 0.70) * (e.elite ? 0.82 : 1.0);
        }
      }

      // FINAL BOSS: phase/awakening sync (post-damage, this frame)
      if (state.phase === "wave" && state.wave === FINAL_WAVE && e.kind === "boss" && e.isFinalBoss && state.final) {
        const hpFracNow = clamp(e.hp / e.hpMax, 0, 1);
        let ph = 1;
        const t2 = clamp(0.70 + (diff.finalPhase2Add||0), 0.05, 0.95);
        if (hpFracNow <= t2) ph = 2;
        if (hpFracNow <= 0.35) ph = 3;
        if (ph !== (state.final.phase || 1)) {
          state.final.phase = ph;
          e.awakeFlash = 1.0;
          fxText(`í˜ì´ì¦ˆ ${ph}`, CORE_POS.x, CORE_POS.y - 120, "#f472b6");
          fxRing(CORE_POS.x, CORE_POS.y, CORE_RADIUS+10, CORE_RADIUS+150, "#f472b6");
        }
      }


      if (e.hp <= 0) {
        try { onMissionEnemyKill(e); } catch(e2) {}
        const diedIsFinalBoss = (state.wave === FINAL_WAVE && e.kind === "boss" && e.isFinalBoss);
        if (diedIsFinalBoss) state._finalBossJustDied = true;
        const reward = Math.floor((e.reward || (e.elite ? 16 : 10)) * state.mods.rewardMul * ((e.diffRewardMul||diff.rewardMul||1)));
        state.crystals += reward;
        state.stats.kills = (state.stats.kills|0) + 1;
        fxText(`+${reward}`, e.x, e.y - 6, "#a7f3d0");
        fxRing(e.x,e.y, 8, 55, "#a7f3d0");
        fxEnemyDeathBurst(e);
        state.enemies.splice(i,1);
      }
    }

    // FINAL BOSS defeated: wipe remaining mobs & enemy projectiles (no extra reward)
    if (state._finalBossJustDied) {
      for (const o of state.enemies) {
        fxRing(o.x, o.y, 6, 60, "#93c5fd");
      }
      state.enemies.length = 0;
      state.projectiles = state.projectiles.filter(p => p.kind !== "enemy");
      state._finalBossJustDied = false;
      state.final = null;
    }



    // fx
    for (let i = state.fx.length - 1; i >= 0; i--) {
      const f = state.fx[i];
      f.t += dt;
      if (f.t >= f.dur) state.fx.splice(i,1);
    }

    state.eventTextTimer = Math.max(0, state.eventTextTimer - dt);

    // ì›¨ì´ë¸Œ ëª©í‘œ(ë¯¸ì…˜) ì§„í–‰ ì²´í¬
    try { missionTick(dt); } catch(e) {}

    wireTick(state.core.hp / state.core.hpMax);
  }

  // ---------- Draw ----------
  function draw(){
    let shakeX = 0, shakeY = 0;
    if (state.phase === "fail" && state.collapse) {
      const s = state.collapse.shake * 10;
      shakeX = rand(-s, s);
      shakeY = rand(-s, s);
    }

    // ì—ë„ˆì§€í¬ ë°œì‚¬ ë¯¸ì„¸ í”ë“¤ë¦¼(ì§§ê²Œ)
    const tNow = gameSec();
    if (state.camShakeUntil && tNow < state.camShakeUntil) {
      const dur = state.camShakeDur || 0.12;
      const p = clamp((state.camShakeUntil - tNow) / dur, 0, 1);
      const mag = (state.camShakeMag || 6) * p;
      shakeX += rand(-mag, mag);
      shakeY += rand(-mag, mag);
    }

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    ctx.save();
    ctx.translate(shakeX, shakeY);

    // background (battlefield only) â€” cached (perf)
    const bgMode = (state.ui && typeof state.ui.bgMode === 'number') ? state.ui.bgMode : 1;
    ensureBattleBgCache(bgMode);
    if (BG_CACHE.canvas) ctx.drawImage(BG_CACHE.canvas, -shakeX, -shakeY);
    else {
      ctx.fillStyle = "#0b0f14";
      ctx.fillRect(-shakeX,-shakeY,W,H);
    }

    if (state.debris.length) drawDebris();

    drawCore();

    for (const t of state.turrets) drawTurret(t);
    for (const e of state.enemies) drawEnemy(e);
    for (const p of state.projectiles) drawProjectile(p);
    for (const f of state.fx) drawFx(f);

    // build/clear helper overlays
    if (state.phase === "build" || state.phase === "clear" || state.phase === "finalprep") { drawHoverTurret(); drawGhost(); }

    ctx.restore();

    // passive screen vignette
    drawPassiveScreenVignette();

    // explosion flash on top
    drawBlueExplosionFlash();
    drawResonanceScreenFlash();
if (state.phase !== "win") drawBossHUD();

    // ì›¨ì´ë¸Œ/ë³´ìŠ¤/íŒ¨ì‹œë¸Œ ì—°ì¶œ ì¹´ë“œ
    if (state.phase !== "win") drawCineCards();

    if (state.phase === "win") drawWinOverlay();

    if (state.hardError) banner(`ì˜¤ë¥˜: ${state.hardError}`, "#fca5a5");

    if (state.phase !== "win" && state.phase === "build") banner("ì„¤ì¹˜ ë‹¨ê³„: í¬íƒ‘ ë°°ì¹˜ í›„ [ì›¨ì´ë¸Œ ì‹œì‘]ì„ ëˆ„ë¥´ì‹­ì‹œì˜¤.", "#93c5fd");
    if (state.phase !== "win" && state.phase === "clear") {
      if (state.ui.autoStartEnabled && state.autoStartAt > 0) {
        const left = Math.max(0, state.autoStartAt - gameSec());
        banner(`ì›¨ì´ë¸Œ í´ë¦¬ì–´! ${left.toFixed(1)}s í›„ ìë™ ì‹œì‘`, "#a7f3d0");
      } else {
        banner("ì›¨ì´ë¸Œ í´ë¦¬ì–´! ë°°ì¹˜ í›„ [ì›¨ì´ë¸Œ ì‹œì‘]ìœ¼ë¡œ ì§„í–‰í•˜ì‹­ì‹œì˜¤.", "#a7f3d0");
      }
    }
    if (state.phase !== "win" && state.phase === "fail")  banner("ìˆ˜ì •íƒ‘ ë¶•ê´´! R ë˜ëŠ” [ì¬ì‹œì‘]ìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘í•˜ì‹­ì‹œì˜¤.", "#93c5fd");
    if (state.phase === "win" && state.win && state.win.stage < 3) banner("ì •í™” ì‹œí€€ìŠ¤ ì§„í–‰ ì¤‘...", "#93c5fd");
    if (state.phase !== "win" && state.event && state.eventTextTimer > 0) banner(`ì´ë²¤íŠ¸: ${state.event.name} â€” ${state.event.desc}`, "#fbbf24");

    if (state.phase !== "win") drawWireStatusPanel(state.core.hp / state.core.hpMax, state.core.shield / state.core.shieldMax);
  }

  function drawCore(){
    // ë¶•ê´´ ì¤‘: ì½”ì–´ í˜ì´ë“œì•„ì›ƒ
    let alpha = 1.0;
    if (state.phase === "fail" && state.collapse) {
      alpha = 1.0 - clamp(state.collapse.t / 0.22, 0, 1);
    }

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.22 * alpha;
    ctx.beginPath();
    ctx.ellipse(CORE_POS.x, CORE_POS.y + CORE_RADIUS + 18, 64, 18, 0, 0, Math.PI*2);
    ctx.fillStyle = "#000";
    ctx.fill();
    ctx.restore();


    // íŒ¨ì‹œë¸Œë³„ ì½”ì–´ ëª¨ì…˜(ì„ íƒí•œ íŒ¨ì‹œë¸Œì— ë”°ë¼ ì½”ì–´ ì£¼ë³€ ì˜¤ë¼/ë£¬ì´ ë³€í•©ë‹ˆë‹¤)
    if (alpha > 0.01 && state.core.passiveId && state.phase !== "fail") {
      drawCorePassiveAura(alpha);
    }


    // ì›¨ì´ë¸Œ 30(ìµœì¢…ì „): ìˆ˜ì •íƒ‘ ì—ë„ˆì§€ ì§‘ì† ì—°ì¶œ(ì½”ì–´ ì£¼ë³€ ì´í™íŠ¸)
    if (alpha > 0.01 && !false && (state.phase === "finalprep" || (state.phase === "wave" && state.wave === FINAL_WAVE))) {
      const c = clamp(state.core.finalCharge || 0, 0, 1);
      const pulse = 0.5 + 0.5*Math.sin(state.time*3.0 + c*1.7);

      ctx.save();
      // outer glow ring
      ctx.globalAlpha = alpha * (0.10 + 0.16*c + 0.05*pulse);
      ctx.strokeStyle = "rgba(96,165,250,0.85)";
      ctx.lineWidth = 3.5;
      ctx.beginPath();
      ctx.arc(CORE_POS.x, CORE_POS.y, 96 + 7*pulse, 0, Math.PI*2);
      ctx.stroke();

      // rotating arcs
      ctx.globalAlpha = alpha * (0.16 + 0.22*c);
      ctx.strokeStyle = "rgba(147,197,253,0.9)";
      ctx.lineWidth = 5;
      const baseR = 86;
      const rot = state.time*1.9 + c*0.8;
      for (let k=0;k<3;k++){
        const a0 = rot + k*(Math.PI*2/3);
        ctx.beginPath();
        ctx.arc(CORE_POS.x, CORE_POS.y, baseR, a0, a0 + 1.05 + 0.2*pulse);
        ctx.stroke();
      }

      // particles converging to core
      const orbs = state.core.finalChargeOrbs || [];
      for (const o of orbs){
        const ox = CORE_POS.x + Math.cos(o.a) * o.r;
        const oy = CORE_POS.y + Math.sin(o.a) * o.r * 0.72; // ì‚´ì§ ë‚©ì‘í•œ íƒ€ì›
        const t = clamp(o.t / (o.life || 1), 0, 1);
        const a = alpha * (0.28 * (1 - t));
        if (a <= 0) continue;

        ctx.globalAlpha = a * (0.8 + 0.2*pulse);
        ctx.fillStyle = "#60a5fa";
        ctx.beginPath();
        ctx.arc(ox, oy, 3.1, 0, Math.PI*2);
        ctx.fill();

        // thin trail
        ctx.globalAlpha = a * 0.45;
        ctx.strokeStyle = "rgba(96,165,250,0.6)";
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(ox, oy);
        ctx.lineTo(CORE_POS.x, CORE_POS.y);
        ctx.stroke();
      }

      // subtle inner glow
      ctx.globalAlpha = alpha * (0.06 + 0.10*c);
      const g = ctx.createRadialGradient(CORE_POS.x, CORE_POS.y, 10, CORE_POS.x, CORE_POS.y, 80);
      g.addColorStop(0, "rgba(96,165,250,0.55)");
      g.addColorStop(1, "rgba(96,165,250,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(CORE_POS.x, CORE_POS.y, 82, 0, Math.PI*2);      ctx.fill();

      ctx.restore();
    }



    // ì—ë„ˆì§€í¬ ì¶©ì „: ìˆ˜ì •íƒ‘ ì§‘ì† ì—°ì¶œ(ë¹›ì„ ëª¨ì•„ ê°€ì¥ ë°ì•„ì§ˆ ë•Œ ë°œì‚¬)
    if (alpha > 0.01 && state.core.energyCharging) {
      const tt = gameSec();
      const dur = state.core.energyChargeDur || 3.0;
      const rem = state.core.energyChargeUntil - tt;
      const c = clamp(1 - (rem / dur), 0, 1);
      const pulse = 0.5 + 0.5*Math.sin(tt*7.2 + c*2.2);

      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      // ê°•í•œ ê¸€ë¡œìš°(ìˆ˜ì •íƒ‘ ìì²´ê°€ ë¹›ë‚˜ê²Œ)
      ctx.globalAlpha = alpha * (0.10 + 0.36*c);
      const gg = ctx.createRadialGradient(CORE_POS.x, CORE_POS.y, 8, CORE_POS.x, CORE_POS.y, 110 + 40*c);
      gg.addColorStop(0, "rgba(203,230,255,0.85)");
      gg.addColorStop(0.35, "rgba(96,165,250,0.55)");
      gg.addColorStop(1, "rgba(96,165,250,0)");
      ctx.fillStyle = gg;
      ctx.beginPath();
      ctx.arc(CORE_POS.x, CORE_POS.y, 120 + 30*c, 0, Math.PI*2);
      ctx.fill();

      // ì™¸ê³½ ë§(íšŒì „ ì•„í¬)
      ctx.globalAlpha = alpha * (0.12 + 0.26*c);
      ctx.strokeStyle = "rgba(147,197,253,0.95)";
      ctx.lineWidth = 4.2;
      const baseR = 88 + 8*pulse;
      const rot = tt*2.4 + c*1.1;
      for (let k=0;k<3;k++){
        const a0 = rot + k*(Math.PI*2/3);
        ctx.beginPath();
        ctx.arc(CORE_POS.x, CORE_POS.y, baseR, a0, a0 + 0.95 + 0.25*pulse);
        ctx.stroke();
      }

      // ì½”ì–´ë¡œ ëª¨ì´ëŠ” ì˜¤ë¸Œ/íŠ¸ë ˆì¼
      const orbs = state.core.energyChargeOrbs || [];
      for (const o of orbs){
        const ox = CORE_POS.x + Math.cos(o.a) * o.r;
        const oy = CORE_POS.y + Math.sin(o.a) * o.r * 0.72;
        const t01 = clamp(o.t / (o.life || 1), 0, 1);
        const a = alpha * (0.30 * (1 - t01)) * (0.7 + 0.3*pulse);
        if (a <= 0) continue;

        ctx.globalAlpha = a;
        ctx.fillStyle = "rgba(203,230,255,0.95)";
        ctx.beginPath();
        ctx.arc(ox, oy, 3.0, 0, Math.PI*2);
        ctx.fill();

        ctx.globalAlpha = a * 0.55;
        ctx.strokeStyle = "rgba(96,165,250,0.75)";
        ctx.lineWidth = 1.6;
        ctx.beginPath();
        ctx.moveTo(ox, oy);
        ctx.lineTo(CORE_POS.x, CORE_POS.y);
        ctx.stroke();
      }

      ctx.restore();
    }

    // core image (+ ì—ë„ˆì§€í¬ ì¶©ì „ ì‹œ ë” ë°ê²Œ/ì‚´ì§ í™•ëŒ€)
    if (alpha > 0.01) {
      const tt = gameSec();
      const dur = state.core.energyChargeDur || 3.0;
      const rem = (state.core.energyCharging ? (state.core.energyChargeUntil - tt) : 0);
      const eng = state.core.energyCharging ? clamp(1 - (rem / dur), 0, 1) : 0;

      const flashRem = Math.max(0, (state.core.energyFlashUntil || 0) - tt);
      const flash = flashRem > 0 ? clamp(flashRem / 0.16, 0, 1) : 0;

      let size = 140;
      // NOTE: Do NOT scale the core while charging. Charging is shown via glow/orbs only.

      // ì•„ì´ì½˜ ìì²´ ê¸€ë¡œìš°(ë¹›ë‚˜ëŠ” ëŠë‚Œ)
      if (eng > 0.001 || flash > 0.001) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = alpha * (0.10 + 0.22*eng + 0.28*flash);
        const gg = ctx.createRadialGradient(CORE_POS.x, CORE_POS.y, 12, CORE_POS.x, CORE_POS.y, 64 + 80*eng + 90*flash);
        gg.addColorStop(0, "rgba(255,255,255,0.70)");
        gg.addColorStop(0.35, "rgba(147,197,253,0.55)");
        gg.addColorStop(1, "rgba(147,197,253,0)");
        ctx.fillStyle = gg;
        ctx.beginPath();
        ctx.arc(CORE_POS.x, CORE_POS.y, 90 + 60*eng + 70*flash, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      if (coreIconReady) {
        const iconSize =  150; // 2.5x
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.globalAlpha = alpha;
        ctx.drawImage(coreIcon, CORE_POS.x - iconSize/2, CORE_POS.y - iconSize/2, iconSize, iconSize);
        ctx.restore();
      } else {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#60a5fa";
        ctx.beginPath();
        ctx.arc(CORE_POS.x, CORE_POS.y, 20, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ë°œì‚¬ í”Œë˜ì‹œ(ì§§ê³  ê°•í•˜ê²Œ)
      if (flash > 0.001) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = alpha * (0.30 * flash);
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.arc(CORE_POS.x, CORE_POS.y, 28 + 42*(1-flash), 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    // passive emblem on the core (small, on-top)
    if (alpha > 0.01 && state.core.passiveId && state.phase !== "fail") {
      drawCorePassiveEmblem(alpha);
    }

    // faint shield glow only when alive + shield>0
    const shR = clamp(state.core.shield / state.core.shieldMax, 0, 1);
    if (state.phase !== "fail" && shR > 0.001) {
      ctx.save();
      ctx.globalAlpha = 0.06 + 0.10*shR;
      ctx.strokeStyle = "rgba(96,165,250,0.9)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(CORE_POS.x, CORE_POS.y, 70, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // âœ… ë¶ˆê½ƒì€ ì‚´ì•„ìˆì„ ë•Œë§Œ
    if (state.phase !== "fail") drawBlueFlames();
  }

  function drawCorePassiveAura(alpha){
    const id = state.core.passiveId;
    if (!id) return;

    const t = state.time || 0;
    const x = CORE_POS.x, y = CORE_POS.y;

    ctx.save();
    ctx.translate(x,y);
    ctx.globalCompositeOperation = "lighter";

    if (id === "rebuild") {
      const sh = clamp(state.core.shield / state.core.shieldMax, 0, 1);
      const hp = clamp(state.core.hp / state.core.hpMax, 0, 1);
      const need = 1 - Math.min(sh, hp);
      const pulse = 0.5 + 0.5*Math.sin(t*2.2);

      // rotating hex rune
      ctx.globalAlpha = alpha * (0.10 + 0.10*pulse + 0.18*need);
      ctx.strokeStyle = "rgba(96,165,250,0.85)";
      ctx.lineWidth = 3.0;
      polyPath(6, 92 + 4*Math.sin(t*1.4), t*0.55);
      ctx.stroke();

      // inner tick marks
      ctx.globalAlpha = alpha * (0.06 + 0.10*need);
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2.0;
      for (let i=0;i<12;i++){
        const a = t*0.9 + i*(Math.PI*2/12);
        const r0 = 66;
        const r1 = 74 + 6*Math.sin(t*2.0 + i);
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*r0, Math.sin(a)*r0);
        ctx.lineTo(Math.cos(a)*r1, Math.sin(a)*r1);
        ctx.stroke();
      }

      // orbiting repair motes
      const n = 6;
      for (let i=0;i<n;i++){
        const a = t*1.1 + i*(Math.PI*2/n);
        const rr = 78 + 6*Math.sin(t*1.6 + i);
        const ox = Math.cos(a)*rr;
        const oy = Math.sin(a)*rr*0.72;
        ctx.globalAlpha = alpha * (0.10 + 0.16*need) * (0.6 + 0.4*pulse);
        ctx.fillStyle = "rgba(147,197,253,0.95)";
        ctx.beginPath();
        ctx.arc(ox, oy, 2.4, 0, Math.PI*2);
        ctx.fill();
      }

    } else if (id === "resonance") {
      const g01 = (typeof resonanceGauge01 === 'function') ? resonanceGauge01() : 0;
      const pulse = 0.5 + 0.5*Math.sin(t*3.0);

      // base ring
      ctx.globalAlpha = alpha * (0.09 + 0.12*pulse + 0.06*g01);
      ctx.strokeStyle = "rgba(253,186,116,0.55)";
      ctx.lineWidth = 3.0;
      ctx.beginPath();
      ctx.arc(0,0, 90, 0, Math.PI*2);
      ctx.stroke();

      // gauge arc
      ctx.globalAlpha = alpha * (0.10 + 0.26*g01);
      ctx.strokeStyle = "rgba(251,146,60,0.95)";
      ctx.lineWidth = 6.0;
      const start = -Math.PI/2;
      ctx.beginPath();
      ctx.arc(0,0, 90, start, start + Math.PI*2*g01);
      ctx.stroke();

      // rotating chevrons
      ctx.globalAlpha = alpha * (0.06 + 0.16*g01);
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 2.0;
      const rot = t*1.6;
      for (let i=0;i<8;i++){
        const a = rot + i*(Math.PI*2/8);
        const r0 = 64;
        const r1 = 74;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*r0, Math.sin(a)*r0);
        ctx.lineTo(Math.cos(a+0.18)*r1, Math.sin(a+0.18)*r1);
        ctx.stroke();
      }



      // traveling current (always moving, stronger when gauge is high)
      const curA = -Math.PI/2 + t*2.6 + g01*1.1;
      const cx2 = Math.cos(curA)*90;
      const cy2 = Math.sin(curA)*90;
      ctx.globalAlpha = alpha * (0.06 + 0.18*g01) * (0.7 + 0.3*pulse);
      ctx.fillStyle = "rgba(255,255,255,0.30)";
      ctx.beginPath();
      ctx.arc(cx2, cy2, 2.7 + 1.6*g01, 0, Math.PI*2);
      ctx.fill();

      // waveform ring (subtle) to make it feel "alive"
      ctx.globalAlpha = alpha * (0.03 + 0.10*g01);
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.lineWidth = 2.0;
      ctx.beginPath();
      const seg = 42;
      for (let i=0;i<=seg;i++){
        const a = -Math.PI/2 + i*(Math.PI*2/seg);
        const wv = 2.6*Math.sin(t*4.0 + i*0.45) + 1.2*Math.sin(t*7.2 + i*0.22);
        const rr = 76 + wv*(0.35 + 0.65*g01);
        const px = Math.cos(a)*rr;
        const py = Math.sin(a)*rr;
        if (i==0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.stroke();
      // spark on arc end
      if (g01 > 0.02){
        const a = start + Math.PI*2*g01;
        const ex = Math.cos(a)*90;
        const ey = Math.sin(a)*90;
        ctx.globalAlpha = alpha * (0.12 + 0.24*g01) * (0.6 + 0.4*pulse);
        ctx.fillStyle = "rgba(255,255,255,0.35)";
        ctx.beginPath();
        ctx.arc(ex, ey, 3.0, 0, Math.PI*2);
        ctx.fill();
      }

    } else if (id === "overload") {
      const hpFrac = (state.core.hpMax>0) ? (state.core.hp/state.core.hpMax) : 1;
      const trig = (typeof OVERLOAD_CFG === 'object' && OVERLOAD_CFG) ? OVERLOAD_CFG.triggerHp : 0.30;
      const danger = clamp((trig + 0.18 - hpFrac)/0.18, 0, 1);
      const burst = (typeof overloadBurstActive === 'function' && overloadBurstActive()) ? 1 : 0;
      const pulse = 0.5 + 0.5*Math.sin(t*(6 + 4*burst));

      // unstable jagged ring
      ctx.globalAlpha = alpha * (0.05 + 0.18*danger + 0.12*burst);
      ctx.strokeStyle = "rgba(251,113,133,0.85)";
      ctx.lineWidth = 4.5;
      ctx.beginPath();
      const base = 92;
      for (let i=0;i<=36;i++){
        const a = i*(Math.PI*2/36);
        const j = (Math.sin(t*7.0 + i*1.7) + Math.sin(t*3.1 + i*0.9))*0.5;
        const rr = base + (danger*6 + burst*10) * (0.3 + 0.7*Math.abs(j));
        const px = Math.cos(a)*rr;
        const py = Math.sin(a)*rr;
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.stroke();

      // crack spokes
      ctx.globalAlpha = alpha * (0.06 + 0.22*danger + 0.16*burst) * (0.4 + 0.6*pulse);
      ctx.strokeStyle = "rgba(253,164,175,0.65)";
      ctx.lineWidth = 2.2;
      const n = 7;
      for (let k=0;k<n;k++){
        const a = t*1.1 + k*(Math.PI*2/n);
        const r0 = 62;
        const r1 = 84 + 18*danger + 24*burst;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a)*r0, Math.sin(a)*r0);
        ctx.lineTo(Math.cos(a)*r1, Math.sin(a)*r1);
        ctx.stroke();
      }

      // sparks
      const sn = 8;
      for (let i=0;i<sn;i++){
        const a = t*2.6 + i*1.7;
        const rr = 74 + 18*Math.abs(Math.sin(t*3.3 + i));
        const ox = Math.cos(a)*rr;
        const oy = Math.sin(a)*rr*0.72;
        ctx.globalAlpha = alpha * (0.06 + 0.20*danger + 0.16*burst) * (0.4 + 0.6*pulse);
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath();
        ctx.arc(ox, oy, 1.8 + 1.0*burst, 0, Math.PI*2);
        ctx.fill();
      }

    } else if (id === "overdrive") {
      const hpFrac = (state.core.hpMax>0) ? (state.core.hp/state.core.hpMax) : 1;
      const m = clamp(1 - hpFrac, 0, 1);
      const sp = 1.2 + 2.0*Math.pow(m, 0.9);
      const pulse = 0.5 + 0.5*Math.sin(t*3.2);

      // rotating arc ring
      ctx.globalAlpha = alpha * (0.06 + 0.16*pulse + 0.22*m);
      ctx.strokeStyle = "rgba(168,85,247,0.75)";
      ctx.lineWidth = 4.0;
      const r = 92;
      const rot = t*1.8*sp;
      for (let k=0;k<3;k++){
        const a0 = rot + k*(Math.PI*2/3);
        ctx.beginPath();
        ctx.arc(0,0, r, a0, a0 + 0.95);
        ctx.stroke();
      }

      // speed streaks
      ctx.globalAlpha = alpha * (0.05 + 0.14*m);
      ctx.strokeStyle = "rgba(216,180,254,0.35)";
      ctx.lineWidth = 2.0;
      for (let i=0;i<10;i++){
        const a = rot*1.4 + i*(Math.PI*2/10);
        const rr = 64 + 10*Math.sin(t*2.6 + i);
        const x0 = Math.cos(a)*rr;
        const y0 = Math.sin(a)*rr*0.72;
        const tx = -Math.sin(a);
        const ty =  Math.cos(a)*0.72;
        const len = 10 + 22*m*(0.4 + 0.6*Math.sin(t*3.5 + i));
        ctx.beginPath();
        ctx.moveTo(x0 - tx*len*0.5, y0 - ty*len*0.5);
        ctx.lineTo(x0 + tx*len*0.5, y0 + ty*len*0.5);
        ctx.stroke();
      }

      // orbiting motes
      ctx.globalAlpha = alpha * (0.06 + 0.16*m) * (0.6 + 0.4*pulse);
      ctx.fillStyle = "rgba(216,180,254,0.65)";
      const n = 5;
      for (let i=0;i<n;i++){
        const a = rot*0.9 + i*(Math.PI*2/n);
        const rr2 = 78;
        ctx.beginPath();
        ctx.arc(Math.cos(a)*rr2, Math.sin(a)*rr2*0.72, 2.2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    ctx.restore();
  }



  function drawCorePassiveEmblem(alpha){
    const id = state.core && state.core.passiveId;
    if (!id) return;

    const t = state.time || 0;
    const x = CORE_POS.x, y = CORE_POS.y;

    ctx.save();
    ctx.translate(x,y);
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = alpha * 0.22;
    ctx.lineWidth = 2.2;

    if (id === 'rebuild') {
      ctx.strokeStyle = 'rgba(147,197,253,0.9)';
      polyPath(6, 22, t*0.5);
      ctx.stroke();
      ctx.globalAlpha = alpha * 0.16;
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.beginPath();
      ctx.moveTo(-10,0); ctx.lineTo(10,0);
      ctx.moveTo(0,-10); ctx.lineTo(0,10);
      ctx.stroke();

    } else if (id === 'resonance') {
      ctx.strokeStyle = 'rgba(253,186,116,0.95)';
      ctx.beginPath();
      ctx.arc(0,0, 20, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = alpha * 0.18;
      ctx.strokeStyle = 'rgba(255,255,255,0.28)';
      ctx.beginPath();
      for (let i=-18;i<=18;i+=3){
        const yy = i;
        const xx = 12*Math.sin(t*3.0 + i*0.20);
        if (i==-18) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
      }
      ctx.stroke();

    } else if (id === 'overload') {
      ctx.strokeStyle = 'rgba(251,113,133,0.95)';
      ctx.beginPath();
      ctx.moveTo(0,-22); ctx.lineTo(19,14); ctx.lineTo(-19,14);
      ctx.closePath();
      ctx.stroke();
      ctx.globalAlpha = alpha * 0.20;
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.beginPath();
      ctx.moveTo(0,-10); ctx.lineTo(0,6);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(0,12, 1.6, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.30)';
      ctx.fill();

    } else if (id === 'overdrive') {
      ctx.strokeStyle = 'rgba(216,180,254,0.95)';
      const a = t*2.0;
      for (let k=0;k<2;k++){
        const off = (k*6) - 3;
        ctx.beginPath();
        ctx.moveTo(-10+off,-10);
        ctx.lineTo(10+off,0);
        ctx.lineTo(-10+off,10);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  // ---------- Shape helpers (simple vector sprites) ----------
  function withTransform(x,y,rot,fn){
    ctx.save();
    ctx.translate(x,y);
    if (rot) ctx.rotate(rot);
    fn();
    ctx.restore();
  }

  function polyPath(n, r, rot){
    const a0 = rot || 0;
    ctx.beginPath();
    for (let i=0;i<n;i++) {
      const a = a0 + (i/n)*Math.PI*2;
      const px = Math.cos(a)*r;
      const py = Math.sin(a)*r;
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
  }

  function starPath(points, rOuter, rInner, rot){
    const n = Math.max(3, points|0);
    const a0 = rot || 0;
    ctx.beginPath();
    for (let i=0;i<n*2;i++) {
      const r = (i%2===0) ? rOuter : rInner;
      const a = a0 + (i/(n*2))*Math.PI*2;
      const px = Math.cos(a)*r;
      const py = Math.sin(a)*r;
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
  }

  function roundRectPath(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  function drawTurret(t){
    const s = turretBase(t);

    // New visual palette (visual only)
    const col = (t.type==="basic")  ? "#60a5fa" :
                (t.type==="slow")   ? "#34d399" :
                (t.type==="splash") ? "#f472b6" :
                (t.type==="shred")  ? "#22d3ee" :
                (t.type==="breaker")? "#f59e0b" : "#60a5fa";

    // aim (same heuristic as update)
    let best = null, bestScore = Infinity;
    for (const e of state.enemies) {
      const d = dist(t.x,t.y, e.x,e.y);
      if (d > s.range) continue;
      const dCore = dist(e.x,e.y, CORE_POS.x, CORE_POS.y);
      const score = dCore*0.9 + d*0.25;
      if (score < bestScore) { bestScore = score; best = e; }
    }
    const time = (typeof nowSec==="function") ? nowSec() : (performance.now()/1000);
    const aim = best ? Math.atan2(best.y - t.y, best.x - t.x) : (time*0.65 + (t.x+t.y)*0.004);

    // muzzle flash hint (very short after a shot)
    const fireBuffMul = (state.shop && (gameSec() < (state.shop.fireUntil||0))) ? SHOP_ITEM_FIRE_MUL : 1.0;
    const fireRate = (s.fireRate * state.mods.turretFireMul) * fireBuffMul;
    const cdMax = fireRate > 0 ? (1 / fireRate) : 0.3;
    const flashWindow = 0.025;
    const flash = (t.cd > cdMax - flashWindow) ? 1 : 0;

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.beginPath();
    ctx.ellipse(t.x, t.y + 15, 20, 7, 0, 0, Math.PI*2);
    ctx.fillStyle = "#000";
    ctx.fill();
    ctx.restore();

    // body
    withTransform(t.x, t.y, 0, () => {
      // base plate (layered)
      ctx.save();
      const baseG = ctx.createLinearGradient(-18, -14, 18, 16);
      baseG.addColorStop(0, "#0b1220");
      baseG.addColorStop(1, "#121a2a");
      ctx.fillStyle = baseG;
      ctx.strokeStyle = "#334155";
      ctx.lineWidth = 2;

      if (t.type === "slow") {
        // snowflake-ish base (hex + notches)
        polyPath(6, 17, Math.PI/6);
        ctx.fill(); ctx.stroke();
        ctx.globalAlpha = 0.40;
        ctx.strokeStyle = "rgba(52,211,153,0.9)";
        ctx.lineWidth = 2;
        for (let i=0;i<6;i++){
          const a = i*Math.PI/3;
          ctx.beginPath();
          ctx.moveTo(Math.cos(a)*6, Math.sin(a)*6);
          ctx.lineTo(Math.cos(a)*15, Math.sin(a)*15);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      } else if (t.type === "splash") {
        // heavy rounded base + brace
        roundRectPath(-17, -15, 34, 30, 7);
        ctx.fill(); ctx.stroke();
        ctx.globalAlpha = 0.55;
        ctx.strokeStyle = "#475569";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, 2, 13, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 1;
      } else if (t.type === "shred") {
        // shred: gear / saw base
        starPath(10, 17, 13.2, Math.PI/10);
        ctx.fill(); ctx.stroke();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0,0, 11.5, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 1;
      } else if (t.type === "breaker") {
        // breaker: diamond base + mark
        polyPath(4, 18, Math.PI/4);
        ctx.fill(); ctx.stroke();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-10, -10); ctx.lineTo(10, 10);
        ctx.moveTo(-10, 10); ctx.lineTo(10, -10);
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else {
        // basic: beveled octagon
        polyPath(8, 17, Math.PI/8);
        ctx.fill(); ctx.stroke();
      }

      // core crystal (prism)
      const pulse = 0.55 + 0.45*Math.sin(time*2.4 + (t.x+t.y)*0.01);
      ctx.save();
      ctx.translate(0, -3);
      const cg = ctx.createRadialGradient(0,0, 2, 0,0, 12);
      cg.addColorStop(0, col);
      cg.addColorStop(1, "rgba(11,18,32,0.95)");
      ctx.fillStyle = cg;
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -11);
      ctx.lineTo(9, -2);
      ctx.lineTo(0, 10);
      ctx.lineTo(-9, -2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // inner spark
      ctx.globalAlpha = 0.18 + 0.16*pulse;
      ctx.strokeStyle = col;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-5, 0); ctx.lineTo(5, 0);
      ctx.moveTo(0, -5); ctx.lineTo(0, 5);
      ctx.stroke();
      ctx.restore();

      // rotating ring (subtle, no blink)
      ctx.save();
      ctx.globalAlpha = 0.10 + 0.06*pulse;
      ctx.strokeStyle = col;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, -3, 16, time*0.9, time*0.9 + Math.PI*1.35);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(0, -3, 16, time*0.9 + Math.PI*1.7, time*0.9 + Math.PI*2.35);
      ctx.stroke();
      ctx.restore();

      // barrel / head (more angular)
      withTransform(0, -3, aim, () => {
        ctx.save();

        // housing
        ctx.fillStyle = "#162033";
        ctx.strokeStyle = "#475569";
        ctx.lineWidth = 2;
        roundRectPath(-2, -9, 24, 18, 4);
        ctx.fill(); ctx.stroke();

        // energy rail
        ctx.globalAlpha = 0.85;
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(6, -6); ctx.lineTo(18, -6);
        ctx.moveTo(6,  6); ctx.lineTo(18,  6);
        ctx.stroke();

        // muzzle
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#0b1220";
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(22, 0, 5.2, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();

        // type accents
        if (t.type === "slow") {
          ctx.globalAlpha = 0.28;
          ctx.strokeStyle = col;
          ctx.lineWidth = (f.w ?? 3);
          ctx.beginPath(); ctx.arc(10, 0, 7, 0, Math.PI*2); ctx.stroke();
        } else if (t.type === "splash") {
          ctx.globalAlpha = 0.22;
          ctx.fillStyle = col;
          ctx.beginPath();
          ctx.moveTo(3, -10); ctx.lineTo(8, -10); ctx.lineTo(6, -15);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(3, 10); ctx.lineTo(8, 10); ctx.lineTo(6, 15);
          ctx.closePath();
          ctx.fill();
        } else if (t.type === "shred") {
          // shred: saw ring around muzzle
          ctx.globalAlpha = 0.26;
          ctx.strokeStyle = col;
          ctx.lineWidth = (f.w ?? 3);
          ctx.beginPath(); ctx.arc(22, 0, 9.2, 0, Math.PI*2); ctx.stroke();
          ctx.globalAlpha = 0.20;
          ctx.fillStyle = col;
          for (let i=0;i<6;i++){
            const a = i*Math.PI/3;
            ctx.save();
            ctx.translate(22 + Math.cos(a)*9.2, Math.sin(a)*9.2);
            ctx.rotate(a);
            ctx.beginPath();
            ctx.moveTo(-2, -1.5); ctx.lineTo(2, -1.5); ctx.lineTo(0, 5);
            ctx.closePath(); ctx.fill();
            ctx.restore();
          }
          ctx.globalAlpha = 1;
        } else if (t.type === "breaker") {
          // breaker: target reticle + fins
          ctx.globalAlpha = 0.28;
          ctx.strokeStyle = col;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(10, 0, 7, 0, Math.PI*2);
          ctx.moveTo(3,0); ctx.lineTo(17,0);
          ctx.moveTo(10,-7); ctx.lineTo(10,7);
          ctx.stroke();
          ctx.globalAlpha = 0.22;
          ctx.fillStyle = col;
          ctx.beginPath();
          ctx.moveTo(8, -10); ctx.lineTo(14, -10); ctx.lineTo(11, -16);
          ctx.closePath(); ctx.fill();
          ctx.beginPath();
          ctx.moveTo(8, 10); ctx.lineTo(14, 10); ctx.lineTo(11, 16);
          ctx.closePath(); ctx.fill();
          ctx.globalAlpha = 1;
        }

        // muzzle flash (subtle glint)
        if (flash) {
          ctx.globalAlpha = 0.16;
          ctx.fillStyle = col;
          ctx.translate(24, 0);
          starPath(6, 5.2, 2.2, 0);
          ctx.fill();
        }

        ctx.restore();
      });

      // outer glow
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.strokeStyle = col;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, -3, 19, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();

      ctx.restore();
    });
  }


  
    function drawFinalBossGlyph(e, hpR, time){
      const dr = (e.drawR || e.r);
      const c = clamp(state.core.finalCharge || 0, 0, 1);

      // phase from HP (same logic)
      let phase = 1;
      if (hpR <= 0.70) phase = 2;
      if (hpR <= 0.35) phase = 3;

      const p2 = phase >= 2 ? 1 : 0;
      const p3 = phase >= 3 ? 1 : 0;
      const rage = clamp(1 - hpR, 0, 1);
      const flash = clamp(e.awakeFlash || 0, 0, 1);
      const spin = time*0.85*e.orbitDir;

      // ---- Eclipse Engine: concentric rings + blades ----
      // outer halo
      ctx.save();
      ctx.globalAlpha = 0.12 + 0.22*c + 0.10*p2 + 0.12*p3;
      ctx.strokeStyle = "rgba(147,197,253,0.92)";
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.arc(0,0, dr+20 + Math.sin(time*2.2+e.seedAng)*2.2, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();

      // rotating arc segments
      ctx.save();
      ctx.globalAlpha = 0.20 + 0.10*c;
      ctx.strokeStyle = "rgba(96,165,250,0.95)";
      ctx.lineWidth = 6;
      for (let i=0;i<3+p2+p3;i++){
        const a0 = spin + i*(Math.PI*2/(3+p2+p3));
        ctx.beginPath();
        ctx.arc(0,0, dr+10, a0, a0 + Math.PI*0.55);
        ctx.stroke();
      }
      ctx.restore();

      // body (armored disc)
      ctx.save();
      const bodyG = ctx.createRadialGradient(0,0, 4, 0,0, dr+10);
      bodyG.addColorStop(0, "rgba(255,255,255,0.10)");
      bodyG.addColorStop(1, "rgba(11,18,32,0.95)");
      ctx.fillStyle = bodyG;
      ctx.strokeStyle = "#0b1220";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0,0, dr+4, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // blades (increase with phase)
      ctx.save();
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = "rgba(148,163,184,0.22)";
      const blades = 6 + (p2?2:0) + (p3?2:0);
      for (let i=0;i<blades;i++){
        const a = spin + i*(Math.PI*2/blades);
        withTransform(Math.cos(a)*(dr*0.35), Math.sin(a)*(dr*0.35), a, () => {
          ctx.beginPath();
          ctx.moveTo(6, 0);
          ctx.lineTo(dr*0.95, -6);
          ctx.lineTo(dr*0.95,  6);
          ctx.closePath();
          ctx.fill();
        });
      }
      ctx.restore();

      // core eye
      const pulse = 0.55 + 0.45*Math.sin(time*2.8 + e.seedAng);
      ctx.save();
      const coreG = ctx.createRadialGradient(0,0, 2, 0,0, 18);
      coreG.addColorStop(0, "rgba(251,113,133,0.95)");
      coreG.addColorStop(1, "rgba(11,18,32,0.95)");
      ctx.fillStyle = coreG;
      ctx.beginPath(); ctx.arc(0,0, 16, 0, Math.PI*2); ctx.fill();

      ctx.globalAlpha = 0.18 + 0.18*pulse + 0.12*c;
      ctx.strokeStyle = "rgba(251,113,133,0.95)";
      ctx.lineWidth = 4;
      ctx.beginPath(); ctx.arc(0,0, 24, 0, Math.PI*2); ctx.stroke();
      ctx.restore();

      // phase flash (on transition)
      if (flash > 0.01) {
        ctx.save();
        ctx.globalAlpha = 0.25 * flash;
        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = 12;
        ctx.beginPath();
        ctx.arc(0,0, dr+26, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // small crown spikes in phase 2/3
      if (p2) {
        ctx.save();
        ctx.globalAlpha = 0.28 + 0.10*p3;
        ctx.fillStyle = "rgba(96,165,250,0.85)";
        const spikes = 8 + (p3?4:0);
        for (let i=0;i<spikes;i++){
          const a = -Math.PI/2 + i*(Math.PI*2/spikes) + spin*0.35;
          withTransform(Math.cos(a)*(dr+8), Math.sin(a)*(dr+8), a, () => {
            ctx.beginPath();
            ctx.moveTo(-4, 0);
            ctx.lineTo( 4, 0);
            ctx.lineTo( 0, 10 + rage*8);
            ctx.closePath();
            ctx.fill();
          });
        }
        ctx.restore();
      }
    }


function drawEnemy(e){
    const hpR = clamp(e.hp / e.hpMax, 0, 1);
    const base = (e.color || "#94a3b8");
    const time = (typeof nowSec==="function") ? nowSec() : (performance.now()/1000);
    const toCore = Math.atan2(CORE_POS.y - e.y, CORE_POS.x - e.x);
    const wob = Math.sin(time*3 + e.seedAng) * 1.1;
    const rot = (e.kind === "shooter" || e.kind === "boss") ? (e.seedAng + time*0.9*e.orbitDir) : toCore;

    // elite aura (keep, but sharpen)
    if (e.elite) {
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = (e.eliteColor || "#fbbf24");
      ctx.lineWidth = 7;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r + 8, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }


    // supporter pulse aura
    if (e.kind === "supporter" && (e.supportFx||0) > 0) {
      ctx.save();
      const p = clamp((e.supportFx||0) / 0.32, 0, 1);
      ctx.globalAlpha = 0.10 + 0.28*p;
      ctx.strokeStyle = "#38bdf8";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r + 10 + 6*(1-p), 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
    withTransform(e.x, e.y + wob, rot, () => {
      ctx.save();

      // gradient fill for "new look"
      const g = ctx.createRadialGradient(0,0, 2, 0,0, e.r+14);
      g.addColorStop(0, e.elite ? "#fde68a" : base);
      g.addColorStop(1, "rgba(11,18,32,0.92)");
      ctx.fillStyle = g;
      ctx.strokeStyle = "#0b1220";
      ctx.lineWidth = 2;

      // FINAL BOSS (Wave 30): delegate
      if (e.kind === "boss" && e.isFinalBoss) {
        drawFinalBossGlyph(e, hpR, time);
        ctx.restore();
        return;
      }

      // silhouettes per type (redesigned)
      if (e.kind === "grunt") {
        // winged drone: center diamond + two wings
        ctx.beginPath();
        ctx.moveTo(e.r+6, 0);
        ctx.lineTo(4, -e.r*0.55);
        ctx.lineTo(-e.r*0.85, -e.r*0.30);
        ctx.lineTo(-4, 0);
        ctx.lineTo(-e.r*0.85, e.r*0.30);
        ctx.lineTo(4, e.r*0.55);
        ctx.closePath();
      } else if (e.kind === "shooter") {
        // sentry: squared body
        roundRectPath(-(e.r+2), -(e.r+2), (e.r+2)*2, (e.r+2)*2, 6);
      } else if (e.kind === "shieldbreaker") {
        // saw gear (teeth)
        starPath(10, e.r+6, e.r*0.72, 0);
      } else if (e.kind === "piercer") {
        // needle spear (long)
        ctx.beginPath();
        ctx.moveTo(e.r+10, 0);
        ctx.lineTo(-e.r, -e.r*0.40);
        ctx.lineTo(-e.r*0.55, 0);
        ctx.lineTo(-e.r, e.r*0.40);
        ctx.closePath();
      } else if (e.kind === "bomber") {
        // mine: octagon + spikes
        polyPath(8, e.r+3, Math.PI/8);
      } else if (e.kind === "disruptor") {
        // EMP orb: circle with notches
        ctx.beginPath();
        ctx.arc(0,0, e.r+2, 0, Math.PI*2);
      } else if (e.kind === "supporter") {
        // support drone: circle
        ctx.beginPath();
        ctx.arc(0,0, e.r+3, 0, Math.PI*2);
      } else if (e.kind === "boss") {
        // armored corebreaker: layered hex
        polyPath(6, e.r+6, Math.PI/6);
      } else {
        polyPath(6, e.r, 0);
      }

      ctx.fill();
      ctx.stroke();

      // inner details / markings (new)
      ctx.globalAlpha = 0.92;
      ctx.lineWidth = 2;

      if (e.kind === "grunt") {
        // eye
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.beginPath(); ctx.arc(6, 0, 6, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath(); ctx.arc(6, 0, 6, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = "rgba(11,18,32,0.7)";
        ctx.beginPath(); ctx.arc(6, 0, 2.2, 0, Math.PI*2); ctx.stroke();
      }

      if (e.kind === "shooter") {
        // lens + side gun
        ctx.strokeStyle = "rgba(255,255,255,0.28)";
        ctx.beginPath(); ctx.arc(0,0, 8, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = "rgba(11,18,32,0.55)";
        ctx.beginPath(); ctx.moveTo(-12,0); ctx.lineTo(12,0); ctx.stroke();
        ctx.save();
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = "rgba(255,255,255,0.08)";
        roundRectPath(9, -3, 10, 6, 2);
        ctx.fill();
        ctx.restore();
      }

      if (e.kind === "shieldbreaker") {
        // inner ring
        ctx.strokeStyle = "#dbeafe";
        ctx.beginPath(); ctx.arc(0,0, e.r*0.55, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath(); ctx.arc(0,0, e.r*0.90, time*1.2, time*1.2 + Math.PI*1.4); ctx.stroke();
        ctx.globalAlpha = 0.92;
      }


      if (e.kind === "supporter") {
        ctx.strokeStyle = "#bae6fd";
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(8,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(0,8); ctx.stroke();
        ctx.globalAlpha = 0.30;
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath(); ctx.arc(0,0, e.r*0.90, time*0.8, time*0.8 + Math.PI*1.2); ctx.stroke();
        ctx.globalAlpha = 0.92;
      }

      if (e.kind === "piercer") {
        // spine line
        ctx.strokeStyle = "#ede9fe";
        ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.stroke();
        ctx.globalAlpha = 0.30;
        ctx.strokeStyle = "rgba(255,255,255,0.24)";
        ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(14,0); ctx.lineTo(0,6); ctx.stroke();
        ctx.globalAlpha = 0.92;
      }

      if (e.kind === "bomber") {
        // hazard + spikes
        ctx.save();
        ctx.globalAlpha = 0.28;
        ctx.strokeStyle = "#0b1220";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-9,-7); ctx.lineTo(9,7);
        ctx.moveTo(-9, 7); ctx.lineTo(9,-7);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = 0.38;
        ctx.fillStyle = "#111826";
        for (let i=0;i<4;i++){
          const a = i*Math.PI/2 + Math.PI/4;
          withTransform(Math.cos(a)*(e.r+6), Math.sin(a)*(e.r+6), a, () => {
            ctx.beginPath();
            ctx.moveTo(-3,0); ctx.lineTo(3,0); ctx.lineTo(0,7);
            ctx.closePath(); ctx.fill();
          });
        }
        ctx.restore();
      }

      if (e.kind === "disruptor") {
        // broken ring arcs + spark
        ctx.save();
        ctx.globalAlpha = 0.30 + 0.10*Math.sin(time*7 + e.seedAng);
        ctx.strokeStyle = "rgba(34,197,94,0.92)";
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, e.r+8, time*0.9, time*0.9 + Math.PI*1.1); ctx.stroke();
        ctx.beginPath(); ctx.arc(0,0, e.r+8, time*0.9 + Math.PI*1.6, time*0.9 + Math.PI*2.2); ctx.stroke();
        ctx.restore();

        ctx.strokeStyle = "rgba(236,253,245,0.75)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-8, -2); ctx.lineTo(-1, -9); ctx.lineTo(6, -1);
        ctx.moveTo(-6,  3); ctx.lineTo(1, -4); ctx.lineTo(8,  4);
        ctx.stroke();
      }

      if (e.kind === "boss") {
        // inner core + rotating brace
        const gg = ctx.createRadialGradient(0,0, 2, 0,0, 16);
        gg.addColorStop(0, "#fff7ed");
        gg.addColorStop(1, "rgba(11,18,32,0.9)");
        ctx.fillStyle = gg;
        ctx.beginPath(); ctx.arc(0,0, 12, 0, Math.PI*2); ctx.fill();

        ctx.save();
        ctx.globalAlpha = 0.28;
        ctx.strokeStyle = "rgba(96,165,250,0.75)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0,0, e.r+12, time*0.8, time*0.8 + Math.PI*1.35);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    });

    // HP bar (unchanged)
    const br = (e.isFinalBoss ? (e.drawR || e.r) : e.r);
    const w = (e.isFinalBoss ? br*1.45 : e.r*2.4), h = (e.isFinalBoss ? 6 : 4);
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#0b1220";
    ctx.fillRect(e.x - w/2, (e.y + wob) - br - (e.isFinalBoss ? 20 : 14), w, h);
    ctx.fillStyle = e.elite ? "#fbbf24" : base;
    ctx.fillRect(e.x - w/2, (e.y + wob) - br - (e.isFinalBoss ? 20 : 14), w*hpR, h);
    ctx.restore();

    // shield bar (ì  ì‹¤ë“œ) (unchanged)
    if ((e.shieldMax||0) > 0.01) {
      const shR = clamp((e.shield||0) / (e.shieldMax||1), 0, 1);
      const sy = (e.y + wob) - br - (e.isFinalBoss ? 20 : 14) - 6;
      ctx.save();
      ctx.globalAlpha = 0.88;
      ctx.fillStyle = "#0b1220";
      ctx.fillRect(e.x - w/2, sy, w, 3);
      ctx.fillStyle = "#60a5fa";
      ctx.fillRect(e.x - w/2, sy, w*shR, 3);
      ctx.restore();
    }
  }




function drawProjectile(p){
  const ang = Math.atan2(p.vy||0, p.vx||0);

  // enemy shots: sharp diamond
  if (p.kind !== "turret") {
    const col = (p.projCol||"#fbbf24");
    withTransform(p.x, p.y, ang, () => {
      ctx.save();
      ctx.fillStyle = col;
      polyPath(4, p.r*1.25, Math.PI/4);
      ctx.fill();
      ctx.globalAlpha = 0.28;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1.5;
      polyPath(4, p.r*1.25, Math.PI/4);
      ctx.stroke();
      ctx.restore();
    });
    return;
  }

  // turret type (visual-only). Fallback by payload.
  const tType = p.tType || ((p.vulnBonus||0) > 0 ? "breaker" : ((p.shieldMul||1) > 1.05 ? "shred" : ((p.splash||0) > 0 ? "splash" : ((p.slow||0) > 0 ? "slow" : "basic"))));

  // base color per turret type
  let col = (tType === "basic")   ? "#93c5fd" :
            (tType === "slow")    ? "#a7f3d0" :
            (tType === "shred")   ? "#22d3ee" :
            (tType === "breaker") ? "#fbbf24" :
            (tType === "splash")  ? "#f472b6" : "#93c5fd";

  // Overload burst: red tone + stronger trail
  if (p.ovBurst) col = "#fb7185";

  // trail (visual only)
  const trail = (tType === "shred") ? 0.060 :
                (tType === "breaker") ? 0.052 :
                (tType === "splash") ? 0.046 :
                (tType === "slow") ? 0.050 : 0.045;

  const tx = p.x - (p.vx||0) * (p.ovBurst ? 0.030 : trail);
  const ty = p.y - (p.vy||0) * (p.ovBurst ? 0.030 : trail);
  ctx.save();
  ctx.globalAlpha = p.ovBurst ? 0.62 : 0.30;
  ctx.strokeStyle = p.ovBurst ? "rgba(251,113,133,0.85)" : col;
  ctx.lineWidth = p.ovBurst ? 3.6 : (tType === "breaker" ? 2.3 : 2.0);
  ctx.beginPath();
  ctx.moveTo(tx,ty);
  ctx.lineTo(p.x,p.y);
  ctx.stroke();
  ctx.restore();

  // draw per-type shape
  withTransform(p.x, p.y, ang, () => {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = col;

    if (tType === "shred") {
      // rotating gear (using starPath)
      const spin = (state.time * 8.0) % (Math.PI*2);
      ctx.rotate(spin);
      starPath(12, p.r*1.65, p.r*1.05, Math.PI/12);
      ctx.fill();
      ctx.globalAlpha = 0.28;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1.6;
      starPath(12, p.r*1.65, p.r*1.05, Math.PI/12);
      ctx.stroke();
      ctx.globalAlpha = 0.20;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(0,0, p.r*0.55, 0, Math.PI*2);
      ctx.fill();

    } else if (tType === "breaker") {
      // piercing diamond + X mark
      polyPath(4, p.r*1.45, Math.PI/4);
      ctx.fill();
      ctx.globalAlpha = 0.34;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1.4;
      polyPath(4, p.r*1.45, Math.PI/4);
      ctx.stroke();
      ctx.globalAlpha = 0.65;
      ctx.strokeStyle = "rgba(11,15,20,0.55)";
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      ctx.moveTo(-p.r*0.70, -p.r*0.70);
      ctx.lineTo( p.r*0.70,  p.r*0.70);
      ctx.moveTo(-p.r*0.70,  p.r*0.70);
      ctx.lineTo( p.r*0.70, -p.r*0.70);
      ctx.stroke();

    } else if (tType === "splash") {
      // star core
      starPath(5, p.r*1.55, p.r*0.85, state.time*2.5);
      ctx.fill();
      ctx.globalAlpha = 0.30;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1.4;
      starPath(5, p.r*1.55, p.r*0.85, state.time*2.5);
      ctx.stroke();
      ctx.globalAlpha = 0.22;
      ctx.beginPath();
      ctx.arc(0,0, p.r*1.75, 0, Math.PI*2);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1.0;
      ctx.stroke();

    } else {
      // basic/slow: bolt
      roundRectPath(-p.r*1.2, -p.r*0.55, p.r*2.6, p.r*1.1, p.r*0.55);
      ctx.fill();
      if (tType === "slow") {
        ctx.globalAlpha = 0.18;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 1.0;
        ctx.beginPath();
        ctx.arc(0,0, p.r*1.65, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // crit outline
    if (p.crit) {
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      if (tType === "shred") {
        starPath(12, p.r*1.82, p.r*1.15, Math.PI/12);
        ctx.stroke();
      } else if (tType === "breaker") {
        polyPath(4, p.r*1.65, Math.PI/4);
        ctx.stroke();
      } else if (tType === "splash") {
        starPath(5, p.r*1.75, p.r*0.95, state.time*2.5);
        ctx.stroke();
      } else {
        roundRectPath(-p.r*1.35, -p.r*0.65, p.r*2.95, p.r*1.30, p.r*0.65);
        ctx.stroke();
      }
    }

    // highlight slit
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#ffffff";
    roundRectPath(-p.r*1.0, -p.r*0.30, p.r*1.2, p.r*0.60, p.r*0.30);
    ctx.fill();
    ctx.restore();
  });
}


  function drawFx(f){
    const t = clamp(f.t / f.dur, 0, 1);

    if (f.kind === "spark") {
      const u = t;
      const ease = 1 - Math.pow(1 - u, 2);
      const dx = (f.dx || 0), dy = (f.dy || 0);
      const px = f.x + dx * ease;
      const py = f.y + dy * ease;
      const len = Math.hypot(dx, dy) || 1;
      const nx = dx / len, ny = dy / len;
      const tail = (f.tail || 14) * (1 - u);
      const sx = px - nx * tail;
      const sy = py - ny * tail;

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = (1 - u) * 0.9;
      ctx.strokeStyle = f.color || "#ffffff";
      ctx.lineWidth = (f.width || 2);
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(px, py);
      ctx.stroke();

      // glow pass
      ctx.globalAlpha *= 0.35;
      ctx.lineWidth = (f.width || 2) * 2.4;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(px, py);
      ctx.stroke();
      ctx.restore();
      return;
    }

    if (f.kind === "shard") {
      const u = t;
      const ease = 1 - Math.pow(1 - u, 2);
      const dx = (f.dx || 0), dy = (f.dy || 0);
      const px = f.x + dx * ease;
      const py = f.y + dy * ease;
      const size = (f.size || 8) * (1 - u * 0.25);
      const rot = (f.rot || 0) + (f.spin || 0) * u;

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.translate(px, py);
      ctx.rotate(rot);
      ctx.globalAlpha = (1 - u) * 0.75;
      ctx.fillStyle = f.color || "#cbe6ff";

      ctx.beginPath();
      ctx.moveTo(-size * 0.70, -size * 0.18);
      ctx.lineTo(size * 0.72, 0);
      ctx.lineTo(-size * 0.35, size * 0.42);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha *= 0.55;
      ctx.strokeStyle = "rgba(255,255,255,0.85)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
      return;
    }


    if (f.kind === "flash") {
      const r = f.r || 520;
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = (1 - t) * 0.55;
      const rr = lerp(0, r, t);
      const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, rr);
      g.addColorStop(0, f.color || "rgba(255,255,255,1)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(f.x, f.y, rr, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }

    if (f.kind === "ring") {
      const r = lerp(f.r0, f.r1, t);
      ctx.save();
      ctx.globalAlpha = (1 - t) * (f.a ?? 0.8);
      ctx.beginPath();
      ctx.arc(f.x,f.y, r, 0, Math.PI*2);
      ctx.strokeStyle = f.color;
      ctx.lineWidth = (f.w ?? 3);
      ctx.stroke();
      ctx.restore();
      return;
    }

    if (f.kind === "text") {
      ctx.save();
      ctx.globalAlpha = (1 - t);
      ctx.fillStyle = f.color;
      ctx.font = "900 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(f.text, f.x, f.y - 22*t);
      ctx.restore();
      return;
    }

    if (f.kind === "shieldWave") {
      const r = f.r0;
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = (1 - t) * 0.6;
      ctx.shadowColor = "#7dd3fc";
      ctx.shadowBlur = 14;
      ctx.globalAlpha = (1 - t) * 0.5;
      ctx.shadowColor = "#7dd3fc";
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.ellipse(f.x, f.y, r*0.88, r*0.80, 0, 0, Math.PI*2);
      ctx.fillStyle = "rgba(125,211,252,0.16)";
      ctx.fill();

      ctx.globalAlpha = (1 - t) * 0.55;
      ctx.beginPath();
      ctx.arc(f.x, f.y, r*0.9, 0, Math.PI*2);
      ctx.fillStyle = "rgba(125,211,252,0.22)";
      ctx.fill();

      ctx.globalAlpha = (1 - t) * 0.35;
      ctx.beginPath();
      ctx.arc(f.x, f.y, r*0.6, 0, Math.PI*2);
      ctx.fillStyle = "rgba(224,242,254,0.25)";
      ctx.fill();
      ctx.shadowBlur = 6;
      ctx.globalAlpha *= 0.85;
      ctx.beginPath();
      ctx.ellipse(f.x, f.y, r*0.78, r*0.68, 0, 0, Math.PI*2);
      ctx.strokeStyle = "#93c5fd";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.globalAlpha = (1 - t) * 0.35;
      ctx.beginPath();
      ctx.ellipse(f.x, f.y, r*0.55, r*0.48, 0, 0, Math.PI*2);
      ctx.strokeStyle = "#e0f2fe";
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.restore();
      return;
    }
if (f.kind === "line") {
  ctx.save();
  ctx.globalAlpha = (1 - t) * 0.85;
  ctx.strokeStyle = f.color;
  ctx.lineWidth = (f.width || 4);
  ctx.beginPath();
  ctx.moveTo(f.x1, f.y1);
  ctx.lineTo(f.x2, f.y2);
  ctx.stroke();

  // glow
  ctx.globalAlpha *= 0.45;
  ctx.lineWidth = (f.width || 4) * 2.2;
  ctx.beginPath();
  ctx.moveTo(f.x1, f.y1);
  ctx.lineTo(f.x2, f.y2);
  ctx.stroke();
  ctx.restore();
  return;
}

if (f.kind === "warn") {
  const r = lerp(f.r0, f.r1, t);
  ctx.save();
  ctx.globalAlpha = (1 - t) * 0.28;
  ctx.beginPath();
  ctx.arc(f.x,f.y, r, 0, Math.PI*2);
  ctx.fillStyle = f.color;
  ctx.fill();
  ctx.globalAlpha = (1 - t) * 0.85;
  ctx.beginPath();
  ctx.arc(f.x,f.y, r, 0, Math.PI*2);
  ctx.strokeStyle = f.color;
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();
  return;
}

  }

  function drawTopHUD(){
  // legacy canvas HUD removed (use the new HTML HUD)
  return;
}

function drawBossHUD(){
    if (!(state.phase==="wave" && state.wave===FINAL_WAVE)) return;
    const boss = state.enemies.find(e=>e.kind==="boss");
    if (!boss) return;

    const ratio = (boss.hpMax>0) ? (boss.hp / boss.hpMax) : 0;
    const phase = (state.final && state.final.phase) ? state.final.phase : 1;

    // ìµœì¢…ì „ ë³´ìŠ¤ HUD: ìƒë‹¨ìœ¼ë¡œ ì˜¬ë ¤ì„œ(ê²¹ì¹¨ ìµœì†Œí™”) ë” ëˆˆì— ë„ê²Œ í‘œì‹œ
    const x = 12, y = 18, w = 936, h = 28;

    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "#0e1624";
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = "#243040";
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);

    const pad = 10;
    const bx = x + pad;
    const by = y + 12;
    const bw = w - pad*2;
    const bh = 10;

    ctx.fillStyle = "#111827";
    ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = "#f472b6";
    ctx.fillRect(bx, by, bw*clamp(ratio,0,1), bh);

    ctx.fillStyle = "#e6edf3";
    ctx.font = "900 12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(`ìµœì¢… ë³´ìŠ¤ â€” í˜ì´ì¦ˆ ${phase}`, x + 14, y + 18);

    ctx.fillStyle = "#cbd5e1";
    ctx.font = "800 11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.textAlign = "right";
    ctx.fillText(`${Math.ceil(boss.hp)}/${Math.ceil(boss.hpMax)}`, x + w - 14, y + 18);

    ctx.restore();
  }


  // ---------- Cinematic Cards (ì›¨ì´ë¸Œ/ë³´ìŠ¤/íŒ¨ì‹œë¸Œ ì—°ì¶œ) ----------
  function drawCineCards(){
    const cine = state.cine;
    if (!cine || !Array.isArray(cine.cards) || cine.cards.length === 0) return;
    const now = gameSec();
    // ë§Œë£Œ ì¹´ë“œ ì •ë¦¬
    cine.cards = cine.cards.filter(c => (now - (c.t0||0)) < (c.dur||0));
    if (cine.cards.length === 0) return;

    const c = cine.cards[cine.cards.length - 1];
    const dur = Math.max(0.01, c.dur || 1.2);
    const t = clamp((now - (c.t0||0)) / dur, 0, 1);

    const easeOut = (x)=>1 - Math.pow(1-x, 3);
    const easeIn  = (x)=>x*x*x;
    const fadeIn  = easeOut(clamp(t/0.14, 0, 1));
    const fadeOut = easeIn(clamp((1-t)/0.22, 0, 1));
    const a = Math.min(fadeIn, fadeOut);
    if (a <= 0.01) return;

    const isFinalBossHud = (state.phase==="wave" && state.wave===FINAL_WAVE);
    const slide = (1 - easeOut(clamp(t/0.22,0,1)));

    // ì‘ì€ ì´ë²¤íŠ¸(ê³µëª…/ë²„ìŠ¤íŠ¸/ê¸´ê¸‰ë³´ê°• ë“±): í™”ë©´ì„ ëœ ê°€ë¦¬ëŠ” í† ìŠ¤íŠ¸
    if ((c.kind||"") === "toast") {
      const w = Math.min(420, W - 24);
      const h = 56;
      const x = 16;
      const baseY = isFinalBossHud ? 88 : 16;
      const y = baseY + slide * -10;

      ctx.save();
      ctx.globalAlpha = 0.95 * a;
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 14;
      ctx.fillStyle = "rgba(8,12,20,0.82)";
      roundRectPath(x, y, w, h, 14);
      ctx.fill();
      ctx.shadowBlur = 0;

      // accent
      ctx.globalAlpha = 0.98 * a;
      ctx.fillStyle = c.color || "#93c5fd";
      roundRectPath(x + 10, y + 10, 5, h - 20, 5);
      ctx.fill();

      // border
      ctx.globalAlpha = 0.65 * a;
      ctx.strokeStyle = "#243040";
      ctx.lineWidth = 1;
      roundRectPath(x, y, w, h, 14);
      ctx.stroke();

      const title = String(c.title||"");
      const sub   = String(c.sub||"");

      // title
      ctx.globalAlpha = 1.0 * a;
      ctx.textAlign = "left";
      ctx.font = "900 18px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(0,0,0,0.55)";
      ctx.strokeText(title, x + 24, y + 26);
      ctx.fillStyle = "#e6edf3";
      ctx.fillText(title, x + 24, y + 26);

      if (sub) {
        ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(0,0,0,0.50)";
        ctx.strokeText(sub, x + 24, y + 44);
        ctx.fillStyle = "#cbd5e1";
        ctx.fillText(sub, x + 24, y + 44);
      }

      // progress line
      ctx.globalAlpha = 0.42 * a;
      ctx.fillStyle = "#0b1220";
      ctx.fillRect(x + 24, y + h - 10, w - 42, 3);
      ctx.fillStyle = c.color || "#93c5fd";
      ctx.fillRect(x + 24, y + h - 10, (w - 42) * clamp(1 - t, 0, 1), 3);

      ctx.restore();
      return;
    }

    const baseY = isFinalBossHud ? 58 : 22;
    const y = baseY + slide * -16;

    const w = Math.min(560, W - 28);
    const h = 92;
    const x = (W - w) * 0.5;

    ctx.save();
    ctx.globalAlpha = 0.92 * a;
    ctx.shadowColor = "rgba(0,0,0,0.55)";
    ctx.shadowBlur = 18;
    ctx.fillStyle = "rgba(8,12,20,0.75)";
    roundRectPath(x, y, w, h, 18);
    ctx.fill();
    ctx.shadowBlur = 0;

    // accent bar
    ctx.globalAlpha = 0.95 * a;
    ctx.fillStyle = c.color || "#93c5fd";
    roundRectPath(x + 10, y + 10, 6, h - 20, 6);
    ctx.fill();

    // border
    ctx.globalAlpha = 0.55 * a;
    ctx.strokeStyle = "#243040";
    ctx.lineWidth = 1;
    roundRectPath(x, y, w, h, 18);
    ctx.stroke();

    // text
    ctx.globalAlpha = 1.0 * a;
    ctx.fillStyle = "#e6edf3";
    ctx.textAlign = "left";
    ctx.font = "900 24px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.fillText(String(c.title||""), x + 26, y + 40);

    const sub = String(c.sub||"");
    if (sub) {
      ctx.fillStyle = "#cbd5e1";
      ctx.font = "800 13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillText(sub, x + 26, y + 66);
    }

    // tiny progress line
    ctx.globalAlpha = 0.35 * a;
    ctx.fillStyle = "#0b1220";
    ctx.fillRect(x + 26, y + h - 14, w - 52, 4);
    ctx.fillStyle = c.color || "#93c5fd";
    ctx.fillRect(x + 26, y + h - 14, (w - 52) * clamp(1 - t, 0, 1), 4);

    ctx.restore();
  }



  function drawBar(x,y,w,h, ratio, color, label){
    ratio = clamp(ratio,0,1);
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#0b1220";
    ctx.fillRect(x,y,w,h);
    ctx.fillStyle = color;
    ctx.fillRect(x,y,w*ratio,h);
    ctx.strokeStyle = "#243040";
    ctx.strokeRect(x,y,w,h);
    ctx.fillStyle = "#cbd5e1";
    ctx.font = "900 10px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.textAlign = "left";
    ctx.fillText(label, x+4, y+h-2);
    ctx.restore();
  }

  function banner(text, color){
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "#0e1624";
    ctx.fillRect(12, H-54, 936, 42);
    ctx.strokeStyle = "#243040";
    ctx.strokeRect(12, H-54, 936, 42);
    ctx.fillStyle = color;
    ctx.font = "900 13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(text, W/2, H-28);
    ctx.restore();
  }

  function drawHoverTurret(){
    if (!mouse.inside) return;
    const idx = findTurretIndexAt(mouse.x, mouse.y, 18);
    if (idx < 0) return;

    const tr = state.turrets[idx];
    const base = turretBase(tr);
    const cost = (TURRET_TYPES[tr.type] ? TURRET_TYPES[tr.type].cost : 0);
    const refund = Math.max(0, Math.floor(cost * sellRefundRate()));

    ctx.save();

    // range highlight
    ctx.globalAlpha = 0.08;
    ctx.beginPath();
    ctx.arc(tr.x, tr.y, base.range, 0, Math.PI*2);
    ctx.fillStyle = "#fcd34d";
    ctx.fill();

    // turret ring
    ctx.globalAlpha = 0.35;
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#fcd34d";
    ctx.beginPath();
    ctx.arc(tr.x, tr.y, 16, 0, Math.PI*2);
    ctx.stroke();

    // hint text
    ctx.globalAlpha = 0.95;
    ctx.font = "700 12px system-ui, sans-serif";
    ctx.fillStyle = "#fde68a";
    ctx.textAlign = "center";
    ctx.fillText(`íŒë§¤: ìš°í´ë¦­/X (+${refund})`, tr.x, tr.y - 22);

    ctx.restore();
  }

  function drawGhost(){
    if (!mouse.inside) return;
    const mx = mouse.x, my = mouse.y;
    const tt = TURRET_TYPES[state.selected];
    const dCore = dist(mx,my, CORE_POS.x, CORE_POS.y);

    const ok = (
      dCore <= BUILD_RADIUS &&
      dCore >= CORE_RADIUS+30 &&
      state.crystals >= tt.cost &&
      !overlapsTurret(mx,my)
    );

    ctx.save();
    const col = ok ? "#93c5fd" : "#ff9fb2";
    ctx.globalAlpha = 0.22;
    withTransform(mx, my, 0, () => {
      ctx.fillStyle = "#0f172a";
      ctx.strokeStyle = col;
      ctx.lineWidth = 2;
      if (state.selected === "slow") {
        polyPath(6, 16, Math.PI/6);
      } else if (state.selected === "splash") {
        roundRectPath(-16, -14, 32, 28, 6);
      } else {
        polyPath(8, 16, Math.PI/8);
      }
      ctx.fill();
      ctx.stroke();

      // tiny barrel pointing to core (placement feedback)
      const a = Math.atan2(CORE_POS.y - my, CORE_POS.x - mx);
      withTransform(0, -2, a, () => {
        ctx.fillStyle = col;
        roundRectPath(2, -2.5, 16, 5, 2.5);
        ctx.fill();
      });
    });

    ctx.globalAlpha = 0.10;
    ctx.beginPath();
    ctx.arc(mx,my, tt.range, 0, Math.PI*2);
    ctx.fillStyle = ok ? "#93c5fd" : "#ff9fb2";
    ctx.fill();
    ctx.restore();
  }

  
  function syncBackground(){
    // NOTE: Page-wide background is disabled. The [ë°°ê²½] button controls the battlefield (canvas) only.
    // Keep the state flag only; no DOM class toggles.
    return;
  }

function refreshUI(){
    const tt = TURRET_TYPES[state.selected];
    const t = gameSec();
    const cdLeft = Math.max(0, state.core.aegisReadyAt - t);
    const repCdLeft = Math.max(0, state.core.repairReadyAt - t);
    const engCdLeft = Math.max(0, state.core.energyReadyAt - t);
    syncBackground();

    // (Fix) ì €ì¥/ìƒˆë¡œê³ ì¹¨ ë“±ìœ¼ë¡œ passiveIdê°€ ì´ë¯¸ ì¡´ì¬í•´ë„ ê¸€ë¡œìš°/ìƒ‰ìƒì´ í•­ìƒ ë™ê¸°í™”ë˜ê²Œ
    try { refreshCorePassiveUI(); } catch {}

    // íŒ¨ì‹œë¸Œ í‘œì‹œ
    let passiveBadge = "";
    if (state.core.passiveId) {
      const d = CORE_PASSIVES[state.core.passiveId];
      if (state.core.passiveId === "rebuild") {
        const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
        const tB = clamp((0.70 - hpFrac) / 0.60, 0, 1);
        const dr = (12*tB);
        const tNow = gameSec();
        const emOn = (tNow < (state.core.rebuildEmergencyUntil||0));
        const emLeft = Math.max(0, (state.core.rebuildEmergencyUntil||0) - tNow);
        passiveBadge = `<span class="badge ${d.colorClass}">íŒ¨ì‹œë¸Œ: ${d.name} (í”¼í•´ê°ì†Œ ${dr.toFixed(0)}%${emOn ? ` +ê¸´ê¸‰(-38%, ${emLeft.toFixed(1)}s)` : ''})<\/span> `;
      } else if (state.core.passiveId === "resonance") {
        const g = resonanceGauge01();
        const pct = Math.round(g*100);
        const dMul = Math.round(30*g);
        const fMul = Math.round(18*g);
        passiveBadge = `<span class="badge ${d.colorClass}">íŒ¨ì‹œë¸Œ: ${d.name} (ê²Œì´ì§€ ${pct}% | í”¼í•´ +${dMul}% ê³µì† +${fMul}%)<\/span> `;
      
      } else if (state.core.passiveId === "overload") {
        const tNow = gameSec();
        const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
        const tO = clamp((0.40 - hpFrac) / 0.30, 0, 1);

        // ë²„ìŠ¤íŠ¸/ì‡¼í¬ ìƒíƒœ
        overloadEnsure();
        const burstOn = (tNow < (state.core.overloadBurstUntil||0));
        const burstLeft = Math.max(0, (state.core.overloadBurstUntil||0) - tNow);
        const cdLeft = Math.max(0, (state.core.overloadBurstReadyAt||0) - tNow);
        const burstInfo = burstOn ? `ë²„ìŠ¤íŠ¸ ${burstLeft.toFixed(1)}s` : (cdLeft>0.05 ? `ì¿¨ ${cdLeft.toFixed(1)}s` : `READY`);

        // í˜„ì¬ í•„ë“œ í‘œì‹ ìµœëŒ€ ì¤‘ì²©(ë§Œë£Œëœ í‘œì‹ ì œì™¸)
        let maxSt = 0;
        for (const e of state.enemies) {
          if (!e) continue;
          if (tNow < (e.ovMarkUntil||0)) maxSt = Math.max(maxSt, (e.ovMarkStacks||0));
        }
        const markInfo = `í‘œì‹ ${maxSt}/${OVERLOAD_CFG.markMax}`;

        passiveBadge = `<span class="badge ${d.colorClass}">íŒ¨ì‹œë¸Œ: ${d.name} (ê³¼ë¶€í•˜ ${(tO*100)|0}% | ${burstInfo} | ${markInfo})<\/span> `;
      } else if (state.core.passiveId === "overdrive") {
        const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
        const tO = clamp((0.40 - hpFrac) / 0.30, 0, 1);
        passiveBadge = `<span class="badge ${d.colorClass}">íŒ¨ì‹œë¸Œ: ${d.name} (ì˜¤ë²„ë“œë¼ì´ë¸Œ ${(tO*100)|0}%)<\/span> `;
      }
    } else {
      passiveBadge = `<span class="badge">íŒ¨ì‹œë¸Œ: ë¯¸ì„ íƒ<\/span> `;
    }

    if (uiCrystals) uiCrystals.textContent = String(state.crystals|0);


    // ë°©ì–´ ìˆ˜ì¹˜ í‘œì‹œ (íŒ¨ì‹œë¸Œ ë³´ì • í¬í•¨)
    let dispHpArmor = state.core.hpArmor;
    let dispShArmor = state.core.shieldArmor;
    if (state.core.passiveId === "rebuild") {
      const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
      const tB = clamp((0.70 - hpFrac) / 0.60, 0, 1);
      // í•˜ë“œëª¨ë“œì—ì„œëŠ” íŒ¨ì‹œë¸Œ ëª¨ë“  íš¨ê³¼ê°€ 80% ì ìš©ë˜ì–´ì•¼ í•˜ë¯€ë¡œ,
      // HUD í‘œê¸°ë„ ì‹¤ì œ íŒ¨ì‹œë¸Œ ìŠ¤ì¼€ì¼(passiveScale)ê³¼ ë™ì¼í•˜ê²Œ ë§ì¶˜ë‹¤.
      // (ìµœëŒ€ ë°©ì–´ +15 / ë³´í˜¸ë§‰ë°©ì–´ +7.5)
      dispHpArmor += passiveScale(15) * tB;
      dispShArmor += passiveScale(7.5) * tB;
    }
    const fmtArmor = (x)=>{
      const r = Math.round(x);
      if (Math.abs(x - r) < 1e-6) return String(r);
      return x.toFixed(1);
    };
    const hpArmorText = fmtArmor(dispHpArmor);
    const shArmorText = fmtArmor(dispShArmor);

    // ===== ìƒë‹¨ HUD ì—…ë°ì´íŠ¸ =====
    const hp01 = state.core.hpMax>0 ? clamp(state.core.hp/state.core.hpMax, 0, 1) : 0;
    const sh01 = state.core.shieldMax>0 ? clamp(state.core.shield/state.core.shieldMax, 0, 1) : 0;
    if (hudHpFill) hudHpFill.style.width = `${(hp01*100).toFixed(1)}%`;
    if (hudShFill) hudShFill.style.width = `${(sh01*100).toFixed(1)}%`;
    if (hudHpText) hudHpText.textContent = `${Math.ceil(state.core.hp)}/${state.core.hpMax}`;
    if (hudShText) hudShText.textContent = `${Math.ceil(state.core.shield)}/${state.core.shieldMax}`;

    // ===== HP ì €ì²´ë ¥ HUD ê²½ê³  (visual only; does NOT change mechanics) =====
    try {
      const hpFrac = hp01;
      const BLUE_T = 0.70;   // matches blue flame threshold
      const CRIT_T = 0.25;   // critical warning threshold
      const isCrit = (hpFrac <= CRIT_T);
      const isBlue = (hpFrac <= BLUE_T) && !isCrit;
      if (hudHpRow && hudHpRow.classList) {
        hudHpRow.classList.toggle("hpBlue", isBlue);
        hudHpRow.classList.toggle("hpCrit", isCrit);
      }
      if (hudHpText && hudHpText.classList) {
        hudHpText.classList.toggle("hpBlue", isBlue);
        hudHpText.classList.toggle("hpCrit", isCrit);
      }
    } catch(e) {}


    if (hudWave) {
      const ph = (state.phase === 'wave') ? 'ì „íˆ¬' : (state.phase==='build'?'ì¤€ë¹„':(state.phase==='fail'?'ì‹¤íŒ¨':(state.phase==='end'?'í´ë¦¬ì–´':'')));
      const thName = (state.spawn && state.spawn.spec && state.spawn.spec.themeName) ? state.spawn.spec.themeName : (waveSpec ? (waveSpec(state.wave).themeName||"") : "");
      hudWave.textContent = `Wave ${state.wave}${ph ? ` Â· ${ph}` : ``}${thName ? ` Â· ${thName}` : ``}`;
    }
    if (hudArmor) hudArmor.textContent = hpArmorText;
    if (hudShArmor) hudShArmor.textContent = shArmorText;
    if (hudMeta) hudMeta.textContent = `${state.speed.toFixed(1)}x${state.cheat ? ' Â· ì¹˜íŠ¸' : ''}`;


    // ===== ìƒíƒœì´ìƒ(ë””ë²„í”„/íŠ¹ìˆ˜ìƒíƒœ) HUD í‘œì‹œ =====
    if (typeof hudStatusRow !== 'undefined' && hudStatusRow) {
      const tNow = gameSec();
      const chips = [];

      // ì¥ë²½/ì†Œë¹„ ì•„ì´í…œ ë²„í”„
      const barCd = Math.max(0, (state.core.barrierReadyAt||0) - tNow);
      if (state.core.barrierActive){
        const left = Math.max(0, (state.core.barrierUntil||0) - tNow);
        chips.push({ label:'ë°©ë²½', left:left, color:'#93c5fd', pr:4 });
      }
      else if (barCd > 0.05) chips.push({ label:'ë°©ë²½CD', left:barCd, color:'#93c5fd', pr:1 });

      const fireLeft = Math.max(0, (state.shop.fireUntil||0) - tNow);
      if (fireLeft > 0.05) chips.push({ label:'ê³µì†', left:fireLeft, color:'#fcd34d', pr:4 });
      if (state.phase==='wave' && state.shop.slowWave === state.wave) chips.push({ label:'ìŠ¬ë¡œìš°', left:0, color:'#a7f3d0', pr:3 });
      const addUntil = (label, until, color, pr=0) => {
        const left = Math.max(0, (until||0) - tNow);
        if (left > 0.05) chips.push({ label, left, color, pr });
      };

      // shield regen display (visual only; does NOT change mechanics)
      let __regenChip = null;
      let __regenVisualOn = false;
      try {
        const phaseAllows = (state.phase === "wave" || state.core.shieldRegenOutOfWave);
        const blocked = (tNow < (state.core.shieldRegenBlockedUntil || 0));
        if (phaseAllows && !blocked && state.phase !== "collapse" && !(state.phase==="win" && state.win)) {
          const tReal = nowSec();
          const regenBoost = (tReal < (state.core.aegisActiveUntil||0)) ? 3.2 : 1.0;

          let passiveShieldRegenMul = 1.0;
          if (state.core.passiveId === "rebuild") {
            passiveShieldRegenMul *= passiveScaleMul(1.15);
            if (state.wave === FINAL_WAVE) passiveShieldRegenMul *= passiveScaleMul(1.10);
          }
          if (state.core.passiveId === "overload") {
            const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
            const tO = clamp((0.40 - hpFrac) / 0.30, 0, 1);
            passiveShieldRegenMul *= (1 + passiveScale(1.10)*tO);
          }
          if (state.core.passiveId === "overdrive") {
            const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
            const tO = clamp((0.40 - hpFrac) / 0.30, 0, 1);
            passiveShieldRegenMul *= (1 + passiveScale(0.60)*tO);
          }

          const regen = (state.core.shieldRegen||0) * (state.mods.shieldRegenMul||1) * regenBoost * passiveShieldRegenMul;
          if (isFinite(regen) && regen > 0.0001) {
            __regenChip = { label: `ì¬ìƒ +${regen.toFixed(1)}/s`, left: 0, color: '#93c5fd', pr: 0, kind:'regen' };
            __regenVisualOn = (state.core.shield < state.core.shieldMax - 0.05);
          }
        }
      } catch(e) {}

      // apply shimmer to shield bar only when regen is actively filling
      try {
        if (typeof hudShFill !== 'undefined' && hudShFill && hudShFill.classList) {
          hudShFill.classList.toggle('shimmer', !!__regenVisualOn);
        }
      } catch(e) {}


      // timed debuffs
      addUntil('ì¬ìƒì°¨ë‹¨', state.core.shieldRegenBlockedUntil, '#60a5fa', 4);
      addUntil('ìˆ˜ë¦¬ì°¨ë‹¨', state.core.repairBlockedUntil,      '#f472b6', 4);
      addUntil('EMP',      state.core.empUntil,               '#fbbf24', 3);

      // passive/skill states
      addUntil('ê¸´ê¸‰ë³´í˜¸ë§‰', state.core.aegisActiveUntil,        '#93c5fd', 2);
      addUntil('ê¸´ê¸‰ë³´ê°•',   state.core.rebuildEmergencyUntil,   '#93c5fd', 2);
      addUntil('ë²„ìŠ¤íŠ¸',     state.core.overloadBurstUntil,      '#fb7185', 2);

      // energy cannon charging
      if (state.core.energyCharging) {
        const left = Math.max(0, (state.core.energyChargeUntil||0) - tNow);
        if (left > 0.05) chips.push({ label:'ì¶©ì „', left, color:'#c4b5fd', pr:1 });
      }

      // event-like global modifiers
      const absMul = (state.mods && state.mods.shieldAbsorbMul !== undefined) ? state.mods.shieldAbsorbMul : 1;
      if (absMul <= 0.001) chips.push({ label:'ë³´í˜¸ë§‰ë¬´ì‹œ', left:0, color:'#a78bfa', pr:5 });
      else if (absMul < 0.999) chips.push({ label:'í¡ìˆ˜ì•½í™”', left:0, color:'#93c5fd', pr:5 });

      // render (max 6 to avoid clutter)
      chips.sort((a,b)=> (b.pr-a.pr) || (b.left-a.left));
      const maxOther = __regenChip ? 5 : 6;
      const show = chips.slice(0, maxOther);
      if (__regenChip) show.push(__regenChip);
      if (!show.length) {
        hudStatusRow.style.display = 'none';
        hudStatusRow.innerHTML = '';
      } else {
        hudStatusRow.style.display = 'flex';
        hudStatusRow.innerHTML = show.map(s=>{
          const timeTxt = (s.left>0) ? ` <b>${s.left.toFixed(1)}s</b>` : '';
          return `<span class="hudStatus" style="border-color:${s.color};color:${s.color};">${s.label}${timeTxt}</span>`;
        }).join('');
      }
    }

    // íŒ¨ì‹œë¸Œ í…ìŠ¤íŠ¸/ê²Œì´ì§€
    const passivePlain = (passiveBadge || '').replace(/<[^>]*>/g,'').trim();
    if (hudPassiveText) hudPassiveText.textContent = passivePlain || 'íŒ¨ì‹œë¸Œ: ë¯¸ì„ íƒ';

    let pGauge = 0;
    if (state.core.passiveId === "rebuild") {
      const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
      pGauge = clamp((0.70 - hpFrac) / 0.60, 0, 1);
    } else if (state.core.passiveId === "resonance") {
      pGauge = resonanceGauge01();
    } else if (state.core.passiveId === "overload" || state.core.passiveId === "overdrive") {
      const hpFrac = state.core.hpMax>0 ? (state.core.hp/state.core.hpMax) : 1;
      pGauge = clamp((0.40 - hpFrac) / 0.30, 0, 1);
    } else {
      pGauge = 0;
    }
    if (hudPassiveFill) hudPassiveFill.style.width = `${(clamp(pGauge,0,1)*100).toFixed(1)}%`;

    // ê¸°ì¡´ ìš°ì¸¡ íŒ¨ë„ì˜ í…ìŠ¤íŠ¸ ë±ƒì§€ëŠ” ìˆ¨ê¹€(ëŒ€í­ UI ê°œí¸)
    if (uiStats) uiStats.innerHTML = '';

    // UI message (ì—…ê·¸ë ˆì´ë“œ/ì•ˆë‚´) â€” ì´ë²¤íŠ¸ ì •ë³´ì— ë®ì–´ì“°ì´ì§€ ì•Šê²Œ ë¶„ë¦¬
    if (uiMsg) {
      const tNow = nowSec();
      if (state.uiMsg && tNow < state.uiMsgUntil) uiMsg.textContent = state.uiMsg;
      else { state.uiMsg = ""; uiMsg.textContent = ""; }
    }

    // Repair ë²„íŠ¼ UI
    if (typeof btnRepair !== 'undefined' && btnRepair) {
      const affordable = state.crystals >= state.core.repairCost;
      const canUse = (repCdLeft <= 0) && (state.phase !== 'fail') && (state.core.hp < state.core.hpMax - 0.01) && affordable;
      btnRepair.disabled = !canUse;
      btnRepair.textContent = repCdLeft>0 ? `ìˆ˜ë¦¬ (${repCdLeft.toFixed(1)}s)` : `ìˆ˜ë¦¬ (-${state.core.repairCost})`;
      if (btnEnergy) {
        const charging = !!state.core.energyCharging;
        const chargeLeft = charging ? Math.max(0, state.core.energyChargeUntil - t) : 0;
        const hasTargetNow = !!(state.enemies && state.enemies.some(e=>e && e.hp > 0));
        btnEnergy.disabled = (state.phase !== 'wave') || charging || (engCdLeft>0) || !hasTargetNow;
        btnEnergy.textContent = charging
          ? `ì—ë„ˆì§€í¬ ì¶©ì „ (${chargeLeft.toFixed(1)}s)`
          : (engCdLeft>0 ? `ì—ë„ˆì§€í¬ (${engCdLeft.toFixed(1)}s)` : `ì—ë„ˆì§€í¬ (${Math.round((state.core.energyDmg||800) * (1 + Math.max(0, state.wave-1)*0.018))})`);
      }

// Barrier ë²„íŠ¼ UI
if (btnBarrier) {
  const barActive = !!state.core.barrierActive;
  const barCdLeft = Math.max(0, (state.core.barrierReadyAt||0) - t);
  const affordable = state.crystals >= BARRIER_COST;
  const canUse = !barActive && (barCdLeft <= 0.05) && affordable && (state.phase !== 'fail') && (state.phase !== 'win');
  btnBarrier.disabled = !canUse;
  const barLeft = barActive ? Math.max(0, (state.core.barrierUntil||0) - t) : 0;
  btnBarrier.textContent = barActive ? `ë°©ë²½ (${barLeft.toFixed(1)}s)` : (barCdLeft>0.05 ? `ë°©ë²½ (${barCdLeft.toFixed(1)}s)` : `ë°©ë²½ (-${BARRIER_COST})`);
}

// Shop item ë²„íŠ¼ UI
if (uiShopItemHint) {
  uiShopItemHint.innerHTML = `ì¦‰ì‹œ ìˆ˜ë¦¬(-${SHOP_ITEM_REPAIR_COST}) Â· ê³µì† 10s(-${SHOP_ITEM_FIRE_COST}) Â· ìŠ¬ë¡œìš° 1ì›¨ì´ë¸Œ(-${SHOP_ITEM_SLOW_COST})`;
}
if (btnItemRepair){
  const cd = Math.max(0, (state.shop.repairReadyAt||0) - t);
  const can = (state.phase !== 'fail') && (state.phase !== 'win') && (cd<=0.05) && (state.core.hp < state.core.hpMax - 0.01) && (state.crystals >= SHOP_ITEM_REPAIR_COST);
  btnItemRepair.disabled = !can;
  btnItemRepair.textContent = cd>0.05 ? `ì¦‰ì‹œ ìˆ˜ë¦¬ (${cd.toFixed(1)}s)` : `ì¦‰ì‹œ ìˆ˜ë¦¬ (-${SHOP_ITEM_REPAIR_COST})`;
}
if (btnItemFire){
  const cd = Math.max(0, (state.shop.fireReadyAt||0) - t);
  const inWave = (state.phase === 'wave');
  const can = (state.phase !== 'fail') && (state.phase !== 'win') && inWave && (cd<=0.05) && (state.crystals >= SHOP_ITEM_FIRE_COST);
  btnItemFire.disabled = !can;
  btnItemFire.textContent = cd>0.05 ? `ê³µì† 10s (${cd.toFixed(1)}s)` : `ê³µì† 10s (-${SHOP_ITEM_FIRE_COST})`;
}
if (btnItemSlow){
  const cd = Math.max(0, (state.shop.slowReadyAt||0) - t);
  const inWave = (state.phase === 'wave');
  const already = (state.shop.slowWave === state.wave);
  const can = (state.phase !== 'fail') && (state.phase !== 'win') && inWave && !already && (cd<=0.05) && (state.crystals >= SHOP_ITEM_SLOW_COST);
  btnItemSlow.disabled = !can;
  btnItemSlow.textContent = already ? `ì›¨ì´ë¸Œ ìŠ¬ë¡œìš° (ì ìš©ì¤‘)` : (cd>0.05 ? `ì›¨ì´ë¸Œ ìŠ¬ë¡œìš° (${cd.toFixed(1)}s)` : `ì›¨ì´ë¸Œ ìŠ¬ë¡œìš° (-${SHOP_ITEM_SLOW_COST})`);
}

// ëª¨ë°”ì¼ ì¥ë²½ ë²„íŠ¼ UI
if (mbBarrier){
  const tNow = t;
  const barActive = !!state.core.barrierActive;
  const cd = Math.max(0, (state.core.barrierReadyAt||0) - t);
  const affordable = state.crystals >= BARRIER_COST;
  const can = !barActive && (cd<=0.05) && affordable && (state.phase !== 'fail') && (state.phase !== 'win');
  mbBarrier.disabled = !can;
  const sp = mbBarrier.querySelector('span'); if (sp) sp.textContent = 'ì¥ë²½';
  const sm = mbBarrier.querySelector('small');
  if (sm){
    if (barActive){
      const left = Math.max(0, (state.core.barrierUntil||0) - tNow);
      sm.textContent = `${Math.ceil(left)}s`;
    }
    else if (cd>0.05) sm.textContent = `${Math.ceil(cd)}s`;
    else sm.textContent = `-${BARRIER_COST}`;
  }
}
      if (mbEnergy){
        const inWave = (state.phase === 'wave');
        const charging = !!state.core.energyCharging;
        const chargeLeft = charging ? Math.max(0, state.core.energyChargeUntil - t) : 0;
        const hasTarget = !!(state.enemies && state.enemies.some(e=>e && e.hp > 0));
        const canUseEnergy = inWave && !charging && (engCdLeft <= 0) && hasTarget;
        mbEnergy.disabled = !canUseEnergy;
        const sp = mbEnergy.querySelector('span');
        if (sp) sp.textContent = 'ì—ë„ˆì§€í¬';
        const sm = mbEnergy.querySelector('small');
        if (sm){
          if (!inWave) sm.textContent = 'ì›¨ì´ë¸Œ';
          else if (charging) sm.textContent = `ì¶©ì „ ${Math.ceil(chargeLeft)}s`;
          else if (!hasTarget) sm.textContent = 'ëŒ€ìƒì—†ìŒ';
          else if (engCdLeft > 0) sm.textContent = `${Math.ceil(engCdLeft)}s`;
          else sm.textContent = String(Math.round((state.core.energyDmg||800) * (1 + Math.max(0, state.wave-1)*0.018)));
        }
      }

      if (btnBg) {
        btnBg.textContent = (state.ui.bgMode===0) ? 'ë°°ê²½ ë”' : (state.ui.bgMode===2 ? 'ë°°ê²½ ê°•í•¨' : 'ë°°ê²½ ì•½í•¨');
      }

    }

    if (uiEvent) {
  if (state.wave === FINAL_WAVE && (state.phase === "finalprep" || state.phase === "wave")) {
    const c = state.finalChoice || "ë¯¸ì„ íƒ";
    uiEvent.textContent = `ìµœì¢…ì „: ìµœì¢… ì§€ì› ${c==="offense" ? "í™”ë ¥" : (c==="defense" ? "ë°©í˜¸" : c)}`;
  } else {
    uiEvent.textContent = state.event
      ? `í˜„ì¬ ì´ë²¤íŠ¸: ${state.event.name} â€” ${state.event.desc}`
      : `í˜„ì¬ ì´ë²¤íŠ¸: ì—†ìŒ (3ì›¨ì´ë¸Œë§ˆë‹¤ 1íšŒ)`;
  }
}

// Wave button label + state
    if (btnWave) {
      if (state.phase === "wave") {
        btnWave.disabled = true;
        btnWave.textContent = "ì›¨ì´ë¸Œ ì§„í–‰ ì¤‘...";
      } else if (state.phase === "fail") {
        btnWave.disabled = true;
        btnWave.textContent = "ë¶•ê´´ë¨";
      } else if (state.phase === "win") {
        btnWave.disabled = true;
        btnWave.textContent = "í´ë¦¬ì–´!";
      } else if (state.phase === "clear") {
        const left = Math.max(0, state.autoStartAt - gameSec());
        btnWave.disabled = false;
        btnWave.textContent = left > 0.05 ? `ë‹¤ìŒ ì›¨ì´ë¸Œ (${left.toFixed(1)}s)` : "ë‹¤ìŒ ì›¨ì´ë¸Œ ì‹œì‘";
} else if (state.phase === "finalprep") {
  const left = Math.max(0, state.finalPrepEndsAt - gameSec());
  btnWave.disabled = false;
  btnWave.textContent = left > 0.05 ? `ìµœì¢…ì „ ì¤€ë¹„ (${left.toFixed(1)}s)` : "ìµœì¢…ì „ ì‹œì‘";
} else {
        btnWave.disabled = false;
        btnWave.textContent = "ì›¨ì´ë¸Œ ì‹œì‘";
      }
    }

    
    // Restart button label
    if (btnRestart) {
      btnRestart.textContent = "ì¬ì‹œì‘";
    }

    // Speed/Cheat buttons + hint
    if (btnSpeed) btnSpeed.textContent = `ë°°ì† ${state.speed.toFixed(2).replace(/\.00$/,".0")}x`;
    if (btnCheat) btnCheat.textContent = state.cheat ? "ì¹˜íŠ¸ ON" : "ì¹˜íŠ¸ OFF";
    syncCheatButtons();
    if (uiCheat) {
      uiCheat.textContent = state.cheat
        ? "ì¹˜íŠ¸í‚¤: T=í† ê¸€, K=í¬ë¦¬ìŠ¤íƒˆ+500, H=HPí’€, J=ë³´í˜¸ë§‰í’€, B=ì ì‚­ì œ, N=ì›¨ì´ë¸ŒìŠ¤í‚µ, U=ì—…ê¸€MAX, G=ë¬´ì , P=íŒ¨ì‹œë¸Œ100"
        : "";
    }


    if (uiPreview) {
      const w = state.wave;
      const spec = waveSpec(w);
      const label = (state.phase === "wave") ? "í˜„ì¬ ì›¨ì´ë¸Œ" : "ë‹¤ìŒ ì›¨ì´ë¸Œ";
      const list = [];
      list.push(ENEMY_ARCH.grunt.name);
      if (w >= 2) list.push(ENEMY_ARCH.runner.name);
      if (w >= 2) list.push(ENEMY_ARCH.shooter.name);
      if (w >= 3) list.push(ENEMY_ARCH.shieldbreaker.name);
      if (w >= 4) list.push(ENEMY_ARCH.piercer.name);
      if (w >= 6) list.push(ENEMY_ARCH.bruiser.name);
      if (w >= 6) list.push(ENEMY_ARCH.bomber.name);
      if (w >= 8) list.push(ENEMY_ARCH.disruptor.name);

      const bossLine = spec.isBoss ? `ë³´ìŠ¤: ${ENEMY_ARCH.boss.name} í¬í•¨` : "ë³´ìŠ¤: ì—†ìŒ";
      uiPreview.innerHTML =
        `<b>${label} ${w}${spec.isBoss ? " (ë³´ìŠ¤ ì›¨ì´ë¸Œ)" : ""}</b><br>` +
        `ì  ìˆ˜: ${spec.count} / ìŠ¤í°: ${spec.spawnRate.toFixed(2)}/s<br>` +
        `${bossLine}<br>` +
        `ë“±ì¥: ${list.join(", ")}`;
    }

    try { refreshContractUI(); } catch(e) {}

    try { refreshMissionUI(); } catch(e) {}

// ì—…ê·¸ë ˆì´ë“œ DOM ê°±ì‹ (hover ì‹œì—ëŠ” ë©ˆì¶¤)
    if (!window.__upgLastRenderAt) window.__upgLastRenderAt = 0;
    if (typeof window.__freezeUpgRender === 'undefined') window.__freezeUpgRender = false;
    if (typeof window.__upgForceRender === 'undefined') window.__upgForceRender = false;
    const _tNow = nowSec();
    const _need = window.__upgForceRender || (_tNow - window.__upgLastRenderAt > 0.25);
    if (_need) {
      if (!window.__freezeUpgRender || window.__upgForceRender) {
        window.__upgLastRenderAt = _tNow;
        window.__upgForceRender = false;
        renderUpgrades();
      }
    }

// Final support UI (wave 30 prep)
if (finalSupportPanel) {
  const show = (state.phase === "finalprep");
  finalSupportPanel.classList.toggle("hidden", !show);
  if (show) {
    const c = state.finalChoice;
    if (btnFinalOffense) btnFinalOffense.classList.toggle("active", c==="offense");
    if (btnFinalDefense) btnFinalDefense.classList.toggle("active", c==="defense");
    if (uiFinalSupportDesc) {
      const left = Math.max(0, state.finalPrepEndsAt - gameSec());
      uiFinalSupportDesc.innerHTML = `ì›¨ì´ë¸Œ 30 ì‹œì‘ê¹Œì§€ <b>${left.toFixed(1)}s</b> â€” ` +
        (c ? (`í˜„ì¬ ì„ íƒ: <b>${c==="offense" ? "í™”ë ¥ ì§€ì›" : "ë°©í˜¸ ê°•í™”"}</b>`) : "ì•„ì§ ì„ íƒí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
    }
  }
}

// Mobile: final support row
if (mbFinalRow) {
  const show = (state.phase === "finalprep");
  mbFinalRow.classList.toggle("hidden", !show);
  if (show) {
    const c = state.finalChoice;
    if (mbFinalOffense) mbFinalOffense.classList.toggle("active", c==="offense");
    if (mbFinalDefense) mbFinalDefense.classList.toggle("active", c==="defense");
  }
}

    try { renderRecords(); } catch(e) {}
  }

  // ---------- Wire Panel (ì†ìƒ ê³ ì • + ì¬ì‹œì‘ ê²€ì •ì„  ë²„ê·¸ ìˆ˜ì •) ----------
  const WG = "rgb(60,255,90)";
  const WY = "rgb(255,230,90)";
  const WR = "rgb(255,80,80)";
  const SB = "rgb(60,200,255)";

  const wire = {
    segs: null,
    outlinePolys: null,
    cachedColors: [],
    thY: [],
    thR: [],
    seed: 1337,
    oneYellowIdx: -1,
  };

  function wireReset(){
    wire.segs = null;
    wire.outlinePolys = null;
    wire.shieldPoly = null;
    wire.cachedColors = [];
    wire.thY = [];
    wire.thR = [];
    wire.oneYellowIdx = -1;
  }

      function buildWireSegments(cx, cy, s){
    const P = (nx,ny)=>({x: cx + nx*s, y: cy + ny*s});

    // (ì‹ ê·œ ìˆ˜ì •íƒ€ì›Œ ì‹¤ë£¨ì—£) ì¤‘ì•™ í¬ë¦¬ìŠ¤íƒˆ + ì¢Œ/ìš° ê°€ë“œ + í° ë°›ì¹¨ëŒ€ + ì˜¤ë¸Œ(ì›í˜•)
    const crystal = [
      P(0,-1.22), P(0.50,-0.62), P(0.42,0.10), P(0.22,0.62),
      P(0,0.82),  P(-0.22,0.62), P(-0.42,0.10), P(-0.50,-0.62)
    ];

    const leftG  = [P(-1.10,0.34),P(-0.76,0.12),P(-0.58,0.34),P(-0.62,0.96),P(-0.86,1.12),P(-1.16,0.78),P(-1.18,0.52)];
    const rightG = [P(1.10,0.34),P(0.76,0.12),P(0.58,0.34),P(0.62,0.96),P(0.86,1.12),P(1.16,0.78),P(1.18,0.52)];

    const base = [P(-1.10,0.78),P(1.10,0.78),P(0.88,1.32),P(0.30,1.40),P(-0.30,1.40),P(-0.88,1.32)];

    const plate = [P(-0.32,0.78),P(0.32,0.78),P(0.42,1.10),P(-0.42,1.10)];

    function ngon(cx0, cy0, r, n=8, rot=-Math.PI/8){
      const out = [];
      for (let i=0;i<n;i++){
        const a = rot + i*(Math.PI*2/n);
        out.push(P(cx0 + Math.cos(a)*r, cy0 + Math.sin(a)*r));
      }
      return out;
    }
    const orbL = ngon(-0.88, 0.56, 0.13, 8);
    const orbR = ngon(0.88, 0.56, 0.13, 8);

    // í¬ë¦¬ìŠ¤íƒˆ íŒ¨ì‹¯(ë‚´ë¶€ì„ )
    const facets = [
      [P(0,-1.00), P(0,0.74)],
      [P(-0.26,-0.48), P(0.18,-0.10)],
      [P(0.26,-0.48), P(-0.18,-0.10)],
      [P(-0.18,0.22), P(0,0.58)],
      [P(0.18,0.22), P(0,0.58)],
      [P(-0.34,0.06), P(0.34,0.06)]
    ];

    // ë°›ì¹¨ëŒ€ ë””í…Œì¼(ì—ë„ˆì§€ ë¼ì¸)
    const baseLines = [
      [P(-0.86,0.92),P(0.86,0.92)],
      [P(-0.72,1.06),P(0.72,1.06)],
      [P(-0.58,1.20),P(0.58,1.20)],
      [P(-0.96,0.78),P(-0.88,1.32)],
      [P(0.96,0.78),P(0.88,1.32)],
    ];

    function polySeg(poly){
      const out = [];
      for (let i=0;i<poly.length;i++){
        const a = poly[i], b = poly[(i+1)%poly.length];
        out.push([a,b]);
      }
      return out;
    }

    // ë³´í˜¸ë§‰ í…Œë‘ë¦¬ëŠ” ì „ì²´ ì‹¤ë£¨ì—£ 1ê°œë§Œ (ë„ˆë¬´ ë²ˆì©ì„ ë°©ì§€)
    const outline = [P(0,-1.22),P(0.62,-0.50),P(1.18,0.52),P(1.10,0.78),P(0.88,1.32),P(0.30,1.40),P(-0.30,1.40),P(-0.88,1.32),P(-1.10,0.78),P(-1.18,0.52),P(-0.62,-0.50)];

    return {
      shieldPoly: outline,
      outlinePolys: [outline],
      segs: [
        ...polySeg(crystal),
        ...polySeg(leftG),
        ...polySeg(rightG),
        ...polySeg(base),
        ...polySeg(plate),
        ...polySeg(orbL),
        ...polySeg(orbR),
        ...facets,
        ...baseLines,
      ]
    };
  }


  function wireEnsureGeometry(){
    // âœ… ì„¸ê·¸ë¨¼íŠ¸ê°€ ìˆìœ¼ë‚˜ ìºì‹œ ê¸¸ì´ê°€ ì•ˆ ë§ìœ¼ë©´ ì¬ì´ˆê¸°í™”(ê²€ì •ì„  ë°©ì§€)
    if (wire.segs && wire.cachedColors.length === wire.segs.length && wire.thY.length === wire.segs.length) return;

    const ww = wireCanvas.width, wh = wireCanvas.height;
    const cx = ww*0.5, cy = wh*0.55;
    const s  = Math.min(ww,wh) * (detectMobile() ? 0.32 : 0.38);

    const shape = buildWireSegments(cx,cy,s);
    wire.segs = shape.segs;
    wire.outlinePolys = shape.outlinePolys;

    wire.shieldPoly = shape.shieldPoly || null;
    wire.cachedColors = new Array(wire.segs.length).fill(WG);

    const prng = mulberry32(wire.seed);
    wire.thY = new Array(wire.segs.length);
    wire.thR = new Array(wire.segs.length);
    for (let i=0;i<wire.segs.length;i++){
      const y = 0.06 + prng()*0.60;
      let r = y + (0.14 + prng()*0.30);
      r = Math.min(r, 0.98);
      wire.thY[i] = y;
      wire.thR[i] = r;
    }
  }

  function shieldLW(ratio){
    const maxW = 14, minW = 2;
    return minW + (maxW-minW)*clamp(ratio,0,1);
  }

  function wireTick(hpRatio){
    wireEnsureGeometry();

    const sev = clamp(1 - hpRatio, 0, 1);

    if (hpRatio <= 0) {
      for (let i=0;i<wire.cachedColors.length;i++) wire.cachedColors[i] = WR;
      return;
    }

    if (hpRatio >= 0.999999) {
      for (let i=0;i<wire.cachedColors.length;i++) wire.cachedColors[i] = WG;
      wire.oneYellowIdx = -1;
      return;
    }

    if (hpRatio >= 0.99) {
      if (wire.oneYellowIdx < 0) {
        wire.oneYellowIdx = (Math.random() * wire.cachedColors.length) | 0;
      }
      for (let i=0;i<wire.cachedColors.length;i++) wire.cachedColors[i] = WG;
      wire.cachedColors[wire.oneYellowIdx] = WY;
      return;
    }

    for (let i=0;i<wire.cachedColors.length;i++){
      let col =
        (sev >= wire.thR[i]) ? WR :
        (sev >= wire.thY[i]) ? WY :
        WG;

      if (i === wire.oneYellowIdx && col === WG) col = WY;
      wire.cachedColors[i] = col;
    }
  }

  function wStroke(a,b,color,lw,alpha=1){
    wctx.save();
    wctx.globalAlpha = alpha;
    wctx.beginPath();
    wctx.moveTo(a.x,a.y);
    wctx.lineTo(b.x,b.y);
    wctx.strokeStyle = color || WG; // âœ… safety
    wctx.lineWidth = lw;
    wctx.lineCap="round";
    wctx.lineJoin="round";
    wctx.stroke();
    wctx.restore();
  }

  function wStrokePoly(poly,color,lw,alpha=1){
    wctx.save();
    wctx.globalAlpha = alpha;
    wctx.beginPath();
    wctx.moveTo(poly[0].x, poly[0].y);
    for(let i=1;i<poly.length;i++) wctx.lineTo(poly[i].x, poly[i].y);
    wctx.closePath();
    wctx.strokeStyle = color;
    wctx.lineWidth = lw;
    wctx.lineCap="round";
    wctx.lineJoin="round";
    wctx.stroke();
    wctx.restore();
  }

  function drawWireStatusPanel(hpRatio, shieldRatio){
    wireEnsureGeometry();

    const ww = wireCanvas.width, wh = wireCanvas.height;
    wctx.clearRect(0,0,ww,wh);
    wctx.fillStyle = "#000";
    wctx.fillRect(0,0,ww,wh);

    // ë³´í˜¸ë§‰(íŒŒë€ í…Œë‘ë¦¬) â€” ë‹³ì„ìˆ˜ë¡ ì–‡ì•„ì§
    // âœ… í”„ë ˆì„ì´ 'ë”°ë¡œ ë…¸ëŠ”' ëŠë‚Œ ë°©ì§€: ìµœì™¸ê³½ ì‹¤ë£¨ì—£(shieldPoly) 1ê°œë§Œ ê·¸ë¦¼ + ë¸”ëŸ¬/ë‘ê»˜ ì œí•œ
    if (shieldRatio > 0.001) {
      const lw = clamp(shieldLW(shieldRatio), 2, 8);
      wctx.save();
      wctx.globalAlpha = 0.22 + 0.52*shieldRatio;
      wctx.shadowColor = "rgba(80,220,255,0.55)";
      wctx.shadowBlur  = 6 + 10*shieldRatio;
      const poly = wire.shieldPoly || (wire.outlinePolys ? wire.outlinePolys[0] : null);
      if (poly) wStrokePoly(poly, SB, lw, 1);
      wctx.restore();
    }

    // HP ì™€ì´ì–´
    const lwWire = 4.2;
    for (let i=0;i<wire.segs.length;i++){
      const [a,b] = wire.segs[i];
      wStroke(a,b, wire.cachedColors[i], lwWire, 0.92);
    }

    const hpPct = Math.round(hpRatio*100);
    const shPct = Math.round(shieldRatio*100);
    wireText.textContent = `HP ${hpPct}% / ë³´í˜¸ë§‰ ${shPct}%`;
  }

  // ---------- Game Loop ----------
  function tick(){
    const t = nowSec();
    const dtReal = clamp(t - state.lastTime, 0, 0.05);
    state.lastTime = t;

    // game time advances with speed multiplier
    const dt = clamp(dtReal * (state.speed || 1), 0, 0.08);
    state.gtime += dt;

    // ëŒ€ê¸°(ì›¨ì´ë¸Œ ì™¸)ì—ëŠ” ìŠ¤í‚¬/íŒ¨ì‹œë¸Œ ì¿¨íƒ€ì„ì´ íë¥´ì§€ ì•Šë„ë¡ ê³ ì •
    if (state.phase !== "wave") {
      const c = state.core;
      const pauseKeys = ["barrierReadyAt","aegisReadyAt","repairReadyAt","energyReadyAt","resDischargeReadyAt","rebuildEmergencyReadyAt","overloadBurstReadyAt","overloadExtendReadyAt","overloadKickReadyAt"];
      for (let i = 0; i < pauseKeys.length; i++) {
        const k = pauseKeys[i];
        if (c[k] != null) c[k] += dt;
      }

      // ìƒì (ì†Œë¹„ ì•„ì´í…œ) ì¿¨/ì§€ì†ì‹œê°„ë„ ì›¨ì´ë¸Œ ì‹œê°„ë§Œ ì†Œëª¨ë˜ë„ë¡ ì •ì§€
      const sh = state.shop;
      if (sh) {
        if (sh.repairReadyAt != null) sh.repairReadyAt += dt;
        if (sh.fireReadyAt != null)   sh.fireReadyAt   += dt;
        if (sh.slowReadyAt != null)   sh.slowReadyAt   += dt;
        if (sh.fireUntil != null)     sh.fireUntil     += dt;
      }
    }
    try {
      update(dt);
      draw();
      refreshUI();
    } catch (err) {
      console.error(err);
      const msg = (err && err.message) ? err.message : String(err);
      state.hardError = msg.slice(0, 140);
      // ìµœì†Œí•œ UIëŠ” ê°±ì‹ ë˜ë„ë¡ ì‹œë„
      try { draw(); refreshUI(); } catch {}
    }

    requestAnimationFrame(tick);
  }

  // ---------- Init ----------
  restart();
  syncCheatButtons();
  setSpeed(1.0);
  tick();
  } catch (err) {
    console.error(err);
    const msg = (err && err.message) ? err.message : String(err);
    const uiMsgEl = document.getElementById("uiMsg");
    if (uiMsgEl) uiMsgEl.textContent = "ì´ˆê¸°í™” ì˜¤ë¥˜: " + msg;

    // ìº”ë²„ìŠ¤ì—ë¼ë„ ì˜¤ë¥˜ë¥¼ í‘œì‹œ(ìŠ¤í¬ë¦½íŠ¸ê°€ ë©ˆì¶˜ ê²ƒì²˜ëŸ¼ ë³´ì´ëŠ” ë¬¸ì œ ë°©ì§€)
    const c0 = document.getElementById("c");
    try {
      if (c0 && c0.getContext) {
        const cctx = c0.getContext("2d");
        if (cctx) {
          cctx.clearRect(0,0,c0.width,c0.height);
          cctx.fillStyle = "#0b1220";
          cctx.fillRect(0,0,c0.width,c0.height);
          cctx.fillStyle = "#fca5a5";
          cctx.font = "18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          cctx.fillText("ì´ˆê¸°í™” ì˜¤ë¥˜: " + msg, 18, 36);
          cctx.fillStyle = "#93c5fd";
          cctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          cctx.fillText("F12 ì½˜ì†” ì˜¤ë¥˜ë¥¼ í™•ì¸í•˜ê±°ë‚˜, ìœ„ ë¬¸êµ¬ë¥¼ ë³´ë‚´ì£¼ì‹œë©´ ì¦‰ì‹œ ìˆ˜ì • ê°€ëŠ¥í•©ë‹ˆë‹¤.", 18, 60);
        }
      }
    } catch {}
  }

})();

</script>


<script>
(function(){
  // If boot flag didn't set, show a visible error for mobile local file restrictions.
  setTimeout(function(){
    if(!window.__CBD_BOOT_OK){
      var d=document.createElement('div');
      d.style.cssText='position:fixed;left:10px;right:10px;top:10px;z-index:99999;background:rgba(140,0,0,0.92);color:#fff;padding:10px 12px;border-radius:10px;font-weight:700;box-shadow:0 10px 30px rgba(0,0,0,0.45);';
      d.textContent='ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì‹¤íŒ¨: ì••ì¶•ì„ í’€ê³  í´ë”ì§¸ë¡œ ì—´ì–´ì£¼ì„¸ìš”. (Androidì—ì„œëŠ” content://ë¡œ ì—´ë©´ ì™¸ë¶€ JSê°€ ë§‰í ìˆ˜ ìˆì–´ ì¸ë¼ì¸ ë²„ì „ì„ ì‚¬ìš©í•©ë‹ˆë‹¤)';
      document.body.appendChild(d);
    }
  }, 1200);
})();
</script>

</body>
</html>
